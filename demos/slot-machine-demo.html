<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <base href="/">
  <title>Server-Backed Slot Machine Demo</title>
  <meta name="theme-color" content="#0d1117" />
  <link rel="stylesheet" href="dist/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500&display=swap" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #020617;
      --panel: color-mix(in srgb, var(--surface, #0f172a) 90%, black 10%);
      --panel-border: color-mix(in srgb, var(--surface-accent, #1e293b) 70%, transparent);
      --text: var(--text-light, #e2e8f0);
      --muted: color-mix(in srgb, var(--text) 65%, transparent);
      --accent: #facc15;
      --accent-2: #6366f1;
      --danger: #f87171;
      --radius: 16px;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(900px 600px at 50% -10%, rgba(99, 102, 241, .25), transparent 70%) var(--bg);
      color: var(--text);
      padding: clamp(16px, 3vw, 32px);
      display: block;
      overflow-y: auto;
    }
    html[data-embedded="true"] body {
      display: block;
    }
    main {
      width: min(960px, 100%);
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius);
      box-shadow: 0 20px 80px rgba(2, 6, 23, .6);
      padding: clamp(20px, 3vw, 32px);
      display: grid;
      gap: 24px;
      margin: 0 auto;
    }
    header h1 {
      font-family: "Space Grotesk", Inter, sans-serif;
      font-size: clamp(1.75rem, 3vw, 2.5rem);
      margin: 0 0 8px;
    }
    header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: .9rem;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 60%, transparent);
      background: rgba(99, 102, 241, .12);
    }
    .status-pill.ghost {
      background: rgba(255,255,255,.12);
      border-color: rgba(255,255,255,.2);
      color: rgba(255,255,255,.85);
    }
    .status-pill[data-state="error"] {
      color: var(--danger);
      background: rgba(244, 114, 182, .1);
    }
    .grid {
      display: grid;
      gap: 16px;
    }
    .grid-two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .panel {
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 40%, transparent);
      padding: 16px;
      background: rgba(15, 23, 42, .6);
    }
    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.05rem;
      font-weight: 600;
    }
    dl {
      margin: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 16px;
      font-size: .95rem;
    }
    dt {
      color: var(--muted);
      font-weight: 500;
    }
    dd {
      margin: 0;
      font-weight: 600;
    }
    .reels {
      display: grid;
      grid-template-columns: repeat(3, minmax(80px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .slot-cell {
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, white 12%, transparent);
      display: grid;
      place-items: center;
      font-size: 2.75rem;
      background: rgba(15, 23, 42, .8);
      box-shadow: inset 0 0 30px rgba(0,0,0,.3);
      transition: transform .45s cubic-bezier(.34, 1.56, .64, 1);
    }
    .slot-cell.spin {
      transform: scale(1.08) rotateX(360deg);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .controls label {
      font-size: .9rem;
      color: var(--muted);
    }
    .controls input[type="number"] {
      width: 120px;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(15, 23, 42, .8);
      color: inherit;
      font-size: 1rem;
    }
    .controls button {
      border: none;
      border-radius: 999px;
      padding: 12px 28px;
      font-size: .95rem;
      font-weight: 600;
      cursor: pointer;
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      box-shadow: 0 10px 30px rgba(250, 204, 21, .35);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .controls button[disabled] {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .controls button:not([disabled]):active {
      transform: translateY(1px);
    }
    .alert {
      padding: 12px 14px;
      border-radius: 10px;
      font-size: .95rem;
      background: rgba(248, 113, 113, .1);
      border: 1px solid rgba(248, 113, 113, .4);
      color: var(--danger);
    }
    .log {
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
      max-height: 160px;
      overflow-y: auto;
    }
    .log-entry + .log-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .ghost-btn {
      border: 1px solid rgba(255,255,255,.25);
      color: var(--muted);
      background: transparent;
      border-radius: 10px;
      padding: 8px 14px;
      font-size: .85rem;
      cursor: pointer;
    }
    .ghost-btn:disabled {
      opacity: .5;
      cursor: default;
    }
    .ghost-btn.primary {
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      border-color: transparent;
      font-weight: 600;
      box-shadow: 0 15px 35px rgba(250, 204, 21, .35);
    }
    .ghost-btn.secondary {
      color: var(--text);
      border-color: rgba(255,255,255,.25);
    }
    .ghost-btn.tertiary {
      color: var(--muted);
      border-color: transparent;
      background: rgba(255,255,255,.08);
    }
    .ghost-btn.danger {
      color: var(--danger);
      border-color: rgba(248,113,113,.5);
      background: rgba(248,113,113,.08);
    }
    .auth-overlay {
      position: fixed;
      inset: 0;
      z-index: 40;
      background: radial-gradient(circle at top, rgba(15,23,42,.9), rgba(2,6,23,.98));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(16px, 4vw, 48px);
      transition: opacity .35s ease, visibility .35s ease;
    }
    .auth-overlay[data-hidden="true"] {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .auth-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(20px, 5vw, 36px);
      width: min(960px, 100%);
      border-radius: 26px;
      border: 1px solid rgba(99,102,241,.35);
      background: linear-gradient(135deg, rgba(15,23,42,.95), rgba(30,64,175,.9));
      padding: clamp(24px, 5vw, 48px);
      box-shadow: 0 40px 150px rgba(2, 6, 23, .9);
      position: relative;
      overflow: hidden;
    }
    .auth-card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at top right, rgba(99,102,241,.4), transparent 45%);
      pointer-events: none;
    }
    .auth-copy {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 12px;
    }
    .auth-copy h2 {
      margin: 0;
      font-size: clamp(1.6rem, 3vw, 2.4rem);
      font-weight: 600;
      color: #fff;
    }
    .auth-copy p {
      margin: 0;
      color: color-mix(in srgb, #fff 85%, rgba(255,255,255,.4));
      line-height: 1.6;
    }
    .auth-body {
      position: relative;
      z-index: 1;
      background: rgba(2, 6, 23, .7);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.08);
      padding: clamp(18px, 4vw, 28px);
      display: grid;
      gap: 18px;
    }
    .auth-tabs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      padding: 5px;
    }
    .auth-tab {
      border: none;
      background: transparent;
      color: rgba(255,255,255,.7);
      font-weight: 600;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: background .2s ease, color .2s ease;
    }
    .auth-tab.active {
      background: rgba(255,255,255,.14);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .auth-forms {
      display: grid;
      gap: 15px;
    }
    .auth-forms label {
      display: grid;
      gap: 6px;
      font-size: .9rem;
      color: rgba(255,255,255,.7);
    }
    .auth-forms input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(15, 23, 42, .85);
      color: inherit;
      font-size: 1rem;
      transition: border .2s ease, box-shadow .2s ease;
    }
    .auth-forms input:focus-visible {
      outline: none;
      border-color: rgba(250,204,21,.65);
      box-shadow: 0 0 0 2px rgba(250,204,21,.2);
    }
    .auth-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .muted-text {
      color: rgba(255,255,255,.65);
      margin: 0;
      font-size: .9rem;
    }
    .muted-text.small {
      font-size: .8rem;
    }
    .alert {
      margin-top: 4px;
    }
    .auth-body[data-mode="login"] #auth-confirm-group {
      display: none;
    }
    .auth-body[data-mode="register"] #auth-info {
      display: none;
    }
    .account-panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      background: rgba(15,23,42,.75);
      border: 1px solid rgba(255,255,255,.06);
    }
    .slot-machine {
      background: linear-gradient(160deg, rgba(15,23,42,.92), rgba(30,41,59,.9));
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 24px;
      box-shadow: 0 25px 100px rgba(2,6,23,.6);
    }
    .slot-machine__header {
      display: flex;
      justify-content: space-between;
      gap: 24px;
      align-items: center;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(148,163,184,.2);
    }
    .slot-machine__header h2 {
      margin: 4px 0;
      font-size: clamp(1.4rem, 3vw, 2rem);
    }
    .jackpot {
      border-radius: 18px;
      padding: 14px 20px;
      background: linear-gradient(120deg, #e11d48, #f97316);
      color: #fff;
      text-align: center;
      min-width: 160px;
      box-shadow: 0 18px 45px rgba(241,135,0,.4);
    }
    .jackpot span {
      font-size: .8rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      opacity: .8;
    }
    .jackpot strong {
      display: block;
      font-size: 1.5rem;
      letter-spacing: .06em;
    }
    .slot-machine__body {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: clamp(16px, 4vw, 32px);
      padding-top: 20px;
    }
    .machine-frame {
      position: relative;
      border-radius: 26px;
      border: 1px solid rgba(148,163,184,.15);
      padding: clamp(16px, 3vw, 28px);
      background: radial-gradient(circle at top, rgba(14,165,233,.15), rgba(15,23,42,.95));
      overflow: hidden;
    }
    .machine-frame__glow {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 50% 20%, rgba(59,130,246,.4), transparent 45%);
      opacity: .8;
      pointer-events: none;
    }
    .machine-frame__reels {
      position: relative;
      display: block;
      background: rgba(2,6,23,.75);
      padding: clamp(18px, 3vw, 28px);
      border-radius: 20px;
      box-shadow: inset 0 0 20px rgba(0,0,0,.45);
    }
    .slot-grid {
      --reel-count: 3;
      --row-count: 3;
      display: grid;
      grid-template-columns: repeat(var(--reel-count), minmax(0, 1fr));
      gap: clamp(8px, 2vw, 18px);
    }
    .slot-cell {
      position: relative;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(180deg, rgba(15,23,42,.95), rgba(15,23,42,.6));
      aspect-ratio: 1 / 1.1;
      display: grid;
      place-items: center;
      overflow: hidden;
      transition: transform .3s ease, box-shadow .3s ease, border-color .3s ease;
    }
    .slot-cell[data-state="spinning"] {
      animation: slotPulse .6s ease-in-out infinite alternate;
      opacity: .9;
    }
    .slot-cell[data-state="win"] {
      box-shadow: 0 0 0 2px rgba(250,204,21,.45), 0 20px 45px rgba(250,204,21,.3);
      border-color: rgba(250,204,21,.6);
      transform: scale(1.03);
    }
    .slot-cell__symbol {
      width: 80%;
      max-width: 120px;
      display: grid;
      place-items: center;
    }
    .slot-cell__symbol img {
      width: 100%;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,.45));
    }
    .line-overlay {
      position: absolute;
      inset: clamp(12px, 2vw, 26px);
      pointer-events: none;
    }
    @keyframes slotPulse {
      0% { transform: translateY(-4px) scale(.98); opacity: .8; }
      100% { transform: translateY(4px) scale(1.02); opacity: 1; }
    }
    .machine-display {
      margin-top: 18px;
      border-radius: 16px;
      background: rgba(15,23,42,.8);
      border: 1px solid rgba(148,163,184,.2);
      padding: 14px 18px;
    }
    .machine-display__label {
      margin: 0;
      text-transform: uppercase;
      font-size: .8rem;
      letter-spacing: .08em;
      color: rgba(148,163,184,.8);
    }
    .machine-display__value {
      margin: 4px 0 0;
      font-size: 1.1rem;
      font-weight: 600;
    }
    .machine-display__meta {
      margin: 6px 0 0;
      font-size: .9rem;
      color: var(--muted);
    }
    .control-deck {
      display: grid;
      gap: 18px;
      background: rgba(2,6,23,.65);
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.18);
      padding: clamp(18px, 4vw, 28px);
    }
    .upgrade-panel {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(15,23,42,.8);
      padding: 18px;
      display: grid;
      gap: 12px;
    }
    .upgrade-panel h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }
    .upgrade-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.2);
      padding: 12px;
      background: rgba(2,6,23,.7);
      display: grid;
      gap: 6px;
    }
    .upgrade-card h4 {
      margin: 0;
      font-size: 1rem;
    }
    .upgrade-card p {
      margin: 0;
      font-size: .85rem;
      color: var(--muted);
      min-height: 32px;
    }
    .upgrade-card strong {
      font-size: .95rem;
    }
    .upgrade-card button {
      border: 1px solid rgba(255,255,255,.3);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: .85rem;
      background: transparent;
      color: var(--text);
      cursor: pointer;
    }
    .upgrade-card button[data-disabled="true"],
    .upgrade-card button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
    }
    .hud-card {
      border-radius: 14px;
      padding: 12px 14px;
      background: rgba(15,23,42,.9);
      border: 1px solid rgba(148,163,184,.2);
    }
    .hud-label {
      margin: 0;
      font-size: .8rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: rgba(148,163,184,.8);
    }
    .hud-value {
      font-size: 1.3rem;
      margin-top: 6px;
      display: block;
    }
    .bet-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .bet-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent, #facc15);
      height: 4px;
    }
    .chip {
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.9);
      color: #facc15;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: .95rem;
      cursor: pointer;
    }
    .chip:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .machine-messages {
      min-height: 32px;
    }
    .machine-error {
      margin: 0;
      color: #f97316;
      font-size: .9rem;
    }
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      align-items: center;
    }
    .spin-btn {
      border: none;
      border-radius: 99px;
      padding: 16px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      color: #020617;
      background: radial-gradient(circle at top, #bef264, #facc15);
      box-shadow: 0 18px 35px rgba(250,204,21,.45);
      cursor: pointer;
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .spin-btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .spin-btn:not(:disabled):active {
      transform: translateY(1px);
      box-shadow: 0 10px 25px rgba(250,204,21,.35);
    }
    .paytable-panel {
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.18);
      background: rgba(2,6,23,.7);
    }
    .paytable {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 12px;
    }
    .paytable li {
      display: flex;
      justify-content: space-between;
      background: rgba(15,23,42,.85);
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 14px;
      padding: 12px 16px;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .paytable-symbol {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }
    .paytable-symbol img {
      width: 36px;
      height: 36px;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
    }
    .paytable-meta {
      font-size: .9rem;
      color: rgba(148,163,184,.85);
    }
    @media (max-width: 640px) {
      .slot-machine__body {
        grid-template-columns: 1fr;
      }
      .slot-grid {
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <div class="auth-overlay" id="auth-overlay" aria-hidden="false" data-hidden="false">
    <div class="auth-card">
      <div class="auth-copy">
        <p class="status-pill ghost">üé∞ Demo Slot Machine</p>
        <h2>Log in to save your credits and keep the reels rolling.</h2>
        <p>This is a fun, server-backed slot machine demo‚Äîno real money is involved. Every spin is validated in AWS so balances carry across devices.</p>
        <p class="muted-text small">Passwords are hashed before storing and sessions auto-expire. Have fun exploring the animations and payouts.</p>
      </div>
      <div class="auth-body" id="auth-body" data-mode="login">
        <div class="auth-tabs" role="tablist">
          <button type="button" class="auth-tab active" data-mode="login">Sign In</button>
          <button type="button" class="auth-tab" data-mode="register">Create Account</button>
        </div>
        <div class="auth-forms">
          <label>
            Email
            <input type="email" id="auth-email" autocomplete="email" placeholder="you@example.com" required />
          </label>
          <label>
            Password
            <input type="password" id="auth-password" autocomplete="current-password" placeholder="At least 8 characters" required />
          </label>
          <label id="auth-confirm-group" hidden>
            Confirm password
            <input type="password" id="auth-confirm" autocomplete="new-password" placeholder="Repeat password" />
          </label>
          <div class="auth-actions">
            <button type="button" class="ghost-btn primary" id="auth-submit">Sign In</button>
            <button type="button" class="ghost-btn tertiary" id="auth-info">Need access? Register in seconds.</button>
          </div>
          <p class="muted-text small" id="auth-note">Passwords never leave AWS without hashing. Sessions expire automatically to keep balances safe.</p>
          <div class="alert" id="auth-alert" hidden></div>
        </div>
      </div>
    </div>
  </div>
  <a class="skip-link" href="#main">Skip to content</a>
  <main id="main" data-api-base="https://4kvebym8b3.execute-api.us-east-2.amazonaws.com/prod" data-max-bet="100" data-machine-config="slot-config/classic.json">
    <header class="grid">
      <div>
        <p class="status-pill" id="connection-pill" data-state="loading">
          <span aria-hidden="true">üõ∞Ô∏è</span>
          <span id="connection-text">Connecting to AWS‚Ä¶</span>
        </p>
        <h1>Server-Backed Slot Machine</h1>
        <p>This demo uses an AWS Lambda function, API Gateway, and DynamoDB table so every spin is validated on the server. The browser can render the reels, but it cannot change your credit balance or payout.</p>
      </div>
    </header>

    <section class="panel account-panel" id="account-panel" data-requires-auth hidden>
      <div>
        <p class="muted-text">Signed in as</p>
        <strong id="account-user"></strong>
      </div>
      <div class="actions">
        <button type="button" class="ghost-btn danger" id="delete-account-btn">Delete account</button>
        <button type="button" class="ghost-btn secondary" id="logout-btn">Sign out</button>
      </div>
    </section>

    <section class="panel slot-machine" data-requires-auth hidden>
      <div class="slot-machine__header">
        <div>
          <p class="muted-text small">Lucky Lambda Slots</p>
          <h2>Server-validated spins with cinematic reels.</h2>
          <p class="muted-text">Every result routes through AWS Lambda + DynamoDB, so payouts are locked before they reach your browser.</p>
        </div>
        <div class="jackpot">
          <span>Progressive Demo</span>
          <strong>$1,000,000</strong>
        </div>
      </div>
      <div class="slot-machine__body">
        <div class="machine-frame">
          <div class="machine-frame__glow"></div>
          <div class="machine-frame__reels" id="reel-stage">
            <div class="slot-grid" id="slot-grid" aria-live="polite"></div>
            <div class="line-overlay" id="line-overlay" aria-hidden="true"></div>
          </div>
          <div class="machine-display">
            <p class="machine-display__label">Last outcome</p>
            <p class="machine-display__value" id="machine-outcome">Sign in to start spinning.</p>
            <p class="machine-display__meta" id="machine-lines"></p>
          </div>
        </div>
        <div class="control-deck">
          <div class="hud">
            <div class="hud-card">
              <p class="hud-label">Credits</p>
              <strong class="hud-value" id="hud-balance">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Bet</p>
              <strong class="hud-value" id="hud-bet">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Last win</p>
              <strong class="hud-value" id="hud-win">$0</strong>
            </div>
          </div>
          <div class="bet-controls">
            <button type="button" class="chip" data-chip="decrease" aria-label="Decrease bet">-</button>
            <input type="range" id="bet-range" min="1" max="100" value="25" aria-label="Bet amount" />
            <button type="button" class="chip" data-chip="increase" aria-label="Increase bet">+</button>
            <button type="button" class="chip" data-chip="max" aria-label="Max bet">Max</button>
          </div>
          <div class="machine-messages">
            <p class="machine-error" id="error" role="status" aria-live="polite"></p>
            <div class="alert" id="alert" hidden></div>
          </div>
          <div class="action-buttons">
            <button type="button" class="ghost-btn secondary" id="sync-btn">Sync balance</button>
            <button type="button" class="ghost-btn tertiary" id="reset-btn">Reset session</button>
            <button type="button" class="spin-btn" id="spin-btn" disabled>Spin</button>
          </div>
          <div class="upgrade-panel" id="upgrade-panel" data-requires-auth hidden>
            <h3>Machine Upgrades</h3>
            <div class="upgrade-grid" id="upgrade-grid"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="grid grid-two" data-requires-auth hidden>
      <div class="panel">
        <h2>Session</h2>
        <dl id="session-stats">
          <dt>Player ID</dt><dd id="player-id">‚Äî</dd>
          <dt>Balance</dt><dd id="balance">‚Äî</dd>
          <dt>Max Bet</dt><dd id="max-bet">‚Äî</dd>
          <dt>Total Spins</dt><dd id="spin-count">‚Äî</dd>
        </dl>
      </div>
      <div class="panel">
        <h2>Last Result</h2>
        <dl>
          <dt>Outcome</dt><dd id="last-outcome">‚Äî</dd>
          <dt>Winnings</dt><dd id="last-win">‚Äî</dd>
          <dt>Multiplier</dt><dd id="last-multiplier">‚Äî</dd>
          <dt>Timestamp</dt><dd id="last-time">‚Äî</dd>
        </dl>
      </div>
    </section>

    <section class="panel paytable-panel" data-requires-auth hidden>
      <h2>Paytable</h2>
      <ul class="paytable" id="paytable"></ul>
      <p class="muted-text small">Multipliers apply to your active bet. Triple matches and pairs are calculated server-side.</p>
    </section>

    <section class="panel" data-requires-auth hidden>
      <h2>Server Event Log</h2>
      <div class="log" id="log" aria-live="polite"></div>
    </section>
  </main>

  <script>
    (() => {
      const DEBUG = true;
      const debug = (...args) => DEBUG && console.debug('[slot-demo]', ...args);
      const debugError = (scope, error, extra = {}) => {
        if (!DEBUG) return;
        console.error(`[slot-demo][${scope}]`, error, extra);
      };
      window.addEventListener('error', (event) => {
        debugError('window-error', event.error || event.message, { event });
      });
      window.addEventListener('unhandledrejection', (event) => {
        debugError('unhandled-rejection', event.reason, {});
      });

      const root = document.getElementById('main');
      if (!root) {
        debugError('init', 'Missing #main element');
        return;
      }
      const API_BASE = root.dataset.apiBase;
      const DEFAULT_MAX_BET = Number(root.dataset.maxBet) || 100;
      const MACHINE_CONFIG_URL = root.dataset.machineConfig || '';
      const storageKeys = {
        player: 'slotMachineDemoPlayerId',
        token: 'slotMachineAuthToken',
        user: 'slotMachineAuthUser'
      };
      const AUTH_MODE_KEY = 'slotMachineAuthMode';
      const getStored = (key) => {
        const value = localStorage.getItem(key);
        return value && value !== 'null' ? value : null;
      };
      const DEFAULT_SYMBOLS = [
        { key: 'cherry', label: 'Cherry', asset: 'img/slot/classic/symbols/cherry.png' },
        { key: 'lemon', label: 'Lemon', asset: 'img/slot/classic/symbols/lemon.png' },
        { key: 'orange', label: 'Orange', asset: 'img/slot/classic/symbols/orange.png' },
        { key: 'plum', label: 'Plum', asset: 'img/slot/classic/symbols/plum.png' },
        { key: 'watermelon', label: 'Watermelon', asset: 'img/slot/classic/symbols/watermelon.png' },
        { key: 'horseshoe', label: 'Horseshoe', asset: 'img/slot/classic/symbols/horseshoe.png' },
        { key: 'bell', label: 'Bell', asset: 'img/slot/classic/symbols/bell.png' },
        { key: 'diamond', label: 'Diamond', asset: 'img/slot/classic/symbols/diamond.png' },
        { key: 'seven', label: 'Lucky Seven', asset: 'img/slot/classic/symbols/seven.png' },
        { key: 'crown', label: 'Crown', asset: 'img/slot/classic/symbols/crown.png' },
        { key: 'wild', label: 'Wild', asset: 'img/slot/classic/symbols/wild.png' },
        { key: 'bonus', label: 'Bonus Sigil', asset: 'img/slot/classic/symbols/bonus.png' }
      ];
      const PLACEHOLDER_ASSET = 'img/slot/placeholder.png';
      const buildSymbolMap = (symbols = [], baseMap = null, placeholderAsset = PLACEHOLDER_ASSET) => {
        const seedEntries = baseMap
          ? Array.from(baseMap.entries())
          : DEFAULT_SYMBOLS.map(entry => [entry.key, { ...entry }]);
        const map = new Map(seedEntries.map(([key, val]) => [key, { ...val, asset: val.asset || placeholderAsset }]));
        if (!Array.isArray(symbols) || !symbols.length) return map;
        symbols.forEach(entry => {
          if (!entry || !entry.key) return;
          const prev = map.get(entry.key) || { key: entry.key, label: entry.label || entry.key, asset: placeholderAsset };
          map.set(entry.key, {
            ...prev,
            ...entry,
            asset: entry.asset || prev.asset || placeholderAsset
          });
        });
        return map;
      };
      const cloneSymbolMap = (map) => new Map(Array.from(map.entries()).map(([key, val]) => [key, { ...val }]));
      const DEFAULT_SYMBOL_MAP = buildSymbolMap(DEFAULT_SYMBOLS, null, PLACEHOLDER_ASSET);

      const state = {
        playerId: null,
        balance: 0,
        maxBet: DEFAULT_MAX_BET,
        bet: 25,
        busy: false,
        gameReady: false,
        auth: {
          token: getStored(storageKeys.token),
          username: getStored(storageKeys.user)
        },
        authMode: localStorage.getItem(AUTH_MODE_KEY) || 'login',
        machine: {
          id: 'classic',
          name: 'Lucky Lambda Classic',
          rows: 3,
          reels: 5,
          lineTier: 0,
          lines: [],
          payouts: {},
          assets: {},
          placeholder: PLACEHOLDER_ASSET,
          upgradeSettings: {
            baseRows: 3,
            maxRows: 5,
            baseReels: 3,
            maxReels: 5,
            costs: { rows: [], reels: [], lines: [] }
          }
        },
        symbolMap: cloneSymbolMap(DEFAULT_SYMBOL_MAP),
        gridCells: new Map(),
        upgrades: { rows: 0, reels: 0, lines: 0 },
        currentRows: 3,
        currentReels: 5,
        currentLineTier: 0
      };
      window.slotDemoDebug = window.slotDemoDebug || {};
      window.slotDemoDebug.state = state;
      window.slotDemoDebug.log = debug;
      window.slotDemoDebug.dumpState = () => JSON.parse(JSON.stringify({
        ...state,
        symbolMap: Array.from(state.symbolMap.keys()),
        upgrades: { ...state.upgrades }
      }));

      const currency = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const resolveMaxBet = (incoming) => {
        const numeric = Number(incoming);
        if (Number.isFinite(numeric) && numeric > 0) return numeric;
        if (Number.isFinite(state.maxBet) && state.maxBet > 0) return state.maxBet;
        return DEFAULT_MAX_BET;
      };

      const els = {
        connectionPill: document.getElementById('connection-pill'),
        connectionText: document.getElementById('connection-text'),
        slotGrid: document.getElementById('slot-grid'),
        lineOverlay: document.getElementById('line-overlay'),
        spinBtn: document.getElementById('spin-btn'),
        resetBtn: document.getElementById('reset-btn'),
        syncBtn: document.getElementById('sync-btn'),
        alert: document.getElementById('alert'),
        error: document.getElementById('error'),
        machineOutcome: document.getElementById('machine-outcome'),
        machineLines: document.getElementById('machine-lines'),
        reelStage: document.getElementById('reel-stage'),
        betSlider: document.getElementById('bet-range'),
        chipButtons: Array.from(document.querySelectorAll('[data-chip]')),
        hudBalance: document.getElementById('hud-balance'),
        hudBet: document.getElementById('hud-bet'),
        hudWin: document.getElementById('hud-win'),
        balance: document.getElementById('balance'),
        playerId: document.getElementById('player-id'),
        maxBet: document.getElementById('max-bet'),
        spinCount: document.getElementById('spin-count'),
        lastOutcome: document.getElementById('last-outcome'),
        lastWin: document.getElementById('last-win'),
        lastMult: document.getElementById('last-multiplier'),
        lastTime: document.getElementById('last-time'),
        log: document.getElementById('log'),
        paytable: document.getElementById('paytable'),
        authOverlay: document.getElementById('auth-overlay'),
        authBody: document.getElementById('auth-body'),
        authAlert: document.getElementById('auth-alert'),
        authEmail: document.getElementById('auth-email'),
        authPassword: document.getElementById('auth-password'),
        authConfirmGroup: document.getElementById('auth-confirm-group'),
        authConfirm: document.getElementById('auth-confirm'),
        authSubmit: document.getElementById('auth-submit'),
        authInfo: document.getElementById('auth-info'),
        authTabs: Array.from(document.querySelectorAll('.auth-tab')),
        authOverlayNote: document.getElementById('auth-note'),
        accountPanel: document.getElementById('account-panel'),
        accountUser: document.getElementById('account-user'),
        logoutBtn: document.getElementById('logout-btn'),
        deleteBtn: document.getElementById('delete-account-btn'),
        upgradeGrid: document.getElementById('upgrade-grid'),
        upgradePanel: document.getElementById('upgrade-panel')
      };
      const probedSymbols = new Set();
      const getPlaceholderAsset = () => state?.machine?.assets?.placeholder || state?.machine?.placeholder || PLACEHOLDER_ASSET;
      const auditSymbolAssets = () => {
        state.symbolMap.forEach(entry => {
          if (!entry || !entry.key || !entry.asset || probedSymbols.has(entry.key)) return;
          probedSymbols.add(entry.key);
          const img = new Image();
          img.addEventListener('load', () => {
            debug('asset:load-ok', { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.addEventListener('error', () => {
            debugError('asset:load-failed', new Error('Failed to load symbol asset'), { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.src = entry.asset;
        });
      };
      const attachImageDebugging = (img, symbolKey) => {
        if (!img || img.dataset.debugAttached) return;
        img.dataset.debugAttached = 'true';
        img.addEventListener('error', () => {
          debugError('image', new Error('Image failed to load'), { symbol: symbolKey || img.dataset.symbolKey || img.alt, src: img.currentSrc || img.src });
          img.src = getPlaceholderAsset();
        });
      };
      const getSymbolEntry = (symbolKey) => {
        if (!symbolKey) {
          return { key: 'placeholder', label: 'Symbol', asset: getPlaceholderAsset() };
        }
        const entry = state.symbolMap.get(symbolKey) || DEFAULT_SYMBOL_MAP.get(symbolKey);
        if (entry) {
          return { ...entry, asset: entry.asset || getPlaceholderAsset() };
        }
        return { key: symbolKey, label: symbolKey, asset: getPlaceholderAsset() };
      };
      const applySymbolToImage = (img, symbolKey) => {
        const info = getSymbolEntry(symbolKey);
        if (!img) return info;
        const needsUpdate = img.dataset.symbolKey !== info.key || img.dataset.symbolAsset !== info.asset;
        if (needsUpdate) {
          img.dataset.symbolKey = info.key;
          img.dataset.symbolAsset = info.asset;
          img.alt = info.label || info.key;
          img.src = info.asset || getPlaceholderAsset();
          if (!info.asset || info.asset === getPlaceholderAsset()) {
            debug('symbol:placeholder-used', { symbol: info.key, reason: 'missing asset' });
          }
        }
        attachImageDebugging(img, info.key);
        return info;
      };
      const upgradeDefinitions = {
        rows: {
          label: 'Extra Rows',
          description: 'Adds another horizontal row so more lines can form.',
          format: (current, max) => `${current}/${max} rows`
        },
        reels: {
          label: 'Extra Reels',
          description: 'Extends the machine vertically for longer combos.',
          format: (current, max) => `${current}/${max} reels`
        },
        lines: {
          label: 'Line Patterns',
          description: 'Unlocks diagonal and zig-zag paylines.',
          format: (current, max) => `${current}/${max} tiers`
        }
      };
      const getUpgradeSettings = () => {
        const defaults = {
          baseRows: 3,
          maxRows: 5,
          baseReels: 3,
          maxReels: 5,
          costs: { rows: [], reels: [], lines: [] }
        };
        const settings = state.machine.upgradeSettings || state.machine.upgrades || {};
        return {
          baseRows: settings.baseRows ?? defaults.baseRows,
          maxRows: settings.maxRows ?? defaults.maxRows,
          baseReels: settings.baseReels ?? defaults.baseReels,
          maxReels: settings.maxReels ?? defaults.maxReels,
          costs: settings.costs || defaults.costs
        };
      };
      state.playerId = state.auth.token ? null : getStored(storageKeys.player);

      const log = (message, data) => {
        debug('ui-log', { message, data, stateSnapshot: { busy: state.busy, auth: !!state.auth.token } });
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<strong>${time}</strong> ‚Äî ${message}${data ? `<br><span>${data}</span>` : ''}`;
        els.log.prepend(entry);
        const entries = els.log.querySelectorAll('.log-entry');
        if (entries.length > 40) {
          entries[entries.length - 1].remove();
        }
      };

      const setStatus = (text, stateAttr = 'ok') => {
        debug('ui:setStatus', { text, stateAttr });
        els.connectionText.textContent = text;
        els.connectionPill.dataset.state = stateAttr;
        els.connectionPill.dataset.state === 'ok'
          ? els.connectionPill.setAttribute('data-state', 'ok')
          : els.connectionPill.setAttribute('data-state', stateAttr);
      };

      const showAlert = (text = '') => {
        els.alert.hidden = !text;
        els.alert.textContent = text;
        if (text) debug('ui:alert', text);
      };

      const showAuthAlert = (text = '') => {
        if (text) debug('auth:alert', text);
        if (!els.authAlert) return;
        els.authAlert.hidden = !text;
        els.authAlert.textContent = text;
      };

      const gamePanels = Array.from(document.querySelectorAll('[data-requires-auth]'));

      const setGameVisibility = (visible) => {
        debug('ui:setGameVisibility', { visible });
        state.gameReady = visible;
        gamePanels.forEach(panel => {
          panel.hidden = !visible;
        });
        const disableInputs = !visible || state.busy;
        els.spinBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.resetBtn) els.resetBtn.disabled = disableInputs;
        renderUpgrades();
      };

      const setBusy = (flag) => {
        debug('ui:setBusy', { flag, prev: state.busy });
        state.busy = flag;
        const disableInputs = flag || !state.gameReady;
        els.spinBtn.disabled = disableInputs;
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        renderUpgrades();
      };

      const toggleAuthInputs = (disabled) => {
        [els.authEmail, els.authPassword, els.authConfirm, els.authSubmit, els.authInfo].forEach(node => {
          if (node) node.disabled = disabled;
        });
        (els.authTabs || []).forEach(btn => {
          btn.disabled = disabled;
        });
      };

      const randomSymbolInfo = () => {
        const entries = Array.from(state.symbolMap.values());
        if (!entries.length) {
          return getSymbolEntry('placeholder');
        }
        return entries[Math.floor(Math.random() * entries.length)];
      };

      const renderUpgrades = () => {
        if (!els.upgradeGrid) return;
        const settings = getUpgradeSettings();
        const costs = settings.costs || {};
        const loggedIn = Boolean(state.auth.token);
        if (els.upgradePanel) {
          els.upgradePanel.hidden = !state.gameReady || !loggedIn;
        }
        const cards = ['rows', 'reels', 'lines'].map(key => {
          const def = upgradeDefinitions[key];
          const level = state.upgrades?.[key] || 0;
          const costList = costs[key] || [];
          const maxLevel = costList.length;
          let currentValue = '';
          let maxValue = '';
          if (key === 'rows') {
            currentValue = state.currentRows || settings.baseRows;
            maxValue = settings.maxRows;
          } else if (key === 'reels') {
            currentValue = state.currentReels || settings.baseReels;
            maxValue = settings.maxReels;
          } else {
            currentValue = Math.min(level, maxLevel);
            maxValue = maxLevel;
          }
          const cost = costList[level];
          const atMax = level >= maxLevel || !Number.isFinite(cost);
          const valueText = def?.format
            ? def.format(currentValue, maxValue)
            : `${currentValue}/${maxValue}`;
          const disabledAttr = (!loggedIn || state.busy) ? 'data-disabled="true" disabled' : '';
          const button = atMax
            ? `<button type="button" data-disabled="true" disabled>Maxed</button>`
            : `<button type="button" data-upgrade="${key}" ${disabledAttr}>Unlock (${cost} credits)</button>`;
          return `
            <div class="upgrade-card">
              <h4>${def?.label || key}</h4>
              <p>${def?.description || ''}</p>
              <strong>${valueText}</strong>
              ${button}
            </div>
          `;
        }).join('');
        els.upgradeGrid.innerHTML = cards;
      };

      const ensureGrid = (rows, reels) => {
        if (!els.slotGrid) return;
        const currentRows = Number(els.slotGrid.dataset.rows) || 0;
        const currentReels = Number(els.slotGrid.dataset.reels) || 0;
        if (currentRows === rows && currentReels === reels && state.gridCells.size === rows * reels) {
          return;
        }
        debug('grid:rebuild', { rows, reels });
        state.gridCells.clear();
        els.slotGrid.dataset.rows = rows;
        els.slotGrid.dataset.reels = reels;
        els.slotGrid.style.setProperty('--row-count', rows);
        els.slotGrid.style.setProperty('--reel-count', reels);
        els.slotGrid.innerHTML = '';
        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < reels; col += 1) {
            const cell = document.createElement('div');
            cell.className = 'slot-cell';
            cell.dataset.row = row.toString();
            cell.dataset.col = col.toString();
            const wrapper = document.createElement('div');
            wrapper.className = 'slot-cell__symbol';
            const img = document.createElement('img');
            const seedSymbol = randomSymbolInfo();
            applySymbolToImage(img, seedSymbol.key);
            wrapper.appendChild(img);
            cell.appendChild(wrapper);
            els.slotGrid.appendChild(cell);
            cell.dataset.symbol = seedSymbol.key;
            state.gridCells.set(`${row}:${col}`, cell);
          }
        }
      };

      const updateMachineMeta = () => {
        if (!els.machineLines) return;
        const settings = getUpgradeSettings();
        const lineTier = state.currentLineTier ?? 0;
        const patterns = Array.isArray(state.machine.lines) ? state.machine.lines : [];
        const lineCount = patterns.filter(def => def.tier <= lineTier).length || patterns.length || 0;
        const rows = state.currentRows || settings.baseRows;
        const reels = state.currentReels || settings.baseReels;
        const parts = [
          `${rows}/${settings.maxRows} rows`,
          `${reels}/${settings.maxReels} reels`
        ];
        if (lineCount) parts.push(`${lineCount} lines`);
        els.machineLines.textContent = parts.join(' ‚Ä¢ ');
      };

      const applyMachineTheme = () => {
        if (!els.reelStage) return;
        const assets = state.machine.assets || {};
        const bg = assets.background || {};
        const portrait = typeof bg === 'string' ? bg : bg.portrait;
        const landscape = typeof bg === 'string' ? bg : bg.landscape;
        const useLandscape = window.innerWidth > window.innerHeight;
        const chosen = useLandscape ? (landscape || portrait) : (portrait || landscape);
        if (chosen) {
          els.reelStage.style.backgroundImage = `url('${chosen}')`;
          els.reelStage.style.backgroundSize = 'cover';
          els.reelStage.style.backgroundPosition = 'center';
        }
      };

      const updateGridSymbols = (grid = []) => {
        const rows = state.machine.rows;
        const reels = state.machine.reels;
        ensureGrid(rows, reels);
        for (let row = 0; row < rows; row += 1) {
          const rowSymbols = grid[row] || [];
          for (let col = 0; col < reels; col += 1) {
            const symbolKey = rowSymbols[col] || randomSymbolInfo().key;
            const cell = state.gridCells.get(`${row}:${col}`);
            if (!cell) continue;
            const img = cell.querySelector('img');
            const info = applySymbolToImage(img, symbolKey);
            cell.dataset.symbol = info.key;
            if (cell.dataset.state !== 'win') {
              cell.dataset.state = 'settled';
            }
            debug('grid:update-cell', { row, col, symbol: info.key });
          }
        }
      };

      const setGridState = (mode) => {
        state.gridCells.forEach(cell => {
          cell.dataset.state = mode;
        });
      };

      const startGridSpin = () => {
        if (!state.gridCells.size) ensureGrid(state.machine.rows, state.machine.reels);
        setGridState('spinning');
      };

      const stopGridSpin = (grid) => {
        if (Array.isArray(grid)) {
          updateGridSymbols(grid);
        } else {
          state.gridCells.forEach(cell => {
            if (cell.dataset.state === 'spinning') cell.dataset.state = 'settled';
          });
        }
      };

      const highlightWins = (groups = []) => {
        state.gridCells.forEach(cell => {
          if (cell.dataset.state === 'spinning') return;
          cell.dataset.state = 'settled';
        });
        if (!groups.length) return;
        groups.forEach(group => {
          if (group.symbol === 'bonus') {
            state.gridCells.forEach(cell => {
              if (cell.dataset.symbol === 'bonus') cell.dataset.state = 'win';
            });
            return;
          }
          if (!Array.isArray(group.pattern) || !Array.isArray(group.indexes)) return;
          group.indexes.forEach(index => {
            const row = Math.max(0, Math.min(group.pattern[index] ?? 0, state.machine.rows - 1));
            const cell = state.gridCells.get(`${row}:${index}`);
            if (cell) cell.dataset.state = 'win';
          });
        });
      };

      function renderPaytable() {
        if (!els.paytable) return;
        if (!state.symbolMap.size) {
          state.symbolMap = cloneSymbolMap(DEFAULT_SYMBOL_MAP);
        }
        const entries = Array.from(state.symbolMap.values());
        els.paytable.innerHTML = entries.map(entry => {
          const payout = state.machine.payouts[entry.key] || 0;
          const tiers = [1, 2, 3].map(mult => `${mult + 2}√ó ${payout ? payout * mult : 0}√ó bet`).join(' ‚Ä¢ ');
          const asset = entry.asset || getPlaceholderAsset();
          if (!entry.asset || asset === getPlaceholderAsset()) {
            debug('paytable:placeholder', { symbol: entry.key });
          }
          return `
            <li>
              <div class="paytable-symbol">
                <img src="${asset}" alt="${entry.label}" data-symbol="${entry.key}" loading="lazy">
                ${entry.label}
              </div>
              <div class="paytable-meta">${tiers}</div>
            </li>
          `;
        }).join('');
        els.paytable.querySelectorAll('.paytable-symbol img').forEach(img => {
          attachImageDebugging(img, img.dataset.symbol);
        });
        debug('paytable:render', { symbols: entries.length });
      }

      const setSymbolMap = (symbols = [], reason = 'update') => {
        state.symbolMap = buildSymbolMap(symbols, state.symbolMap || DEFAULT_SYMBOL_MAP, getPlaceholderAsset());
        debug('symbols:set', { reason, count: state.symbolMap.size });
        auditSymbolAssets();
        renderPaytable();
      };
      setSymbolMap(DEFAULT_SYMBOLS, 'init');
      applyUpgradeState(state.upgrades);

      function applyUpgradeState(incoming = state.upgrades) {
        const base = state.upgrades || { rows: 0, reels: 0, lines: 0 };
        const normalized = {
          rows: Math.max(0, incoming?.rows ?? base.rows ?? 0),
          reels: Math.max(0, incoming?.reels ?? base.reels ?? 0),
          lines: Math.max(0, incoming?.lines ?? base.lines ?? 0)
        };
        const settings = getUpgradeSettings();
        const maxLineLevel = (settings.costs?.lines || []).length;
        if (maxLineLevel >= 0) {
          normalized.lines = Math.min(normalized.lines, maxLineLevel);
        }
        state.upgrades = normalized;
        const maxLineTier = state.machine.lineTier || (state.machine.lines?.[state.machine.lines.length - 1]?.tier ?? 3);
        const rows = Math.min(settings.maxRows, (settings.baseRows || 3) + normalized.rows);
        const reels = Math.min(settings.maxReels, (settings.baseReels || 3) + normalized.reels);
        const lineTier = Math.min(maxLineTier, normalized.lines);
        state.currentRows = rows;
        state.currentReels = reels;
        state.currentLineTier = lineTier;
        state.machine.rows = rows;
        state.machine.reels = reels;
        state.machine.currentRows = rows;
        state.machine.currentReels = reels;
        state.machine.currentLineTier = lineTier;
        ensureGrid(rows, reels);
        renderUpgrades();
        updateMachineMeta();
      }

      const syncMachineDefinition = (machine = {}) => {
        if (!machine || typeof machine !== 'object') return;
        state.machine.id = machine.id || state.machine.id;
        state.machine.name = machine.name || state.machine.name;
        state.machine.lineTier = Number(machine.lineTier) || state.machine.lineTier;
        state.machine.rows = Number(machine.rows) || state.machine.rows;
        state.machine.reels = Number(machine.reels) || state.machine.reels;
        if (Array.isArray(machine.lines)) state.machine.lines = machine.lines;
        if (machine.payouts) state.machine.payouts = machine.payouts;
        if (machine.assets) state.machine.assets = { ...state.machine.assets, ...machine.assets };
        state.machine.upgradeSettings = {
          baseRows: machine.upgrades?.baseRows ?? state.machine.upgradeSettings?.baseRows ?? state.machine.rows,
          maxRows: machine.upgrades?.maxRows ?? state.machine.upgradeSettings?.maxRows ?? state.machine.rows,
          baseReels: machine.upgrades?.baseReels ?? state.machine.upgradeSettings?.baseReels ?? state.machine.reels,
          maxReels: machine.upgrades?.maxReels ?? state.machine.upgradeSettings?.maxReels ?? state.machine.reels,
          costs: machine.upgrades?.costs || state.machine.upgradeSettings?.costs || {}
        };
        setSymbolMap(Array.isArray(machine.symbols) ? machine.symbols : [], 'syncMachineDefinition');
        applyUpgradeState(state.upgrades);
      };

      const loadMachineConfig = async () => {
        debug('machine-config:load', { url: MACHINE_CONFIG_URL });
        if (!MACHINE_CONFIG_URL) {
          ensureGrid(state.machine.rows, state.machine.reels);
          debug('machine-config:skipped', 'no URL provided');
          return;
        }
        try {
          const res = await fetch(MACHINE_CONFIG_URL, { cache: 'no-cache' });
          if (!res.ok) throw new Error(`Config ${res.status}`);
          const data = await res.json();
          state.machine.assets = data.assets || state.machine.assets;
          state.machine.placeholder = data.assets?.placeholder || state.machine.placeholder;
          if (data.payouts) state.machine.payouts = data.payouts;
          if (Number(data.rows)) state.machine.rows = Number(data.rows);
          if (Number(data.reels)) state.machine.reels = Number(data.reels);
          state.machine.upgradeSettings = {
            baseRows: data.baseRows ?? state.machine.upgradeSettings?.baseRows ?? state.machine.rows,
            maxRows: data.maxRows ?? state.machine.upgradeSettings?.maxRows ?? state.machine.rows,
            baseReels: data.baseReels ?? state.machine.upgradeSettings?.baseReels ?? state.machine.reels,
            maxReels: data.maxReels ?? state.machine.upgradeSettings?.maxReels ?? state.machine.reels,
            costs: data.upgradeCosts || state.machine.upgradeSettings?.costs || {}
          };
          setSymbolMap(Array.isArray(data.symbols) ? data.symbols : [], 'machineConfig');
          applyUpgradeState(state.upgrades);
          applyMachineTheme();
          debug('machine-config:loaded', { rows: state.machine.rows, reels: state.machine.reels, symbols: state.symbolMap.size });
        } catch (error) {
          console.error('Machine config failed', error);
          log('Assets', 'Unable to load slot assets.');
          debugError('machine-config', error);
          ensureGrid(state.machine.rows, state.machine.reels);
        }
      };

      const setAuthMode = (mode = 'login') => {
        debug('auth:setMode', mode);
        const nextMode = mode === 'register' ? 'register' : 'login';
        state.authMode = nextMode;
        localStorage.setItem(AUTH_MODE_KEY, nextMode);
        if (els.authBody) {
          els.authBody.dataset.mode = nextMode;
        }
        (els.authTabs || []).forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === nextMode);
        });
        if (els.authSubmit) {
          els.authSubmit.textContent = nextMode === 'register' ? 'Create Account' : 'Sign In';
        }
        if (els.authConfirmGroup) {
          els.authConfirmGroup.hidden = nextMode !== 'register';
        }
        if (nextMode !== 'register' && els.authConfirm) {
          els.authConfirm.value = '';
        }
        showAuthAlert('');
      };

      setGameVisibility(false);
      setAuthMode(state.authMode);
      const handleAuthEnter = (event) => {
        if (event.key === 'Enter' && !state.busy) {
          event.preventDefault();
          if (document.activeElement === els.authEmail || document.activeElement === els.authPassword || document.activeElement === els.authConfirm) {
            loginOrRegister();
          }
        }
      };

      [els.authEmail, els.authPassword, els.authConfirm].forEach(input => {
        if (input) input.addEventListener('keydown', handleAuthEnter);
      });


      const updateHud = () => {
        if (els.hudBalance) els.hudBalance.textContent = currency.format(state.balance || 0);
        if (els.hudBet) els.hudBet.textContent = currency.format(state.bet || 0);
      };

      const setBetValue = (value) => {
        const safe = clamp(value || 1, 1, state.maxBet || DEFAULT_MAX_BET);
        debug('bet:update', { requested: value, applied: safe, max: state.maxBet });
        state.bet = safe;
        if (els.betSlider) {
          els.betSlider.max = state.maxBet || DEFAULT_MAX_BET;
          els.betSlider.value = safe;
        }
        updateHud();
      };
      setBetValue(state.bet);

      const storeGuestPlayer = (value) => {
        if (value) {
          localStorage.setItem(storageKeys.player, value);
        }
      };
      const resetStoredPlayer = () => localStorage.removeItem(storageKeys.player);

      const updateAuthUI = () => {
        debug('auth:updateUI', { loggedIn: Boolean(state.auth.token) });
        const loggedIn = Boolean(state.auth.token);
        if (els.authOverlay) {
          els.authOverlay.dataset.hidden = loggedIn ? 'true' : 'false';
          els.authOverlay.setAttribute('aria-hidden', loggedIn ? 'true' : 'false');
        }
        if (els.accountPanel) {
          els.accountPanel.hidden = !loggedIn;
        }
        if (loggedIn && els.accountUser) {
          els.accountUser.textContent = state.auth.username || 'Account';
        }
        if (els.deleteBtn) {
          els.deleteBtn.disabled = !loggedIn;
        }
        if (!loggedIn && els.authPassword) {
          els.authPassword.value = '';
          if (els.authConfirm) els.authConfirm.value = '';
        }
        if (!loggedIn) {
          if (els.machineOutcome) els.machineOutcome.textContent = 'Sign in to start spinning.';
          if (els.hudWin) els.hudWin.textContent = currency.format(0);
          updateHud();
        }
      };

      const setAuthState = ({ token, username } = {}) => {
        debug('auth:setState', { tokenPresent: Boolean(token), username });
        state.auth.token = token || null;
        state.auth.username = token ? (username || state.auth.username || null) : null;
        if (!state.auth.token) {
          state.playerId = null;
        }
        if (state.auth.token) {
          localStorage.setItem(storageKeys.token, state.auth.token);
          localStorage.setItem(storageKeys.user, state.auth.username || '');
          resetStoredPlayer();
        } else {
          localStorage.removeItem(storageKeys.token);
          localStorage.removeItem(storageKeys.user);
        }
        updateAuthUI();
      };

      const clearAuth = (message) => {
        debug('auth:clear', { message });
        if (!state.auth.token) return;
        setAuthState({});
        setGameVisibility(false);
        setStatus('Sign in to start', 'error');
        if (message) {
          showAuthAlert(message);
          log('Auth', message);
        }
      };

      const syncAuthFromPayload = (payload = {}) => {
        debug('auth:syncFromPayload', payload);
        if (payload.token && payload.username) {
          setAuthState({ token: payload.token, username: payload.username });
          showAuthAlert('');
        }
      };

      const withAuth = (payload = {}) => {
        if (state.auth.token) {
          return { ...payload, token: state.auth.token };
        }
        return payload;
      };

      const request = async (path, payload = {}, options = {}) => {
        const finalPayload = options.skipAuth ? payload : withAuth(payload);
        debug('request:start', { path, payload: finalPayload, options });
        const res = await fetch(`${API_BASE}${path}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(finalPayload)
        });
        let data = {};
        try {
          data = await res.json();
        } catch {
          data = {};
        }
        debug('request:response', { path, status: res.status, ok: res.ok, body: data });
        if (!res.ok) {
          if (res.status === 401 && !options.skipAuth) {
            clearAuth('Session expired. Please sign in again.');
          }
          const err = new Error(data.error || data.message || 'Request failed');
          err.payload = data;
          err.status = res.status;
           debugError('request:error', err, { path, payload: finalPayload });
          throw err;
        }
        return data;
      };

      const updateStats = (payload = {}) => {
        debug('updateStats', payload);
        if (payload.playerId) {
          state.playerId = payload.playerId;
          els.playerId.textContent = payload.playerId;
          if (state.auth.token) {
            resetStoredPlayer();
          } else {
            storeGuestPlayer(payload.playerId);
          }
        }
        if (typeof payload.balance === 'number') {
          state.balance = payload.balance;
          els.balance.textContent = currency.format(payload.balance);
        }
        if (typeof payload.spins === 'number') {
          els.spinCount.textContent = payload.spins;
        }
        if (payload.machine) {
          syncMachineDefinition(payload.machine);
        }

        state.maxBet = resolveMaxBet(payload.maxBet);
        els.maxBet.textContent = state.maxBet;
        if (payload.upgrades) {
          applyUpgradeState(payload.upgrades);
        } else {
          applyUpgradeState(state.upgrades);
        }
        const incomingBet = Number(payload.bet);
        const fallbackBet = Number.isFinite(state.bet)
          ? state.bet
          : Number(els.betSlider?.value);
        const desiredBet = Number.isFinite(incomingBet)
          ? incomingBet
          : (Number.isFinite(fallbackBet) ? fallbackBet : 1);
        setBetValue(desiredBet || 1);
        updateHud();
      };

      const formatWinSummary = (groups = []) => {
        if (!groups?.length) return '';
        return groups
          .slice()
          .sort((a, b) => (b.payout || 0) - (a.payout || 0))
          .map(group => {
            const info = getSymbolInfo(group.symbol);
            return `${info.label || info.key} √ó${group.count}`;
          })
          .join(', ');
      };

      const updateLastSpin = (lastSpin) => {
        debug('updateLastSpin', lastSpin);
        if (!lastSpin) {
          if (els.lastOutcome) els.lastOutcome.textContent = '‚Äî';
          if (els.lastWin) els.lastWin.textContent = '‚Äî';
          if (els.lastMult) els.lastMult.textContent = '‚Äî';
          if (els.lastTime) els.lastTime.textContent = '‚Äî';
          if (els.machineOutcome) els.machineOutcome.textContent = 'Awaiting spin‚Ä¶';
          if (els.hudWin) els.hudWin.textContent = currency.format(0);
          highlightWins([]);
          return;
        }
        const summary = formatWinSummary(lastSpin.winGroups) || lastSpin.outcome || '‚Äî';
        if (els.lastOutcome) els.lastOutcome.textContent = summary;
        if (els.lastWin) els.lastWin.textContent = currency.format(lastSpin.winAmount || 0);
        if (els.lastMult) {
          const lines = Array.isArray(lastSpin.winGroups) ? lastSpin.winGroups.length : 0;
          els.lastMult.textContent = lines ? `${lines} line${lines === 1 ? '' : 's'}` : '‚Äî';
        }
        if (els.lastTime) els.lastTime.textContent = new Date(lastSpin.timestamp).toLocaleString();
        if (els.machineOutcome) els.machineOutcome.textContent = lastSpin.outcome || summary;
        if (els.hudWin) els.hudWin.textContent = currency.format(lastSpin.winAmount || 0);
        if (Array.isArray(lastSpin.grid)) {
          updateGridSymbols(lastSpin.grid);
        }
        highlightWins(lastSpin.winGroups || []);
      };

      const hydrateSession = (session, logMessage) => {
        debug('hydrateSession', session);
        syncAuthFromPayload(session);
        if (session.machine) {
          syncMachineDefinition(session.machine);
        }
        if (session.upgrades) {
          applyUpgradeState(session.upgrades);
        }
        updateStats(session);
        updateLastSpin(session.lastSpin);
        setGameVisibility(true);
        setStatus('Connected to AWS Lambda', 'ok');
        if (logMessage) {
          log(logMessage, `${session.username || 'User'} ‚Ä¢ balance ${currency.format(session.balance)}`);
        }
      };

      const bootstrap = async () => {
        debug('bootstrap:start');
        if (!state.auth.token) {
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          debug('bootstrap:skipped', 'missing auth token');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const session = await request('/session');
          hydrateSession(session, 'Session synced');
        } catch (error) {
          console.error(error);
          setGameVisibility(false);
          setStatus('Offline ‚Äî check CloudWatch logs', 'error');
          showAlert(error.message || 'Unable to reach AWS.');
          log('Connection failed', error.message);
          debugError('bootstrap', error);
        } finally {
          debug('bootstrap:end');
          setBusy(false);
        }
      };

      const spin = async () => {
        debug('spin:click', { busy: state.busy, authed: !!state.auth.token });
        if (state.busy) return;
        if (!state.auth.token) {
          showAuthAlert('Sign in to spin the slot machine.');
          return;
        }
        const bet = clamp(state.bet || 1, 1, state.maxBet || DEFAULT_MAX_BET);
        setBetValue(bet);
        setBusy(true);
        showAlert('');
        if (els.error) els.error.textContent = '';
        startGridSpin();
        let spinData = null;
        try {
          const result = await request('/spin', { bet });
          spinData = result.lastSpin || null;
          updateStats(result);
          updateLastSpin(spinData);
          const outcomeText = spinData?.outcome || result.outcome || 'Result processed';
          log('Spin processed by Lambda', `${outcomeText} (balance ${currency.format(result.balance)})`);
          debug('spin:success', { bet, outcome: outcomeText, balance: result.balance });
        } catch (error) {
          const payload = error.payload || {};
          const msg = payload.message || error.message;
          if (els.error) els.error.textContent = msg;
          if (payload.balance !== undefined || payload.maxBet !== undefined) {
            updateStats({ balance: payload.balance, maxBet: payload.maxBet });
          }
          if (payload.errorCode === 'INSUFFICIENT_CREDITS') {
            log('Spin blocked', 'Insufficient credits');
          } else {
            log('Spin failed', msg);
          }
          debugError('spin', error, { payload });
        } finally {
          stopGridSpin(spinData?.grid);
          setBusy(false);
        }
      };

      const loginOrRegister = async () => {
        const email = (els.authEmail?.value || '').trim().toLowerCase();
        const password = els.authPassword?.value || '';
        debug('auth:submit', { mode: state.authMode, email, hasPassword: Boolean(password) });
        if (!email || !password) {
          showAuthAlert('Enter your email and password.');
          return;
        }
        if (state.authMode === 'register') {
          const confirm = (els.authConfirm?.value || '').trim();
          if (!confirm) {
            showAuthAlert('Please confirm your password.');
            return;
          }
          if (confirm !== password) {
            showAuthAlert('Passwords do not match.');
            return;
          }
        }
        showAuthAlert('');
        toggleAuthInputs(true);
        try {
          const endpoint = state.authMode === 'register' ? '/auth/register' : '/auth/login';
          const result = await request(endpoint, { username: email, password }, { skipAuth: true });
          hydrateSession(result, state.authMode === 'register' ? 'Account created' : 'Signed in');
          showAuthAlert(state.authMode === 'register' ? 'Account created! Credits synced.' : 'Signed in successfully.');
          debug('auth:success', { endpoint });
        } catch (error) {
          showAuthAlert(error.message || 'Unable to process request.');
          log('Auth failed', error.message);
          debugError('auth', error);
        } finally {
          toggleAuthInputs(false);
        }
      };

      const logout = async () => {
        debug('auth:logout-click', { authed: !!state.auth.token });
        if (!state.auth.token) return;
        showAuthAlert('');
        if (els.logoutBtn) els.logoutBtn.disabled = true;
        try {
          await request('/auth/logout', {});
        } catch (error) {
          console.error(error);
          debugError('logout', error);
        } finally {
          if (els.logoutBtn) els.logoutBtn.disabled = false;
          setAuthState({});
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          log('Signed out', '');
          showAuthAlert('Signed out.');
        }
      };

      const deleteAccount = async () => {
        if (!state.auth.token) return;
        const confirmed = window.confirm('Delete your account and all slot progress? This cannot be undone.');
        debug('account:delete-click', { confirmed });
        if (!confirmed) return;
        showAuthAlert('');
        if (els.deleteBtn) els.deleteBtn.disabled = true;
        try {
          await request('/auth/delete', {});
          log('Account deleted', '');
          setAuthState({});
          setGameVisibility(false);
          setStatus('Account deleted', 'error');
          showAuthAlert('Account deleted. You can register again anytime.');
        } catch (error) {
          showAuthAlert(error.message || 'Unable to delete account right now.');
          log('Delete failed', error.message);
          debugError('delete-account', error);
        } finally {
          if (els.deleteBtn) els.deleteBtn.disabled = false;
        }
      };

      updateAuthUI();
      ensureGrid(state.machine.rows, state.machine.reels);
      updateMachineMeta();
      renderPaytable();
      loadMachineConfig();
      window.addEventListener('resize', applyMachineTheme);

      if (els.betSlider) {
        els.betSlider.addEventListener('input', (event) => {
          setBetValue(Number(event.target.value));
        });
      }

      const handleChipAction = (action) => {
        debug('chip:action', { action, busy: state.busy, ready: state.gameReady });
        if (state.busy || !state.gameReady) return;
        if (action === 'increase') {
          setBetValue(state.bet + 5);
          return;
        }
        if (action === 'decrease') {
          setBetValue(state.bet - 5);
          return;
        }
        if (action === 'max') {
          setBetValue(state.maxBet || DEFAULT_MAX_BET);
        }
      };

      els.chipButtons.forEach(btn => {
        btn.addEventListener('click', () => handleChipAction(btn.dataset.chip));
      });

      els.upgradeGrid?.addEventListener('click', (event) => {
        const button = event.target.closest('[data-upgrade]');
        if (!button || button.dataset.disabled === 'true') return;
        if (state.busy) return;
        purchaseUpgrade(button.dataset.upgrade);
      });

      els.spinBtn.addEventListener('click', spin);

      els.resetBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) {
          showAuthAlert('Sign in to use the slot machine.');
          return;
        }
        bootstrap();
      });

      els.syncBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) return;
        bootstrap();
      });

      const purchaseUpgrade = async (type) => {
        if (!state.auth.token) {
          showAuthAlert('Sign in to upgrade your machine.');
          return;
        }
        debug('upgrade:request', { type });
        setBusy(true);
        showAlert('');
        try {
          const result = await request('/upgrade', { type });
          updateStats(result);
          log('Upgrade purchased', `Unlocked ${type}.`);
        } catch (error) {
          const msg = error.payload?.message || error.message || 'Upgrade failed.';
          showAlert(msg);
          debugError('upgrade', error);
        } finally {
          setBusy(false);
        }
      };

      if (els.authSubmit) {
        els.authSubmit.addEventListener('click', loginOrRegister);
      }
      (els.authTabs || []).forEach(btn => {
        btn.addEventListener('click', () => setAuthMode(btn.dataset.mode));
      });
      if (els.authInfo) {
        els.authInfo.addEventListener('click', () => {
          setAuthMode('register');
          els.authEmail?.focus();
        });
      }
      els.logoutBtn.addEventListener('click', logout);
      els.deleteBtn?.addEventListener('click', deleteAccount);

      if (state.auth.token) {
        bootstrap();
      } else {
        setStatus('Sign in to start', 'error');
      }
    })();
  </script>
</body>
</html>
