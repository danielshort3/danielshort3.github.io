<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <base href="/">
  <title>Server-Backed Slot Machine Demo</title>
  <meta name="theme-color" content="#0d1117" />
  <link rel="stylesheet" href="dist/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500&display=swap" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #020617;
      --panel: color-mix(in srgb, var(--surface, #0f172a) 90%, black 10%);
      --panel-border: color-mix(in srgb, var(--surface-accent, #1e293b) 70%, transparent);
      --text: var(--text-light, #e2e8f0);
      --muted: color-mix(in srgb, var(--text) 65%, transparent);
      --accent: #facc15;
      --accent-2: #6366f1;
      --danger: #f87171;
      --radius: 16px;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(900px 600px at 50% -10%, rgba(99, 102, 241, .25), transparent 70%) var(--bg);
      color: var(--text);
      padding: clamp(16px, 3vw, 32px);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    html[data-embedded="true"] body {
      display: block;
    }
    main {
      width: min(960px, 100%);
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius);
      box-shadow: 0 20px 80px rgba(2, 6, 23, .6);
      padding: clamp(20px, 3vw, 32px);
      display: grid;
      gap: 24px;
    }
    header h1 {
      font-family: "Space Grotesk", Inter, sans-serif;
      font-size: clamp(1.75rem, 3vw, 2.5rem);
      margin: 0 0 8px;
    }
    header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: .9rem;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 60%, transparent);
      background: rgba(99, 102, 241, .12);
    }
    .status-pill.ghost {
      background: rgba(255,255,255,.12);
      border-color: rgba(255,255,255,.2);
      color: rgba(255,255,255,.85);
    }
    .status-pill[data-state="error"] {
      color: var(--danger);
      background: rgba(244, 114, 182, .1);
    }
    .grid {
      display: grid;
      gap: 16px;
    }
    .grid-two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .panel {
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 40%, transparent);
      padding: 16px;
      background: rgba(15, 23, 42, .6);
    }
    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.05rem;
      font-weight: 600;
    }
    dl {
      margin: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 16px;
      font-size: .95rem;
    }
    dt {
      color: var(--muted);
      font-weight: 500;
    }
    dd {
      margin: 0;
      font-weight: 600;
    }
    .reels {
      display: grid;
      grid-template-columns: repeat(3, minmax(80px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .slot-cell {
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, white 12%, transparent);
      display: grid;
      place-items: center;
      font-size: 2.75rem;
      background: rgba(15, 23, 42, .8);
      box-shadow: inset 0 0 30px rgba(0,0,0,.3);
      transition: transform .45s cubic-bezier(.34, 1.56, .64, 1);
    }
    .slot-cell.spin {
      transform: scale(1.08) rotateX(360deg);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .controls label {
      font-size: .9rem;
      color: var(--muted);
    }
    .controls input[type="number"] {
      width: 120px;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(15, 23, 42, .8);
      color: inherit;
      font-size: 1rem;
    }
    .controls button {
      border: none;
      border-radius: 999px;
      padding: 12px 28px;
      font-size: .95rem;
      font-weight: 600;
      cursor: pointer;
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      box-shadow: 0 10px 30px rgba(250, 204, 21, .35);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .controls button[disabled] {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .controls button:not([disabled]):active {
      transform: translateY(1px);
    }
    .alert {
      padding: 12px 14px;
      border-radius: 10px;
      font-size: .95rem;
      background: rgba(248, 113, 113, .1);
      border: 1px solid rgba(248, 113, 113, .4);
      color: var(--danger);
    }
    .log {
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
      max-height: 160px;
      overflow-y: auto;
    }
    .log-entry + .log-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .ghost-btn {
      border: 1px solid rgba(255,255,255,.25);
      color: var(--muted);
      background: transparent;
      border-radius: 10px;
      padding: 8px 14px;
      font-size: .85rem;
      cursor: pointer;
    }
    .ghost-btn:disabled {
      opacity: .5;
      cursor: default;
    }
    .ghost-btn.primary {
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      border-color: transparent;
      font-weight: 600;
      box-shadow: 0 15px 35px rgba(250, 204, 21, .35);
    }
    .ghost-btn.secondary {
      color: var(--text);
      border-color: rgba(255,255,255,.25);
    }
    .ghost-btn.tertiary {
      color: var(--muted);
      border-color: transparent;
      background: rgba(255,255,255,.08);
    }
    .auth-overlay {
      position: fixed;
      inset: 0;
      z-index: 40;
      background: radial-gradient(circle at top, rgba(15,23,42,.9), rgba(2,6,23,.98));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(16px, 4vw, 48px);
      transition: opacity .35s ease, visibility .35s ease;
    }
    .auth-overlay[data-hidden="true"] {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .auth-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(20px, 5vw, 36px);
      width: min(960px, 100%);
      border-radius: 26px;
      border: 1px solid rgba(99,102,241,.35);
      background: linear-gradient(135deg, rgba(15,23,42,.95), rgba(30,64,175,.9));
      padding: clamp(24px, 5vw, 48px);
      box-shadow: 0 40px 150px rgba(2, 6, 23, .9);
      position: relative;
      overflow: hidden;
    }
    .auth-card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at top right, rgba(99,102,241,.4), transparent 45%);
      pointer-events: none;
    }
    .auth-copy {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 12px;
    }
    .auth-copy h2 {
      margin: 0;
      font-size: clamp(1.6rem, 3vw, 2.4rem);
      font-weight: 600;
      color: #fff;
    }
    .auth-copy p {
      margin: 0;
      color: color-mix(in srgb, #fff 85%, rgba(255,255,255,.4));
      line-height: 1.6;
    }
    .auth-body {
      position: relative;
      z-index: 1;
      background: rgba(2, 6, 23, .7);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.08);
      padding: clamp(18px, 4vw, 28px);
      display: grid;
      gap: 18px;
    }
    .auth-tabs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      padding: 5px;
    }
    .auth-tab {
      border: none;
      background: transparent;
      color: rgba(255,255,255,.7);
      font-weight: 600;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: background .2s ease, color .2s ease;
    }
    .auth-tab.active {
      background: rgba(255,255,255,.14);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .auth-forms {
      display: grid;
      gap: 15px;
    }
    .auth-forms label {
      display: grid;
      gap: 6px;
      font-size: .9rem;
      color: rgba(255,255,255,.7);
    }
    .auth-forms input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(15, 23, 42, .85);
      color: inherit;
      font-size: 1rem;
      transition: border .2s ease, box-shadow .2s ease;
    }
    .auth-forms input:focus-visible {
      outline: none;
      border-color: rgba(250,204,21,.65);
      box-shadow: 0 0 0 2px rgba(250,204,21,.2);
    }
    .auth-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .muted-text {
      color: rgba(255,255,255,.65);
      margin: 0;
      font-size: .9rem;
    }
    .muted-text.small {
      font-size: .8rem;
    }
    .alert {
      margin-top: 4px;
    }
    .auth-body[data-mode="login"] #auth-confirm-group {
      display: none;
    }
    .auth-body[data-mode="register"] #auth-info {
      display: none;
    }
    .account-panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      background: rgba(15,23,42,.75);
      border: 1px solid rgba(255,255,255,.06);
    }
    .slot-machine {
      background: linear-gradient(160deg, rgba(15,23,42,.92), rgba(30,41,59,.9));
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 24px;
      box-shadow: 0 25px 100px rgba(2,6,23,.6);
    }
    .slot-machine__header {
      display: flex;
      justify-content: space-between;
      gap: 24px;
      align-items: center;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(148,163,184,.2);
    }
    .slot-machine__header h2 {
      margin: 4px 0;
      font-size: clamp(1.4rem, 3vw, 2rem);
    }
    .jackpot {
      border-radius: 18px;
      padding: 14px 20px;
      background: linear-gradient(120deg, #e11d48, #f97316);
      color: #fff;
      text-align: center;
      min-width: 160px;
      box-shadow: 0 18px 45px rgba(241,135,0,.4);
    }
    .jackpot span {
      font-size: .8rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      opacity: .8;
    }
    .jackpot strong {
      display: block;
      font-size: 1.5rem;
      letter-spacing: .06em;
    }
    .slot-machine__body {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: clamp(16px, 4vw, 32px);
      padding-top: 20px;
    }
    .machine-frame {
      position: relative;
      border-radius: 26px;
      border: 1px solid rgba(148,163,184,.15);
      padding: clamp(16px, 3vw, 28px);
      background: radial-gradient(circle at top, rgba(14,165,233,.15), rgba(15,23,42,.95));
      overflow: hidden;
    }
    .machine-frame__glow {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 50% 20%, rgba(59,130,246,.4), transparent 45%);
      opacity: .8;
      pointer-events: none;
    }
    .machine-frame__reels {
      position: relative;
      display: grid;
      grid-template-columns: repeat(3, minmax(90px, 1fr));
      gap: clamp(12px, 2vw, 20px);
      background: rgba(2,6,23,.6);
      padding: clamp(18px, 3vw, 28px);
      border-radius: 20px;
      box-shadow: inset 0 0 20px rgba(0,0,0,.45);
    }
    .reel {
      height: clamp(150px, 24vw, 220px);
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.2);
      background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(30,41,59,.95));
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
    }
    .reel::before,
    .reel::after {
      content: "";
      position: absolute;
      left: 8px;
      right: 8px;
      height: 18px;
      border-radius: 999px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
      pointer-events: none;
    }
    .reel::before {
      top: 10px;
    }
    .reel::after {
      bottom: 10px;
    }
    .reel .symbol {
      font-size: clamp(2.8rem, 6vw, 3.6rem);
      transition: transform .45s cubic-bezier(.34, 1.56, .64, 1), filter .3s ease;
    }
    .reel[data-spinning="true"] .symbol {
      animation: reelBlur .35s linear infinite;
      filter: blur(1px);
    }
    @keyframes reelBlur {
      0% { transform: translateY(-6px); }
      50% { transform: translateY(6px); }
      100% { transform: translateY(-6px); }
    }
    .machine-display {
      margin-top: 18px;
      border-radius: 16px;
      background: rgba(15,23,42,.8);
      border: 1px solid rgba(148,163,184,.2);
      padding: 14px 18px;
    }
    .machine-display__label {
      margin: 0;
      text-transform: uppercase;
      font-size: .8rem;
      letter-spacing: .08em;
      color: rgba(148,163,184,.8);
    }
    .machine-display__value {
      margin: 4px 0 0;
      font-size: 1.1rem;
      font-weight: 600;
    }
    .control-deck {
      display: grid;
      gap: 18px;
      background: rgba(2,6,23,.65);
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.18);
      padding: clamp(18px, 4vw, 28px);
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
    }
    .hud-card {
      border-radius: 14px;
      padding: 12px 14px;
      background: rgba(15,23,42,.9);
      border: 1px solid rgba(148,163,184,.2);
    }
    .hud-label {
      margin: 0;
      font-size: .8rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: rgba(148,163,184,.8);
    }
    .hud-value {
      font-size: 1.3rem;
      margin-top: 6px;
      display: block;
    }
    .bet-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .bet-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent, #facc15);
      height: 4px;
    }
    .chip {
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.9);
      color: #facc15;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: .95rem;
      cursor: pointer;
    }
    .chip:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .machine-messages {
      min-height: 32px;
    }
    .machine-error {
      margin: 0;
      color: #f97316;
      font-size: .9rem;
    }
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      align-items: center;
    }
    .spin-btn {
      border: none;
      border-radius: 99px;
      padding: 16px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      color: #020617;
      background: radial-gradient(circle at top, #bef264, #facc15);
      box-shadow: 0 18px 35px rgba(250,204,21,.45);
      cursor: pointer;
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .spin-btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .spin-btn:not(:disabled):active {
      transform: translateY(1px);
      box-shadow: 0 10px 25px rgba(250,204,21,.35);
    }
    .paytable-panel {
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.18);
      background: rgba(2,6,23,.7);
    }
    .paytable {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 12px;
    }
    .paytable li {
      display: flex;
      justify-content: space-between;
      background: rgba(15,23,42,.85);
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 14px;
      padding: 12px 16px;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .paytable-symbol {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }
    .paytable-symbol span {
      font-size: 1.8rem;
    }
    .paytable-meta {
      font-size: .9rem;
      color: rgba(148,163,184,.85);
    }
    @media (max-width: 640px) {
      .slot-machine__body {
        grid-template-columns: 1fr;
      }
      .machine-frame__reels {
        grid-template-columns: repeat(3, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="auth-overlay" id="auth-overlay" aria-hidden="false" data-hidden="false">
    <div class="auth-card">
      <div class="auth-copy">
        <p class="status-pill ghost">üé∞ Demo Slot Machine</p>
        <h2>Log in to save your credits and keep the reels rolling.</h2>
        <p>This is a fun, server-backed slot machine demo‚Äîno real money is involved. Every spin is validated in AWS so balances carry across devices.</p>
        <p class="muted-text small">Passwords are hashed before storing and sessions auto-expire. Have fun exploring the animations and payouts.</p>
      </div>
      <div class="auth-body" id="auth-body" data-mode="login">
        <div class="auth-tabs" role="tablist">
          <button type="button" class="auth-tab active" data-mode="login">Sign In</button>
          <button type="button" class="auth-tab" data-mode="register">Create Account</button>
        </div>
        <div class="auth-forms">
          <label>
            Email
            <input type="email" id="auth-email" autocomplete="email" placeholder="you@example.com" required />
          </label>
          <label>
            Password
            <input type="password" id="auth-password" autocomplete="current-password" placeholder="At least 8 characters" required />
          </label>
          <label id="auth-confirm-group" hidden>
            Confirm password
            <input type="password" id="auth-confirm" autocomplete="new-password" placeholder="Repeat password" />
          </label>
          <div class="auth-actions">
            <button type="button" class="ghost-btn primary" id="auth-submit">Sign In</button>
            <button type="button" class="ghost-btn tertiary" id="auth-info">Need access? Register in seconds.</button>
          </div>
          <p class="muted-text small" id="auth-note">Passwords never leave AWS without hashing. Sessions expire automatically to keep balances safe.</p>
          <div class="alert" id="auth-alert" hidden></div>
        </div>
      </div>
    </div>
  </div>
  <a class="skip-link" href="#main">Skip to content</a>
  <main id="main" data-api-base="https://4kvebym8b3.execute-api.us-east-2.amazonaws.com/prod" data-max-bet="100">
    <header class="grid">
      <div>
        <p class="status-pill" id="connection-pill" data-state="loading">
          <span aria-hidden="true">üõ∞Ô∏è</span>
          <span id="connection-text">Connecting to AWS‚Ä¶</span>
        </p>
        <h1>Server-Backed Slot Machine</h1>
        <p>This demo uses an AWS Lambda function, API Gateway, and DynamoDB table so every spin is validated on the server. The browser can render the reels, but it cannot change your credit balance or payout.</p>
      </div>
    </header>

    <section class="panel account-panel" id="account-panel" data-requires-auth hidden>
      <div>
        <p class="muted-text">Signed in as</p>
        <strong id="account-user"></strong>
      </div>
      <div class="actions">
        <button type="button" class="ghost-btn secondary" id="logout-btn">Sign out</button>
      </div>
    </section>

    <section class="panel slot-machine" data-requires-auth hidden>
      <div class="slot-machine__header">
        <div>
          <p class="muted-text small">Lucky Lambda Slots</p>
          <h2>Server-validated spins with cinematic reels.</h2>
          <p class="muted-text">Every result routes through AWS Lambda + DynamoDB, so payouts are locked before they reach your browser.</p>
        </div>
        <div class="jackpot">
          <span>Progressive Demo</span>
          <strong>$1,000,000</strong>
        </div>
      </div>
      <div class="slot-machine__body">
        <div class="machine-frame">
          <div class="machine-frame__glow"></div>
          <div class="machine-frame__reels" id="reel-stage">
            <div class="reel" data-reel="0"><span class="symbol">üçí</span></div>
            <div class="reel" data-reel="1"><span class="symbol">üçã</span></div>
            <div class="reel" data-reel="2"><span class="symbol">üçá</span></div>
          </div>
          <div class="machine-display">
            <p class="machine-display__label">Last outcome</p>
            <p class="machine-display__value" id="machine-outcome">Sign in to start spinning.</p>
          </div>
        </div>
        <div class="control-deck">
          <div class="hud">
            <div class="hud-card">
              <p class="hud-label">Credits</p>
              <strong class="hud-value" id="hud-balance">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Bet</p>
              <strong class="hud-value" id="hud-bet">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Last win</p>
              <strong class="hud-value" id="hud-win">$0</strong>
            </div>
          </div>
          <div class="bet-controls">
            <button type="button" class="chip" data-chip="decrease" aria-label="Decrease bet">-</button>
            <input type="range" id="bet-range" min="1" max="100" value="25" aria-label="Bet amount" />
            <button type="button" class="chip" data-chip="increase" aria-label="Increase bet">+</button>
            <button type="button" class="chip" data-chip="max" aria-label="Max bet">Max</button>
          </div>
          <div class="machine-messages">
            <p class="machine-error" id="error" role="status" aria-live="polite"></p>
            <div class="alert" id="alert" hidden></div>
          </div>
          <div class="action-buttons">
            <button type="button" class="ghost-btn secondary" id="sync-btn">Sync balance</button>
            <button type="button" class="ghost-btn tertiary" id="reset-btn">Reset session</button>
            <button type="button" class="spin-btn" id="spin-btn" disabled>Spin</button>
          </div>
        </div>
      </div>
    </section>

    <section class="grid grid-two" data-requires-auth hidden>
      <div class="panel">
        <h2>Session</h2>
        <dl id="session-stats">
          <dt>Player ID</dt><dd id="player-id">‚Äî</dd>
          <dt>Balance</dt><dd id="balance">‚Äî</dd>
          <dt>Max Bet</dt><dd id="max-bet">‚Äî</dd>
          <dt>Total Spins</dt><dd id="spin-count">‚Äî</dd>
        </dl>
      </div>
      <div class="panel">
        <h2>Last Result</h2>
        <dl>
          <dt>Outcome</dt><dd id="last-outcome">‚Äî</dd>
          <dt>Winnings</dt><dd id="last-win">‚Äî</dd>
          <dt>Multiplier</dt><dd id="last-multiplier">‚Äî</dd>
          <dt>Timestamp</dt><dd id="last-time">‚Äî</dd>
        </dl>
      </div>
    </section>

    <section class="panel paytable-panel" data-requires-auth hidden>
      <h2>Paytable</h2>
      <ul class="paytable" id="paytable"></ul>
      <p class="muted-text small">Multipliers apply to your active bet. Triple matches and pairs are calculated server-side.</p>
    </section>

    <section class="panel" data-requires-auth hidden>
      <h2>Server Event Log</h2>
      <div class="log" id="log" aria-live="polite"></div>
    </section>
  </main>

  <script>
    (() => {
      const root = document.getElementById('main');
      if (!root) return;
      const API_BASE = root.dataset.apiBase;
      const DEFAULT_MAX_BET = Number(root.dataset.maxBet) || 100;
      const storageKeys = {
        player: 'slotMachineDemoPlayerId',
        token: 'slotMachineAuthToken',
        user: 'slotMachineAuthUser'
      };
      const AUTH_MODE_KEY = 'slotMachineAuthMode';
      const getStored = (key) => {
        const value = localStorage.getItem(key);
        return value && value !== 'null' ? value : null;
      };
      const state = {
        playerId: null,
        balance: 0,
        maxBet: DEFAULT_MAX_BET,
        bet: 25,
        busy: false,
        gameReady: false,
        auth: {
          token: getStored(storageKeys.token),
          username: getStored(storageKeys.user)
        },
        authMode: localStorage.getItem(AUTH_MODE_KEY) || 'login'
      };

      const currency = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const resolveMaxBet = (incoming) => {
        const numeric = Number(incoming);
        if (Number.isFinite(numeric) && numeric > 0) return numeric;
        if (Number.isFinite(state.maxBet) && state.maxBet > 0) return state.maxBet;
        return DEFAULT_MAX_BET;
      };

      const CLIENT_SYMBOLS = [
        { key: 'cherry', icon: 'üçí', label: 'Cherry', pairMultiplier: 2, tripleMultiplier: 8 },
        { key: 'lemon', icon: 'üçã', label: 'Lemon', pairMultiplier: 3, tripleMultiplier: 12 },
        { key: 'grape', icon: 'üçá', label: 'Grapes', pairMultiplier: 5, tripleMultiplier: 18 },
        { key: 'star', icon: '‚≠ê', label: 'Star', pairMultiplier: 8, tripleMultiplier: 28 },
        { key: 'diamond', icon: 'üíé', label: 'Diamond', pairMultiplier: 15, tripleMultiplier: 50 }
      ];
      const reelTimers = new Map();

      const els = {
        connectionPill: document.getElementById('connection-pill'),
        connectionText: document.getElementById('connection-text'),
        reels: Array.from(document.querySelectorAll('.reel')),
        spinBtn: document.getElementById('spin-btn'),
        resetBtn: document.getElementById('reset-btn'),
        syncBtn: document.getElementById('sync-btn'),
        alert: document.getElementById('alert'),
        error: document.getElementById('error'),
        machineOutcome: document.getElementById('machine-outcome'),
        reelStage: document.getElementById('reel-stage'),
        betSlider: document.getElementById('bet-range'),
        chipButtons: Array.from(document.querySelectorAll('[data-chip]')),
        hudBalance: document.getElementById('hud-balance'),
        hudBet: document.getElementById('hud-bet'),
        hudWin: document.getElementById('hud-win'),
        balance: document.getElementById('balance'),
        playerId: document.getElementById('player-id'),
        maxBet: document.getElementById('max-bet'),
        spinCount: document.getElementById('spin-count'),
        lastOutcome: document.getElementById('last-outcome'),
        lastWin: document.getElementById('last-win'),
        lastMult: document.getElementById('last-multiplier'),
        lastTime: document.getElementById('last-time'),
        log: document.getElementById('log'),
        paytable: document.getElementById('paytable'),
        authOverlay: document.getElementById('auth-overlay'),
        authBody: document.getElementById('auth-body'),
        authAlert: document.getElementById('auth-alert'),
        authEmail: document.getElementById('auth-email'),
        authPassword: document.getElementById('auth-password'),
        authConfirmGroup: document.getElementById('auth-confirm-group'),
        authConfirm: document.getElementById('auth-confirm'),
        authSubmit: document.getElementById('auth-submit'),
        authInfo: document.getElementById('auth-info'),
        authTabs: Array.from(document.querySelectorAll('.auth-tab')),
        authOverlayNote: document.getElementById('auth-note'),
        accountPanel: document.getElementById('account-panel'),
        accountUser: document.getElementById('account-user'),
        logoutBtn: document.getElementById('logout-btn')
      };
      state.playerId = state.auth.token ? null : getStored(storageKeys.player);

      const log = (message, data) => {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<strong>${time}</strong> ‚Äî ${message}${data ? `<br><span>${data}</span>` : ''}`;
        els.log.prepend(entry);
        const entries = els.log.querySelectorAll('.log-entry');
        if (entries.length > 40) {
          entries[entries.length - 1].remove();
        }
      };

      const setStatus = (text, stateAttr = 'ok') => {
        els.connectionText.textContent = text;
        els.connectionPill.dataset.state = stateAttr;
        els.connectionPill.dataset.state === 'ok'
          ? els.connectionPill.setAttribute('data-state', 'ok')
          : els.connectionPill.setAttribute('data-state', stateAttr);
      };

      const showAlert = (text = '') => {
        els.alert.hidden = !text;
        els.alert.textContent = text;
      };

      const showAuthAlert = (text = '') => {
        if (!els.authAlert) return;
        els.authAlert.hidden = !text;
        els.authAlert.textContent = text;
      };

      const gamePanels = Array.from(document.querySelectorAll('[data-requires-auth]'));

      const setGameVisibility = (visible) => {
        state.gameReady = visible;
        gamePanels.forEach(panel => {
          panel.hidden = !visible;
        });
        const disableInputs = !visible || state.busy;
        els.spinBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.resetBtn) els.resetBtn.disabled = disableInputs;
      };

      const setBusy = (flag) => {
        state.busy = flag;
        const disableInputs = flag || !state.gameReady;
        els.spinBtn.disabled = disableInputs;
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
      };

      const toggleAuthInputs = (disabled) => {
        [els.authEmail, els.authPassword, els.authConfirm, els.authSubmit, els.authInfo].forEach(node => {
          if (node) node.disabled = disabled;
        });
        (els.authTabs || []).forEach(btn => {
          btn.disabled = disabled;
        });
      };

      const setAuthMode = (mode = 'login') => {
        const nextMode = mode === 'register' ? 'register' : 'login';
        state.authMode = nextMode;
        localStorage.setItem(AUTH_MODE_KEY, nextMode);
        if (els.authBody) {
          els.authBody.dataset.mode = nextMode;
        }
        (els.authTabs || []).forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === nextMode);
        });
        if (els.authSubmit) {
          els.authSubmit.textContent = nextMode === 'register' ? 'Create Account' : 'Sign In';
        }
        if (els.authConfirmGroup) {
          els.authConfirmGroup.hidden = nextMode !== 'register';
        }
        if (nextMode !== 'register' && els.authConfirm) {
          els.authConfirm.value = '';
        }
        showAuthAlert('');
      };

      setGameVisibility(false);
      setAuthMode(state.authMode);
      const handleAuthEnter = (event) => {
        if (event.key === 'Enter' && !state.busy) {
          event.preventDefault();
          if (document.activeElement === els.authEmail || document.activeElement === els.authPassword || document.activeElement === els.authConfirm) {
            loginOrRegister();
          }
        }
      };

      [els.authEmail, els.authPassword, els.authConfirm].forEach(input => {
        if (input) input.addEventListener('keydown', handleAuthEnter);
      });

      const renderPaytable = () => {
        if (!els.paytable) return;
        els.paytable.innerHTML = CLIENT_SYMBOLS.map(symbol => `
          <li>
            <div class="paytable-symbol"><span>${symbol.icon}</span>${symbol.label}</div>
            <div class="paytable-meta">Triple: ${symbol.tripleMultiplier}√ó ‚Ä¢ Pair: ${symbol.pairMultiplier}√ó</div>
          </li>
        `).join('');
      };
      renderPaytable();

      const randomSymbol = () => CLIENT_SYMBOLS[Math.floor(Math.random() * CLIENT_SYMBOLS.length)];

      const setReelsToSymbols = (symbols = []) => {
        els.reels.forEach((reel, index) => {
          const symbol = symbols[index] || randomSymbol();
          const target = reel.querySelector('.symbol');
          if (target) target.textContent = symbol.icon || symbol;
        });
      };

      const startReelSpinAnimation = () => {
        els.reels.forEach((reel, index) => {
          reel.dataset.spinning = 'true';
          const timer = setInterval(() => {
            const sym = randomSymbol();
            const target = reel.querySelector('.symbol');
            if (target) target.textContent = sym.icon;
          }, 80 + index * 25);
          reelTimers.set(reel, timer);
        });
      };

      const stopReelSpinAnimation = (symbols = []) => {
        els.reels.forEach((reel, index) => {
          const timer = reelTimers.get(reel);
          if (timer) {
            clearInterval(timer);
            reelTimers.delete(reel);
          }
          const targetSymbol = symbols[index] || randomSymbol();
          setTimeout(() => {
            reel.dataset.spinning = 'false';
            const target = reel.querySelector('.symbol');
            if (target) target.textContent = targetSymbol.icon || targetSymbol;
          }, 200 * index);
        });
      };

      const updateHud = () => {
        if (els.hudBalance) els.hudBalance.textContent = currency.format(state.balance || 0);
        if (els.hudBet) els.hudBet.textContent = currency.format(state.bet || 0);
      };

      const setBetValue = (value) => {
        const safe = clamp(value || 1, 1, state.maxBet || DEFAULT_MAX_BET);
        state.bet = safe;
        if (els.betSlider) {
          els.betSlider.max = state.maxBet || DEFAULT_MAX_BET;
          els.betSlider.value = safe;
        }
        updateHud();
      };
      setBetValue(state.bet);

      const storeGuestPlayer = (value) => {
        if (value) {
          localStorage.setItem(storageKeys.player, value);
        }
      };
      const resetStoredPlayer = () => localStorage.removeItem(storageKeys.player);

      const updateAuthUI = () => {
        const loggedIn = Boolean(state.auth.token);
        if (els.authOverlay) {
          els.authOverlay.dataset.hidden = loggedIn ? 'true' : 'false';
          els.authOverlay.setAttribute('aria-hidden', loggedIn ? 'true' : 'false');
        }
        if (els.accountPanel) {
          els.accountPanel.hidden = !loggedIn;
        }
        if (loggedIn && els.accountUser) {
          els.accountUser.textContent = state.auth.username || 'Account';
        }
        if (!loggedIn && els.authPassword) {
          els.authPassword.value = '';
          if (els.authConfirm) els.authConfirm.value = '';
        }
        if (!loggedIn) {
          if (els.machineOutcome) els.machineOutcome.textContent = 'Sign in to start spinning.';
          if (els.hudWin) els.hudWin.textContent = currency.format(0);
          updateHud();
        }
      };

      const setAuthState = ({ token, username } = {}) => {
        state.auth.token = token || null;
        state.auth.username = token ? (username || state.auth.username || null) : null;
        if (!state.auth.token) {
          state.playerId = null;
        }
        if (state.auth.token) {
          localStorage.setItem(storageKeys.token, state.auth.token);
          localStorage.setItem(storageKeys.user, state.auth.username || '');
          resetStoredPlayer();
        } else {
          localStorage.removeItem(storageKeys.token);
          localStorage.removeItem(storageKeys.user);
        }
        updateAuthUI();
      };

      const clearAuth = (message) => {
        if (!state.auth.token) return;
        setAuthState({});
        setGameVisibility(false);
        setStatus('Sign in to start', 'error');
        if (message) {
          showAuthAlert(message);
          log('Auth', message);
        }
      };

      const syncAuthFromPayload = (payload = {}) => {
        if (payload.token && payload.username) {
          setAuthState({ token: payload.token, username: payload.username });
          showAuthAlert('');
        }
      };

      const withAuth = (payload = {}) => {
        if (state.auth.token) {
          return { ...payload, token: state.auth.token };
        }
        return payload;
      };

      const request = async (path, payload = {}, options = {}) => {
        const finalPayload = options.skipAuth ? payload : withAuth(payload);
        const res = await fetch(`${API_BASE}${path}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(finalPayload)
        });
        let data = {};
        try {
          data = await res.json();
        } catch {
          data = {};
        }
        if (!res.ok) {
          if (res.status === 401 && !options.skipAuth) {
            clearAuth('Session expired. Please sign in again.');
          }
          const err = new Error(data.error || data.message || 'Request failed');
          err.payload = data;
          err.status = res.status;
          throw err;
        }
        return data;
      };

      const updateStats = (payload = {}) => {
        if (payload.playerId) {
          state.playerId = payload.playerId;
          els.playerId.textContent = payload.playerId;
          if (state.auth.token) {
            resetStoredPlayer();
          } else {
            storeGuestPlayer(payload.playerId);
          }
        }
        if (typeof payload.balance === 'number') {
          state.balance = payload.balance;
          els.balance.textContent = currency.format(payload.balance);
        }
        if (typeof payload.spins === 'number') {
          els.spinCount.textContent = payload.spins;
        }

        state.maxBet = resolveMaxBet(payload.maxBet);
        els.maxBet.textContent = state.maxBet;
        const incomingBet = Number(payload.bet);
        const fallbackBet = Number.isFinite(state.bet)
          ? state.bet
          : Number(els.betSlider?.value);
        const desiredBet = Number.isFinite(incomingBet)
          ? incomingBet
          : (Number.isFinite(fallbackBet) ? fallbackBet : 1);
        setBetValue(desiredBet || 1);
        updateHud();
      };

      const updateLastSpin = (lastSpin) => {
        if (!lastSpin) {
          els.lastOutcome.textContent = '‚Äî';
          els.lastWin.textContent = '‚Äî';
          els.lastMult.textContent = '‚Äî';
          els.lastTime.textContent = '‚Äî';
          if (els.machineOutcome) els.machineOutcome.textContent = 'Awaiting spin‚Ä¶';
          if (els.hudWin) els.hudWin.textContent = currency.format(0);
          return;
        }
        els.lastOutcome.textContent = lastSpin.outcome;
        els.lastWin.textContent = currency.format(lastSpin.winAmount);
        els.lastMult.textContent = lastSpin.multiplier ? `${lastSpin.multiplier}√ó` : '‚Äî';
        els.lastTime.textContent = new Date(lastSpin.timestamp).toLocaleString();
        if (els.machineOutcome) els.machineOutcome.textContent = lastSpin.outcome;
        if (els.hudWin) els.hudWin.textContent = currency.format(lastSpin.winAmount || 0);
      };

      const animateReels = (reels) => {
        els.reels.forEach((cell, idx) => {
          cell.classList.remove('spin');
          void cell.offsetWidth;
          cell.textContent = reels?.[idx]?.icon || 'üí§';
          setTimeout(() => cell.classList.add('spin'), idx * 80);
          setTimeout(() => cell.classList.remove('spin'), 600);
        });
      };

      const hydrateSession = (session, logMessage) => {
        syncAuthFromPayload(session);
        updateStats(session);
        updateLastSpin(session.lastSpin);
        setReelsToSymbols(session.lastSpin?.reels);
        setGameVisibility(true);
        setStatus('Connected to AWS Lambda', 'ok');
        if (logMessage) {
          log(logMessage, `${session.username || 'User'} ‚Ä¢ balance ${currency.format(session.balance)}`);
        }
      };

      const bootstrap = async () => {
        if (!state.auth.token) {
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const session = await request('/session');
          hydrateSession(session, 'Session synced');
        } catch (error) {
          console.error(error);
          setGameVisibility(false);
          setStatus('Offline ‚Äî check CloudWatch logs', 'error');
          showAlert(error.message || 'Unable to reach AWS.');
          log('Connection failed', error.message);
        } finally {
          setBusy(false);
        }
      };

      const spin = async () => {
        if (state.busy) return;
        if (!state.auth.token) {
          showAuthAlert('Sign in to spin the slot machine.');
          return;
        }
        const bet = clamp(state.bet || 1, 1, state.maxBet || DEFAULT_MAX_BET);
        setBetValue(bet);
        setBusy(true);
        showAlert('');
        if (els.error) els.error.textContent = '';
        startReelSpinAnimation();
        let resultSymbols = null;
        try {
          const result = await request('/spin', { bet });
          resultSymbols = result.reels;
          updateStats(result);
          updateLastSpin(result.lastSpin);
          log('Spin processed by Lambda', `${result.outcome} (balance ${currency.format(result.balance)})`);
        } catch (error) {
          const payload = error.payload || {};
          const msg = payload.message || error.message;
          if (els.error) els.error.textContent = msg;
          if (payload.balance !== undefined || payload.maxBet !== undefined) {
            updateStats({ balance: payload.balance, maxBet: payload.maxBet });
          }
          if (payload.errorCode === 'INSUFFICIENT_CREDITS') {
            log('Spin blocked', 'Insufficient credits');
          } else {
            log('Spin failed', msg);
          }
        } finally {
          stopReelSpinAnimation(resultSymbols);
          setBusy(false);
        }
      };

      const loginOrRegister = async () => {
        const email = (els.authEmail?.value || '').trim().toLowerCase();
        const password = els.authPassword?.value || '';
        if (!email || !password) {
          showAuthAlert('Enter your email and password.');
          return;
        }
        if (state.authMode === 'register') {
          const confirm = (els.authConfirm?.value || '').trim();
          if (!confirm) {
            showAuthAlert('Please confirm your password.');
            return;
          }
          if (confirm !== password) {
            showAuthAlert('Passwords do not match.');
            return;
          }
        }
        showAuthAlert('');
        toggleAuthInputs(true);
        try {
          const endpoint = state.authMode === 'register' ? '/auth/register' : '/auth/login';
          const result = await request(endpoint, { username: email, password }, { skipAuth: true });
          hydrateSession(result, state.authMode === 'register' ? 'Account created' : 'Signed in');
          showAuthAlert(state.authMode === 'register' ? 'Account created! Credits synced.' : 'Signed in successfully.');
        } catch (error) {
          showAuthAlert(error.message || 'Unable to process request.');
          log('Auth failed', error.message);
        } finally {
          toggleAuthInputs(false);
        }
      };

      const logout = async () => {
        if (!state.auth.token) return;
        showAuthAlert('');
        if (els.logoutBtn) els.logoutBtn.disabled = true;
        try {
          await request('/auth/logout', {});
        } catch (error) {
          console.error(error);
        } finally {
          if (els.logoutBtn) els.logoutBtn.disabled = false;
          setAuthState({});
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          log('Signed out', '');
          showAuthAlert('Signed out.');
        }
      };

      updateAuthUI();

      if (els.betSlider) {
        els.betSlider.addEventListener('input', (event) => {
          setBetValue(Number(event.target.value));
        });
      }

      const handleChipAction = (action) => {
        if (state.busy || !state.gameReady) return;
        if (action === 'increase') {
          setBetValue(state.bet + 5);
          return;
        }
        if (action === 'decrease') {
          setBetValue(state.bet - 5);
          return;
        }
        if (action === 'max') {
          setBetValue(state.maxBet || DEFAULT_MAX_BET);
        }
      };

      els.chipButtons.forEach(btn => {
        btn.addEventListener('click', () => handleChipAction(btn.dataset.chip));
      });

      els.spinBtn.addEventListener('click', spin);

      els.resetBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) {
          showAuthAlert('Sign in to use the slot machine.');
          return;
        }
        bootstrap();
      });

      els.syncBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) return;
        bootstrap();
      });

      if (els.authSubmit) {
        els.authSubmit.addEventListener('click', loginOrRegister);
      }
      (els.authTabs || []).forEach(btn => {
        btn.addEventListener('click', () => setAuthMode(btn.dataset.mode));
      });
      if (els.authInfo) {
        els.authInfo.addEventListener('click', () => {
          setAuthMode('register');
          els.authEmail?.focus();
        });
      }
      els.logoutBtn.addEventListener('click', logout);

      if (state.auth.token) {
        bootstrap();
      } else {
        setStatus('Sign in to start', 'error');
      }
    })();
  </script>
</body>
</html>
