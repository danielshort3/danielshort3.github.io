<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <base href="/">
  <title>Server-Backed Slot Machine Demo</title>
  <meta name="theme-color" content="#0d1117" />
  <link rel="stylesheet" href="dist/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500&display=swap" />
  <style>
    :root {
      --app-vh: 1vh;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      color-scheme: light dark;
      --bg: #020617;
      --panel: color-mix(in srgb, var(--surface, #0f172a) 90%, black 10%);
      --panel-border: color-mix(in srgb, var(--surface-accent, #1e293b) 70%, transparent);
      --text: var(--text-light, #e2e8f0);
      --muted: color-mix(in srgb, var(--text) 65%, transparent);
      --accent: #facc15;
      --accent-2: #6366f1;
      --danger: #f87171;
      --radius: 16px;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 800px at 12% -10%, rgba(99, 102, 241, .14), transparent 55%),
        radial-gradient(1000px 700px at 88% 0%, rgba(14, 165, 233, .12), transparent 55%),
        linear-gradient(180deg, #010915, var(--bg));
      color: var(--text);
      padding: clamp(20px, 3vw, 36px);
      display: block;
      overflow-y: auto;
    }
    html[data-embedded="true"] body {
      display: block;
    }
    main {
      width: min(1100px, 100%);
      background: color-mix(in srgb, var(--panel) 90%, #0b1224 10%);
      border: 1px solid color-mix(in srgb, var(--panel-border) 70%, transparent);
      border-radius: 22px;
      box-shadow: 0 24px 120px rgba(2, 6, 23, .72);
      padding: clamp(24px, 3vw, 36px);
      display: grid;
      gap: 28px;
      margin: 0 auto;
    }
    header h1 {
      font-family: "Space Grotesk", Inter, sans-serif;
      font-size: clamp(1.75rem, 3vw, 2.5rem);
      margin: 0 0 8px;
    }
    header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: .9rem;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 60%, transparent);
      background: rgba(99, 102, 241, .12);
    }
    .status-pill.ghost {
      background: rgba(255,255,255,.12);
      border-color: rgba(255,255,255,.2);
      color: rgba(255,255,255,.85);
    }
    .status-pill[data-state="error"] {
      color: var(--danger);
      background: rgba(244, 114, 182, .1);
    }
    .grid {
      display: grid;
      gap: 16px;
    }
    .grid-two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .panel {
      border-radius: 18px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 55%, transparent);
      padding: 18px 20px;
      background: color-mix(in srgb, rgba(15, 23, 42, .9) 90%, rgba(6, 11, 22, .92) 10%);
      box-shadow: 0 16px 60px rgba(2, 6, 23, .5);
    }
    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      font-weight: 600;
    }
    dl {
      margin: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 16px;
      font-size: .95rem;
    }
    dt {
      color: var(--muted);
      font-weight: 500;
    }
    dd {
      margin: 0;
      font-weight: 600;
    }
    .reels {
      display: grid;
      grid-template-columns: repeat(3, minmax(80px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .slot-cell {
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, white 12%, transparent);
      display: grid;
      place-items: center;
      font-size: 2.75rem;
      background: rgba(15, 23, 42, .8);
      box-shadow: inset 0 0 30px rgba(0,0,0,.3);
      transition: transform .45s cubic-bezier(.34, 1.56, .64, 1);
    }
    .slot-cell.spin {
      transform: scale(1.08) rotateX(360deg);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .controls label {
      font-size: .9rem;
      color: var(--muted);
    }
    .controls input[type="number"] {
      width: 120px;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(15, 23, 42, .8);
      color: inherit;
      font-size: 1rem;
    }
    .controls button {
      border: none;
      border-radius: 999px;
      padding: 12px 28px;
      font-size: .95rem;
      font-weight: 600;
      cursor: pointer;
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      box-shadow: 0 10px 30px rgba(250, 204, 21, .35);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .controls button[disabled] {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .controls button:not([disabled]):active {
      transform: translateY(1px);
    }
    .alert {
      padding: 12px 14px;
      border-radius: 10px;
      font-size: .95rem;
      background: rgba(248, 113, 113, .1);
      border: 1px solid rgba(248, 113, 113, .4);
      color: var(--danger);
    }
    .log {
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
      max-height: 160px;
      overflow-y: auto;
    }
    .log-entry + .log-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .ghost-btn {
      border: 1px solid rgba(255,255,255,.25);
      color: var(--muted);
      background: transparent;
      border-radius: 10px;
      padding: 8px 14px;
      font-size: .85rem;
      cursor: pointer;
    }
    .ghost-btn:disabled {
      opacity: .5;
      cursor: default;
    }
    .ghost-btn.primary {
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      border-color: transparent;
      font-weight: 600;
      box-shadow: 0 15px 35px rgba(250, 204, 21, .35);
    }
    .ghost-btn.secondary {
      color: var(--text);
      border-color: rgba(255,255,255,.25);
    }
    .ghost-btn.tertiary {
      color: var(--muted);
      border-color: transparent;
      background: rgba(255,255,255,.08);
    }
    .ghost-btn.danger {
      color: var(--danger);
      border-color: rgba(248,113,113,.5);
      background: rgba(248,113,113,.08);
    }
    .auth-overlay {
      position: fixed;
      inset: 0;
      z-index: 40;
      background: radial-gradient(circle at top, rgba(15,23,42,.9), rgba(2,6,23,.98));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(16px, 4vw, 48px);
      transition: opacity .35s ease, visibility .35s ease;
    }
    .auth-overlay[data-hidden="true"] {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .auth-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(20px, 5vw, 36px);
      width: min(960px, 100%);
      border-radius: 26px;
      border: 1px solid rgba(99,102,241,.35);
      background: linear-gradient(135deg, rgba(15,23,42,.95), rgba(30,64,175,.9));
      padding: clamp(24px, 5vw, 48px);
      box-shadow: 0 40px 150px rgba(2, 6, 23, .9);
      position: relative;
      overflow: hidden;
    }
    .auth-card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at top right, rgba(99,102,241,.4), transparent 45%);
      pointer-events: none;
    }
    .auth-copy {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 12px;
    }
    .auth-copy h2 {
      margin: 0;
      font-size: clamp(1.6rem, 3vw, 2.4rem);
      font-weight: 600;
      color: #fff;
    }
    .auth-copy p {
      margin: 0;
      color: color-mix(in srgb, #fff 85%, rgba(255,255,255,.4));
      line-height: 1.6;
    }
    .auth-body {
      position: relative;
      z-index: 1;
      background: rgba(2, 6, 23, .7);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.08);
      padding: clamp(18px, 4vw, 28px);
      display: grid;
      gap: 18px;
    }
    .auth-tabs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      padding: 5px;
    }
    .auth-tab {
      border: none;
      background: transparent;
      color: rgba(255,255,255,.7);
      font-weight: 600;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: background .2s ease, color .2s ease;
    }
    .auth-tab.active {
      background: rgba(255,255,255,.14);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .auth-forms {
      display: grid;
      gap: 15px;
    }
    .auth-forms label {
      display: grid;
      gap: 6px;
      font-size: .9rem;
      color: rgba(255,255,255,.7);
    }
    .auth-forms input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(15, 23, 42, .85);
      color: inherit;
      font-size: 1rem;
      transition: border .2s ease, box-shadow .2s ease;
    }
    .auth-forms input:focus-visible {
      outline: none;
      border-color: rgba(250,204,21,.65);
      box-shadow: 0 0 0 2px rgba(250,204,21,.2);
    }
    .auth-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .muted-text {
      color: rgba(255,255,255,.65);
      margin: 0;
      font-size: .9rem;
    }
    .muted-text.small {
      font-size: .8rem;
    }
    .alert {
      margin-top: 4px;
    }
    .auth-body[data-mode="login"] #auth-confirm-group {
      display: none;
    }
    .auth-body[data-mode="register"] #auth-info {
      display: none;
    }
    .status-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 8px;
      gap: 12px;
      flex-wrap: wrap;
    }
    .status-row .status-pill {
      margin: 0;
      flex: 1 1 auto;
      min-width: 0;
    }
    .status-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      flex: 0 0 auto;
    }
    .status-icon {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(15,23,42,.7);
      display: grid;
      place-items: center;
      color: var(--text);
      cursor: pointer;
      padding: 0;
    }
    .status-icon:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .status-icon svg {
      width: 22px;
      height: 22px;
      display: block;
    }
    .account-sheet {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: min(420px, calc(100% - 32px));
      z-index: 30;
      box-shadow: 0 20px 80px rgba(2,6,23,.7);
      backdrop-filter: blur(6px);
    }
    .account-sheet[hidden] {
      display: none;
    }
    .account-sheet__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .slot-machine {
      background: linear-gradient(150deg, rgba(9,14,28,.94), rgba(5,10,22,.94));
      border: 1px solid rgba(148,163,184,.28);
      border-radius: 24px;
      box-shadow: 0 30px 90px rgba(2,6,23,.7);
      padding: clamp(18px, 2.4vw, 26px);
    }
    .slot-machine__body {
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 2.4vw, 24px);
      padding-top: 10px;
      align-items: stretch;
    }
    .machine-switcher {
      border: 1px solid rgba(148,163,184,.24);
      border-radius: 18px;
      background: linear-gradient(150deg, rgba(12,18,36,.9), rgba(4,7,18,.9));
      padding: 12px 14px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
      display: grid;
      gap: 10px;
    }
    .machine-switcher__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .machine-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }
    .machine-card {
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,.03);
      display: grid;
      gap: 6px;
      cursor: pointer;
      text-align: left;
      transition: border .18s ease, transform .18s ease, box-shadow .18s ease;
      min-height: 86px;
    }
    .machine-card:hover {
      border-color: rgba(99,102,241,.5);
      transform: translateY(-2px);
      box-shadow: 0 12px 28px rgba(15,23,42,.4);
    }
    .machine-card[data-active="true"] {
      border-color: rgba(34,211,238,.65);
      box-shadow: 0 16px 32px rgba(34,211,238,.25);
      background: linear-gradient(120deg, rgba(34,211,238,.1), rgba(250,204,21,.08));
    }
    .machine-card__name {
      margin: 0;
      font-weight: 700;
      color: var(--text);
    }
    .machine-card__meta {
      margin: 0;
      color: var(--muted);
      font-size: .85rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .machine-card__icon {
      width: 36px;
      height: 36px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(255,255,255,.04);
      padding: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .machine-frame {
      position: relative;
      border-radius: 26px;
      border: 1px solid rgba(99,102,241,.28);
      padding: clamp(16px, 3vw, 24px);
      background:
        radial-gradient(circle at 22% 0%, rgba(59,130,246,.16), transparent 42%),
        linear-gradient(180deg, rgba(12,18,36,.94), rgba(6,11,22,.98));
      overflow: hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 18px 50px rgba(2,6,23,.7);
    }
    .machine-frame__glow {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 50% 18%, rgba(99,102,241,.22), transparent 48%);
      opacity: .9;
      pointer-events: none;
    }
    .machine-frame__reels {
      position: relative;
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, rgba(8,13,26,.86), rgba(4,7,16,.94));
      padding: clamp(16px, 3vw, 22px);
      border-radius: 22px;
      box-shadow: inset 0 0 32px rgba(0,0,0,.45), 0 12px 30px rgba(0,0,0,.4);
      overflow: hidden;
    }
    .slot-grid {
      --reel-count: 3;
      --row-count: 3;
      --cell-size: clamp(52px, 9vw, 96px);
      display: grid;
      grid-template-columns: repeat(var(--reel-count), minmax(var(--cell-size), 1fr));
      gap: clamp(8px, 1.5vw, 14px);
      perspective: 1200px;
      position: relative;
      padding: clamp(6px, 1vw, 12px);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.04);
      background: radial-gradient(circle at 50% 20%, rgba(255,255,255,.04), transparent 62%);
      width: 100%;
      min-width: 100%;
    }
    .slot-reel {
      position: relative;
      display: grid;
      grid-template-rows: repeat(var(--row-count), 1fr);
      gap: clamp(6px, 1.6vw, 12px);
      padding: clamp(6px, 1.4vw, 12px);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(16,24,40,.92), rgba(11,17,30,.92));
      border: 1px solid rgba(148,163,184,.22);
      box-shadow: inset 0 4px 12px rgba(0,0,0,.25), 0 10px 26px rgba(0,0,0,.28);
    }
    .slot-cell {
      position: relative;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      aspect-ratio: 1 / 1.1;
      display: grid;
      place-items: center;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 18px 35px rgba(0,0,0,.35);
      transition: transform .28s ease, box-shadow .28s ease, border-color .2s ease;
      pointer-events: none;
    }
    .slot-cell[data-state="spinning"] {
      opacity: .95;
    }
    .slot-cell[data-state="win"] {
      box-shadow: 0 0 0 2px rgba(250,204,21,.35), 0 22px 45px rgba(250,204,21,.28);
      transform: translateY(-2px) scale(1.02);
      border-color: rgba(250,204,21,.6);
    }
    .slot-cell__symbol {
      width: 80%;
      max-width: calc(var(--cell-size) * 0.9);
      display: grid;
      place-items: center;
    }
    .slot-cell__symbol img {
      width: 100%;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 12px 24px rgba(0,0,0,.45));
      transition: filter .2s ease, transform .2s ease;
    }
    .slot-cell[data-state="spinning"] .slot-cell__symbol {
      animation: slotReelSpin .35s linear infinite;
      opacity: .95;
    }
    .slot-cell[data-state="spinning"] .slot-cell__symbol img {
      filter: blur(1.4px) brightness(1.05);
    }
    .slot-cell.slot-lock .slot-cell__symbol {
      animation: none;
      transform: translateZ(0) scale(1.05);
      transition: transform .5s cubic-bezier(.19,1,.22,1);
    }
    .slot-cell.slot-lock .slot-cell__symbol img {
      filter: drop-shadow(0 15px 25px rgba(0,0,0,.35));
    }
    @media (hover: hover) {
      .slot-cell:not([data-state="spinning"]):hover {
        transform: translateY(-4px);
        box-shadow: 0 0 0 1px rgba(148,163,184,.3), 0 18px 36px rgba(0,0,0,.35);
      }
      .machine-frame__reels {
        max-width: 100%;
      }
      .slot-cell:not([data-state="spinning"]):hover .slot-cell__symbol img {
        transform: translateY(-2px);
      }
    }
    @media (min-width: 1080px) {
      .machine-frame {
        min-height: 380px;
      }
      .machine-frame__reels {
        min-height: 300px;
        align-items: center;
        justify-content: center;
      }
      .control-deck {
        grid-template-rows: auto auto auto auto;
      }
      .hud {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }
    @keyframes slotReelSpin {
      0% { transform: translateY(-16%); }
      50% { transform: translateY(16%); }
      100% { transform: translateY(-16%); }
    }
    .line-overlay {
      position: absolute;
      inset: clamp(12px, 2vw, 26px);
      pointer-events: none;
    }
    .line-overlay svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      overflow: visible;
    }
    .line-path {
      fill: none;
      stroke: hsl(var(--line-hue, 220), 90%, 65%);
      stroke-width: 3.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.92;
      stroke-dasharray: 12 10;
      animation: drawLine .9s ease forwards;
    }
    @keyframes drawLine {
      from { stroke-dashoffset: 40; opacity: 0; }
      to { stroke-dashoffset: 0; opacity: 0.95; }
    }
    .slot-cell.line-flash {
      box-shadow: 0 0 0 2px rgba(99,102,241,.75), 0 0 32px rgba(99,102,241,.4);
      transform: translateY(-2px);
    }
    @keyframes slotPulse {
      0% { transform: translateY(-4px) scale(.98); opacity: .8; }
      100% { transform: translateY(4px) scale(1.02); opacity: 1; }
    }
    .control-deck {
      display: grid;
      gap: 14px;
      background: linear-gradient(165deg, rgba(15,23,42,.84), rgba(12,16,32,.9));
      border-radius: 22px;
      border: 1px solid rgba(148,163,184,.24);
      padding: clamp(16px, 3vw, 20px);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04), 0 10px 30px rgba(0,0,0,.35);
      align-content: start;
    }
    .control-deck .hud,
    .control-deck .bet-controls,
    .control-deck .machine-messages,
    .control-deck .action-buttons {
      background: rgba(255,255,255,.02);
      border: 1px solid rgba(148,163,184,.18);
      border-radius: 14px;
      padding: 12px 14px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .drop-stack {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.22);
      background: linear-gradient(180deg, rgba(15,23,42,.8), rgba(4,6,20,.92));
      padding: 14px;
      display: grid;
      gap: 12px;
      position: relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .drop-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .drop-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .inventory-grid {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .inventory-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(148,163,184,.25);
      font-size: .9rem;
      color: var(--text);
    }
    .inventory-chip img {
      width: 22px;
      height: 22px;
      object-fit: contain;
      display: block;
    }
    .daily-reward {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.03);
      padding: 10px 12px;
      display: grid;
      gap: 8px;
    }
    .daily-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .daily-items {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .daily-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(99,102,241,.12);
      border: 1px solid rgba(99,102,241,.3);
      font-weight: 600;
      color: var(--text);
    }
    .daily-item img {
      width: 22px;
      height: 22px;
      object-fit: contain;
    }
    .bonus-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }
    .bonus-item {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.03);
      padding: 10px 12px;
    }
    .bonus-label {
      margin: 0;
      font-weight: 600;
    }
    .bonus-note {
      margin: 2px 0 0;
      color: var(--muted);
      font-size: .9rem;
    }
    .bonus-value {
      font-weight: 700;
      white-space: nowrap;
    }
    .drop-log {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(2,6,23,.7);
      padding: 10px;
      max-height: 180px;
      overflow-y: auto;
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
    }
    .drop-entry {
      display: flex;
      gap: 8px;
      align-items: center;
      line-height: 1.3;
    }
    .drop-entry + .drop-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.06);
    }
    .drop-icon {
      width: 22px;
      height: 22px;
      object-fit: contain;
      border-radius: 6px;
      background: rgba(255,255,255,.05);
      padding: 3px;
      display: block;
    }
    .drop-amount {
      font-weight: 600;
      color: var(--text);
    }
    .drop-panel {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 10px;
      width: min(480px, 100%);
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(4,6,20,.96);
      box-shadow: 0 20px 50px rgba(2,6,23,.65);
      padding: 12px 14px;
      z-index: 8;
    }
    .drop-panel[hidden] {
      display: none;
    }
    .drop-panel h4 {
      margin: 0 0 8px;
      font-size: 1rem;
    }
    .drop-panel ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
    }
    .drop-panel li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.2);
      padding: 8px 10px;
      background: rgba(255,255,255,.03);
    }
    .gear-card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .gear-panel,
    .card-panel {
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(180deg, rgba(12,18,36,.9), rgba(6,10,22,.92));
      padding: 12px;
      display: grid;
      gap: 10px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .panel-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .gear-slots,
    .card-slots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }
    .gear-slot,
    .card-slot {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.25);
      padding: 10px;
      background: rgba(255,255,255,.03);
      display: grid;
      gap: 6px;
      min-height: 90px;
    }
    .gear-slot.locked,
    .card-slot.locked {
      opacity: .55;
    }
    .gear-slot__meta,
    .card-slot__meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .gear-slot__name,
    .card-slot__name {
      margin: 0;
      font-weight: 700;
    }
    .gear-slot__bonus,
    .card-slot__effect {
      margin: 0;
      color: var(--muted);
      font-size: .9rem;
    }
    .gear-inventory,
    .card-collection {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }
    .gear-item,
    .card-item {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.02);
      padding: 10px;
      display: grid;
      gap: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .rarity-tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: .8rem;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(255,255,255,.05);
    }
    .card-item img,
    .card-slot img {
      width: 44px;
      height: 44px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(255,255,255,.05);
      padding: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .rate-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .drop-tier-label {
      margin: 6px 0 4px;
      font-size: .8rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: var(--muted);
    }
    .drop-mult {
      margin: 4px 0;
      font-size: .85rem;
      color: var(--muted);
    }
    .upgrade-panel {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(15,23,42,.8);
      padding: 18px;
      display: grid;
      gap: 16px;
    }
    .upgrade-panel h2,
    .upgrade-panel h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .upgrade-category + .upgrade-category {
      margin-top: 28px;
    }
    .upgrade-category h3 {
      margin: 0 0 8px;
      font-size: .95rem;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: rgba(226,232,240,.75);
    }
    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 14px;
      align-items: stretch;
    }
    .upgrade-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.25);
      padding: 14px;
      background: linear-gradient(180deg, rgba(14,20,35,.9), rgba(6,10,22,.94));
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 210px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .upgrade-card__meta {
      font-size: .82rem;
      color: rgba(148,163,184,.85);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .upgrade-card__note {
      font-size: .78rem;
      color: rgba(248,250,252,.7);
      margin: 0;
    }
    .upgrade-card h4 {
      margin: 0;
      font-size: 1rem;
    }
    .upgrade-card p {
      margin: 0;
      font-size: .85rem;
      color: var(--muted);
      min-height: 32px;
      flex: 1;
    }
    .upgrade-card strong {
      font-size: .95rem;
    }
    .upgrade-card button {
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: .9rem;
      background: rgba(99,102,241,.12);
      color: var(--text);
      cursor: pointer;
      width: 100%;
      margin-top: auto;
    }
    .upgrade-card button[data-disabled="true"],
    .upgrade-card button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      align-items: stretch;
    }
    .hud-card {
      border-radius: 12px;
      padding: 12px 14px;
      background: linear-gradient(180deg, rgba(17,24,39,.94), rgba(11,16,30,.92));
      border: 1px solid rgba(148,163,184,.26);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .hud-label {
      margin: 0;
      font-size: .75rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: rgba(148,163,184,.8);
    }
    .hud-value {
      font-size: clamp(1rem, 2.2vw, 1.15rem);
      margin-top: 6px;
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-variant-numeric: tabular-nums;
    }
    .bet-controls {
      display: grid;
      grid-template-columns: 44px 1fr 44px auto;
      gap: 10px;
      align-items: center;
    }
    .bet-controls input[type="range"] {
      grid-column: 2;
      width: 100%;
      accent-color: var(--accent, #facc15);
      height: 6px;
      border-radius: 999px;
    }
    .bet-controls button:nth-of-type(1) { grid-column: 1; }
    .bet-controls button:nth-of-type(2) { grid-column: 3; }
    .bet-controls button:nth-of-type(3) { grid-column: 4; }
    .chip {
      border: 1px solid rgba(148,163,184,.45);
      background: linear-gradient(180deg, rgba(15,23,42,.95), rgba(9,14,26,.95));
      color: #e2e8f0;
      border-radius: 12px;
      padding: 9px 12px;
      font-size: .92rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
    }
    .chip:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .machine-messages {
      min-height: 40px;
      display: grid;
      gap: 6px;
    }
    .machine-outcome-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .machine-outcome {
      margin: 0;
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }
    .machine-lines {
      margin: 0;
      font-size: .85rem;
      color: var(--muted);
      word-break: break-word;
    }
    .machine-error {
      margin: 0;
      color: #f97316;
      font-size: .9rem;
    }
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      align-items: stretch;
      justify-items: stretch;
    }
    .action-buttons .line-btn {
      padding: 9px 12px;
      font-size: .85rem;
      border-radius: 12px;
      min-width: 0;
    }
    .action-buttons .spin-btn {
      width: 100%;
    }
    .spin-btn {
      border: none;
      border-radius: 16px;
      padding: 16px 22px;
      font-size: 1.05rem;
      font-weight: 700;
      letter-spacing: .01em;
      color: #041226;
      background: linear-gradient(120deg, #22d3ee, #facc15);
      box-shadow: 0 18px 36px rgba(34,211,238,.32);
      cursor: pointer;
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .spin-btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .spin-btn:not(:disabled):hover {
      box-shadow: 0 22px 44px rgba(34,211,238,.36);
      transform: translateY(-1px);
    }
    .spin-btn:not(:disabled):active {
      transform: translateY(0);
      box-shadow: 0 12px 28px rgba(34,211,238,.3);
    }
    .paytable-panel {
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.22);
      background: linear-gradient(180deg, rgba(10,16,30,.92), rgba(5,9,18,.95));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .paytable {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }
    .paytable li {
      display: flex;
      justify-content: space-between;
      background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(9,14,26,.9));
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 16px;
      padding: 12px 16px;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
    }
    .paytable li[data-active="false"] {
      opacity: .45;
    }
    .paytable-symbol {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }
    .paytable-symbol img {
      width: 36px;
      height: 36px;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
    }
    .paytable-meta {
      font-size: .9rem;
      color: rgba(148,163,184,.85);
    }
    .desktop-nav {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 8px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(145deg, rgba(10,16,30,.92), rgba(8,13,24,.94));
      padding: 10px;
      box-shadow: 0 14px 40px rgba(2,6,23,.45);
    }
    .desktop-nav button {
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(255,255,255,.03);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      letter-spacing: .01em;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: border .16s ease, background .16s ease, transform .16s ease, box-shadow .16s ease;
    }
    .desktop-nav button.active {
      background: linear-gradient(120deg, #22d3ee, #facc15);
      color: #041226;
      border-color: transparent;
      box-shadow: 0 12px 28px rgba(34,211,238,.35);
      transform: translateY(-1px);
    }
    .desktop-nav button:not(.active):hover {
      border-color: rgba(148,163,184,.55);
      transform: translateY(-1px);
    }
    .mobile-nav {
      display: none;
      gap: 6px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(15,23,42,.85);
      padding: 8px;
    }
    .mobile-nav button {
      flex: 1;
      border: none;
      border-radius: 14px;
      padding: 8px;
      background: rgba(99,102,241,.12);
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      min-width: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: .72rem;
      line-height: 1.1;
    }
    .mobile-nav button svg {
      width: 20px;
      height: 20px;
      display: block;
    }
    .mobile-nav button span {
      font-size: .72rem;
      letter-spacing: .04em;
    }
    .mobile-nav button.active {
      background: linear-gradient(120deg, var(--accent), #fde047);
      color: #020617;
      box-shadow: 0 6px 18px rgba(250,204,21,.3);
    }
    main[data-pane-mode="tabbed"] [data-mobile-pane] {
      display: none;
    }
    main[data-pane-mode="tabbed"] [data-mobile-pane][data-mobile-active="true"] {
      display: block;
    }
    @media (max-width: 768px) {
      html, body {
        height: 100%;
      }
      body {
        padding: calc(env(safe-area-inset-top, 0px) + 6px) 0 calc(env(safe-area-inset-bottom, 0px) + 96px);
        min-height: calc((var(--app-vh, 1vh) * 100) - var(--safe-top, 0px));
        background: #020617;
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
        overflow-y: auto;
      }
      main {
        border-radius: 0;
        min-height: calc((var(--app-vh, 1vh) * 100) - var(--safe-top, 0px));
        padding: 0;
        gap: 10px;
        box-shadow: none;
        border: none;
        display: flex;
        flex-direction: column;
        flex: 1;
        width: 100%;
        overflow: visible;
      }
      main > * {
        margin-inline: 14px;
      }
      header {
        padding: 10px 12px;
      }
      .status-row {
        justify-content: space-between;
      }
      .slot-grid {
        gap: 8px;
      }
      .mobile-nav {
        display: flex;
        position: fixed;
        bottom: env(safe-area-inset-bottom, 10px);
        left: 12px;
        right: 12px;
        z-index: 15;
        background: rgba(2,6,23,.95);
        border-radius: 18px;
        border: 1px solid rgba(148,163,184,.25);
        box-shadow: 0 15px 40px rgba(2,6,23,.6);
        padding: 8px;
        flex-wrap: nowrap;
        justify-content: space-between;
      }
      .mobile-nav button {
        font-size: .85rem;
        min-height: 56px;
        flex: 1;
      }
      .desktop-nav {
        display: none;
      }
      main[data-tabs="true"] {
        gap: 8px;
        flex: 1;
      }
      main[data-tabs="true"] [data-mobile-pane] {
        display: none;
        margin-inline: 16px;
        min-height: 0;
      }
      main[data-tabs="true"] [data-mobile-pane][data-mobile-active="true"] {
        display: block;
        max-height: none;
        min-height: 0;
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      main[data-tabs="true"] [data-mobile-pane][data-mobile-active="true"].slot-machine {
        display: flex;
        flex-direction: column;
        overflow: hidden;
        flex: 1;
      }
      main[data-tabs="true"] section.panel {
        max-height: none;
        overflow: visible;
      }
      .slot-machine {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 12px 14px;
        border-radius: 20px;
        box-shadow: 0 25px 60px rgba(2,6,23,.65);
        min-height: 0;
        margin-bottom: 86px;
      }
      .slot-machine__body {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding-top: 0;
        overflow: hidden;
      }
      .machine-frame {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        justify-content: center;
        min-height: calc(var(--app-vh, 1vh) * 0.55);
        padding: 8px;
      }
      .machine-frame__reels {
        flex: 1;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6px;
        overflow: hidden;
      }
      .machine-frame__reels .slot-grid {
        align-content: center;
        justify-content: center;
        justify-items: center;
        height: auto;
        min-width: 100%;
      }
      .machine-frame__reels .slot-cell {
        height: auto;
      }
      .control-deck {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 14px;
        flex: 0 0 auto;
        background: linear-gradient(165deg, rgba(15,23,42,.9), rgba(8,12,24,.94));
      }
    .drop-log {
        max-height: 140px;
      }
      .drop-panel {
        position: fixed;
        left: 16px;
        right: 16px;
        bottom: clamp(96px, 22vh, 260px);
        top: auto;
        width: auto;
      }
      .slot-grid {
        gap: 8px;
        --cell-size: clamp(78px, 22vw, 120px);
      }
      .slot-grid .slot-cell {
        border-width: 1px;
        padding: 4px;
      }
      .slot-grid .slot-cell__symbol {
        max-width: 68px;
      }
      .hud {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
      }
      .hud-card {
        padding: 10px 12px;
      }
      .hud-value {
        font-size: .95rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-variant-numeric: tabular-nums;
      }
      .machine-messages {
        min-height: 42px;
      }
      .action-buttons {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        justify-items: stretch;
      }
      .action-buttons .spin-btn {
        grid-column: 1 / -1;
        min-height: 58px;
        font-size: 1.05rem;
      }
      .account-sheet {
        width: calc(100% - 32px);
        bottom: env(safe-area-inset-bottom, 16px);
      }
      .machine-list {
        grid-auto-flow: column;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        overflow-x: auto;
        padding-bottom: 6px;
        gap: 8px;
        scroll-snap-type: x proximity;
        overscroll-behavior-inline: contain;
      }
      .machine-card {
        min-width: 150px;
        scroll-snap-align: start;
      }
      .bet-controls {
        grid-template-columns: 52px 1fr 52px;
        grid-template-rows: auto auto;
        grid-auto-flow: row;
        gap: 8px;
      }
      .bet-controls input[type="range"] {
        grid-column: 1 / -1;
      }
      .chip {
        min-height: 46px;
      }
    }
  </style>
</head>
<body>
  <div class="auth-overlay" id="auth-overlay" aria-hidden="false" data-hidden="false">
    <div class="auth-card">
      <div class="auth-copy">
        <p class="status-pill ghost">üé∞ Demo Slot Machine</p>
        <h2>Log in to save your credits and keep the reels rolling.</h2>
        <p>This is a fun, server-backed slot machine demo‚Äîno real money is involved. Every spin is validated in AWS so balances carry across devices.</p>
        <p class="muted-text small">Passwords are hashed before storing and sessions auto-expire. Have fun exploring the animations and payouts.</p>
      </div>
      <div class="auth-body" id="auth-body" data-mode="login">
        <div class="auth-tabs" role="tablist">
          <button type="button" class="auth-tab active" data-mode="login">Sign In</button>
          <button type="button" class="auth-tab" data-mode="register">Create Account</button>
        </div>
        <div class="auth-forms">
          <label>
            Email
            <input type="email" id="auth-email" autocomplete="email" placeholder="you@example.com" required />
          </label>
          <label>
            Password
            <input type="password" id="auth-password" autocomplete="current-password" placeholder="At least 8 characters" required />
          </label>
          <label id="auth-confirm-group" hidden>
            Confirm password
            <input type="password" id="auth-confirm" autocomplete="new-password" placeholder="Repeat password" />
          </label>
          <div class="auth-actions">
            <button type="button" class="ghost-btn primary" id="auth-submit">Sign In</button>
            <button type="button" class="ghost-btn tertiary" id="auth-info">Need access? Register in seconds.</button>
          </div>
          <p class="muted-text small" id="auth-note">Passwords never leave AWS without hashing. Sessions expire automatically to keep balances safe.</p>
          <div class="alert" id="auth-alert" hidden role="status" aria-live="polite" tabindex="-1"></div>
        </div>
      </div>
    </div>
  </div>
  <a class="skip-link" href="#main">Skip to content</a>
  <main id="main" data-api-base="https://4kvebym8b3.execute-api.us-east-2.amazonaws.com/prod" data-max-bet="100" data-machine-config="slot-config/classic.json">
    <div class="status-row">
      <p class="status-pill" id="connection-pill" data-state="loading">
        <span aria-hidden="true">üõ∞Ô∏è</span>
        <span id="connection-text">Connecting to AWS‚Ä¶</span>
      </p>
      <div class="status-actions" data-requires-auth hidden>
        <button type="button" class="status-icon" id="account-toggle" aria-label="Account details">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <path d="M12 13.5c3.05 0 5.5-2.45 5.5-5.5S15.05 2.5 12 2.5 6.5 4.95 6.5 8s2.45 5.5 5.5 5.5zm0 2c-4.05 0-7.5 2.45-7.5 5.5 0 .28.22.5.5.5h14c.28 0 .5-.22.5-.5 0-3.05-3.45-5.5-7.5-5.5z" fill="currentColor"/>
          </svg>
        </button>
        <button type="button" class="status-icon" id="logout-btn" aria-label="Log out">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <path d="M14 3a1 1 0 00-1 1v4h2V5h4v14h-4v-3h-2v4a1 1 0 001 1h6a1 1 0 001-1V4a1 1 0 00-1-1h-6z" fill="currentColor"/>
            <path d="M15 11H7V9l-5 3 5 3v-2h8v-2z" fill="currentColor"/>
          </svg>
        </button>
      </div>
    </div>
    <nav class="desktop-nav" id="desktop-nav" aria-label="Game sections" data-requires-auth hidden>
      <button type="button" data-pane-target="play" class="active">Play</button>
      <button type="button" data-pane-target="stats">Stats</button>
      <button type="button" data-pane-target="paytable">Paytable</button>
      <button type="button" data-pane-target="items">Items</button>
      <button type="button" data-pane-target="log">Log</button>
      <button type="button" data-pane-target="upgrades">Upgrades</button>
    </nav>
    <nav class="mobile-nav" id="mobile-nav" aria-label="Game sections" data-requires-auth hidden>
      <button type="button" data-mobile-target="play" class="active" aria-label="Play">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="3" y="5" width="18" height="14" rx="3" ry="3" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <circle cx="9" cy="12" r="1.6" fill="currentColor"></circle>
          <circle cx="12" cy="12" r="1.6" fill="currentColor" opacity=".65"></circle>
          <circle cx="15" cy="12" r="1.6" fill="currentColor" opacity=".4"></circle>
        </svg>
        <span>Play</span>
      </button>
      <button type="button" data-mobile-target="stats" aria-label="Stats">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <path d="M5 17v-4m4 4V7m4 10v-7m4 7V9" fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.6"></path>
        </svg>
        <span>Stats</span>
      </button>
      <button type="button" data-mobile-target="paytable" aria-label="Paytable">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="5" y="6" width="14" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <path d="M8 9h8M8 12h8M8 15h5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Pay</span>
      </button>
      <button type="button" data-mobile-target="items" aria-label="Items">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="5" y="4" width="14" height="16" rx="3" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <path d="M9 9h6M9 13h3" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Items</span>
      </button>
      <button type="button" data-mobile-target="log" aria-label="Log">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="6" y="5" width="12" height="14" rx="2" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <path d="M9 9h6M9 12h6M9 15h4" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Log</span>
      </button>
      <button type="button" data-mobile-target="upgrades" aria-label="Upgrades">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <path d="M12 5v14m0-14l-3 3m3-3l3 3" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" fill="none"></path>
          <path d="M7 19h10" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Upg</span>
      </button>
    </nav>
    <section class="panel account-sheet" id="account-panel" role="dialog" aria-modal="true" aria-hidden="true" hidden tabindex="-1">
      <div class="account-sheet__header">
        <div>
          <p class="muted-text">Signed in as</p>
          <strong id="account-user"></strong>
        </div>
        <button type="button" class="ghost-btn tertiary" id="account-close" aria-label="Close account details">Close</button>
      </div>
      <div class="actions">
        <button type="button" class="ghost-btn secondary" id="sync-btn">Sync balance</button>
        <button type="button" class="ghost-btn tertiary" id="reset-btn">Reset session</button>
        <button type="button" class="ghost-btn primary" id="debug-add-coins" hidden>+100k credits</button>
        <button type="button" class="ghost-btn danger" id="delete-account-btn">Delete account</button>
      </div>
      <div class="actions">
        <button type="button" class="ghost-btn secondary" id="export-state-btn">Export key</button>
        <input type="text" id="import-state-input" placeholder="Paste key to import" aria-label="Import key" />
        <button type="button" class="ghost-btn tertiary" id="import-state-btn">Import key</button>
      </div>
      <p class="muted-text small" id="transfer-status"></p>
    </section>

    <section class="panel slot-machine" data-requires-auth hidden data-mobile-pane="play" data-mobile-active="true">
      <div class="slot-machine__body">
        <div class="machine-switcher">
          <div class="machine-switcher__header">
            <div>
              <p class="hud-label">Machines</p>
              <strong class="hud-value" id="machine-name">Lucky Lambda Classic</strong>
            </div>
            <span class="status-pill ghost" id="machine-tier">Demo Suite</span>
          </div>
          <div class="machine-list" id="machine-list" role="list"></div>
        </div>
        <div class="machine-frame">
          <div class="machine-frame__glow"></div>
          <div class="machine-frame__reels" id="reel-stage">
            <div class="slot-grid" id="slot-grid" aria-live="polite"></div>
            <div class="line-overlay" id="line-overlay" aria-hidden="true"></div>
          </div>
        </div>
        <div class="control-deck">
          <div class="hud">
            <div class="hud-card">
              <p class="hud-label">Credits</p>
              <strong class="hud-value" id="hud-balance">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Bet</p>
              <strong class="hud-value" id="hud-bet">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Last win</p>
              <strong class="hud-value" id="hud-win">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">VIP Marks</p>
              <strong class="hud-value" id="hud-vip">0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Energy</p>
              <strong class="hud-value" id="hud-energy">0/0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Machine Lv</p>
              <strong class="hud-value" id="hud-level">0</strong>
            </div>
          </div>
          <div class="bet-controls">
            <button type="button" class="chip" data-chip="decrease" aria-label="Decrease bet">-</button>
            <input type="range" id="bet-range" min="0" max="10" value="0" aria-label="Bet amount" />
            <button type="button" class="chip" data-chip="increase" aria-label="Increase bet">+</button>
            <button type="button" class="chip" data-chip="max" aria-label="Max bet">Max</button>
          </div>
          <div class="machine-messages">
            <div class="machine-outcome-group">
              <p class="machine-outcome" id="machine-outcome">Sign in to start spinning.</p>
              <p class="machine-lines" id="machine-lines"></p>
            </div>
            <p class="machine-error" id="error" role="status" aria-live="polite"></p>
            <div class="alert" id="alert" hidden></div>
          </div>
          <div class="action-buttons">
            <button type="button" class="ghost-btn secondary line-btn" id="line-flash-btn">Show lines</button>
            <button type="button" class="ghost-btn secondary line-btn" id="auto-spin-btn">Auto</button>
            <button type="button" class="ghost-btn secondary line-btn" id="premium-shop-btn">Premium</button>
            <button type="button" class="ghost-btn secondary line-btn" id="payout-skill-btn">Payout+</button>
            <button type="button" class="ghost-btn secondary line-btn" id="worker-btn">Worker</button>
            <button type="button" class="spin-btn" id="spin-btn" disabled>Spin</button>
          </div>
        </div>
      </div>
    </section>

    <section class="grid grid-two" data-requires-auth hidden data-mobile-pane="stats">
      <div class="panel">
        <h2>Session</h2>
        <dl id="session-stats">
          <dt>Player ID</dt><dd id="player-id">‚Äî</dd>
          <dt>Balance</dt><dd id="balance">‚Äî</dd>
          <dt>Max Bet</dt><dd id="max-bet">‚Äî</dd>
          <dt>Total Spins</dt><dd id="spin-count">‚Äî</dd>
        </dl>
      </div>
      <div class="panel">
        <h2>Last Result</h2>
        <dl>
          <dt>Outcome</dt><dd id="last-outcome">‚Äî</dd>
          <dt>Winnings</dt><dd id="last-win">‚Äî</dd>
          <dt>Multiplier</dt><dd id="last-multiplier">‚Äî</dd>
          <dt>Timestamp</dt><dd id="last-time">‚Äî</dd>
        </dl>
      </div>
      <div class="panel" id="daily-panel">
        <div class="status-row">
          <h2>Daily Rewards</h2>
          <span class="status-pill" id="daily-status">Syncing‚Ä¶</span>
        </div>
        <p class="muted-text" id="daily-streak">Day 1 of 7</p>
        <div class="daily-reward" id="daily-reward">
          <div class="daily-row">
            <span class="hud-label">Today&apos;s reward</span>
            <strong class="hud-value" id="daily-reward-main">$0</strong>
          </div>
          <div class="daily-items" id="daily-items"></div>
        </div>
        <div class="actions">
          <button type="button" class="ghost-btn primary" id="daily-claim-btn">Claim</button>
        </div>
        <p class="muted-text small" id="daily-next-reset">Resets daily</p>
      </div>
      <div class="panel" id="bonus-panel">
        <h2>Equipment Bonuses</h2>
        <ul class="bonus-list" id="bonus-list">
          <li class="bonus-item"><span class="bonus-label">Calculating bonuses‚Ä¶</span></li>
        </ul>
      </div>
    </section>

    <section class="panel paytable-panel" data-requires-auth hidden data-mobile-pane="paytable">
      <h2>Paytable</h2>
      <ul class="paytable" id="paytable"></ul>
      <p class="muted-text small">Multipliers apply to your active bet. Triple matches and pairs are calculated server-side.</p>
    </section>

    <section class="panel" data-requires-auth hidden data-mobile-pane="items">
      <div class="drop-stack">
        <div class="drop-header">
          <div>
            <p class="hud-label">Inventory</p>
            <div class="inventory-grid" id="inventory-grid"></div>
          </div>
          <div class="drop-actions">
            <button type="button" class="ghost-btn secondary" id="drop-rates-btn">Drop rates</button>
            <button type="button" class="ghost-btn tertiary" id="drop-skill-btn">Drop boost</button>
            <button type="button" class="ghost-btn tertiary" id="drop-close-btn">Close</button>
          </div>
        </div>
        <div class="drop-log" id="drop-log" aria-live="polite"></div>
        <div class="drop-panel" id="drop-panel" hidden aria-live="polite"></div>
      </div>
      <div class="gear-card-grid">
        <div class="gear-panel" id="gear-panel">
          <div class="panel-heading">
            <div>
              <p class="hud-label">Equipment</p>
              <strong class="hud-value" id="gear-summary">0/3 equipped</strong>
            </div>
            <span class="status-pill ghost" id="gear-cap">3 slots</span>
          </div>
          <div class="gear-slots" id="gear-slots"></div>
          <div class="gear-inventory" id="gear-inventory"></div>
        </div>
        <div class="card-panel" id="card-panel">
          <div class="panel-heading">
            <div>
              <p class="hud-label">VIP Cards</p>
              <strong class="hud-value" id="card-summary">Deck 0/3</strong>
            </div>
            <span class="status-pill ghost" id="card-cap">3 slots</span>
          </div>
          <div class="card-slots" id="card-slots"></div>
          <div class="card-collection" id="card-collection"></div>
        </div>
      </div>
    </section>

    <section class="panel" data-requires-auth hidden data-mobile-pane="log">
      <h2>Server Event Log</h2>
      <div class="log" id="log" aria-live="polite"></div>
    </section>

    <section class="panel upgrade-panel" id="upgrade-panel" data-requires-auth hidden data-mobile-pane="upgrades">
      <h2>Machine Upgrades</h2>
      <div class="upgrade-grid" id="upgrade-grid"></div>
    </section>
  </main>

  <script>
    (() => {
      const DEBUG = true;
      const debug = (...args) => DEBUG && console.debug('[slot-demo]', ...args);
      const debugError = (scope, error, extra = {}) => {
        if (!DEBUG) return;
        console.error(`[slot-demo][${scope}]`, error, extra);
      };
      const collectPendingIdle = () => {
        if (!state.pendingIdleCoins) return;
        const delta = Math.max(0, state.pendingIdleCoins);
        state.balance += delta;
        state.pendingIdleCoins = 0;
        if (els.balance) els.balance.textContent = currency.format(state.balance);
        updateHud();
      };
      window.addEventListener('error', (event) => {
        debugError('window-error', event.error || event.message, { event });
      });
      window.addEventListener('unhandledrejection', (event) => {
        debugError('unhandled-rejection', event.reason, {});
      });

      const setViewportUnit = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--app-vh', `${vh}px`);
      };
      setViewportUnit();
      window.addEventListener('resize', setViewportUnit);
      window.addEventListener('orientationchange', setViewportUnit, { passive: true });

      const root = document.getElementById('main');
      if (!root) {
        debugError('init', 'Missing #main element');
        return;
      }
      const API_BASE = root.dataset.apiBase;
      const DEFAULT_MAX_BET = Number(root.dataset.maxBet) || 100;
      const MACHINE_CONFIG_URL = root.dataset.machineConfig || '';
      const MACHINE_LIST_URL = 'slot-config/machines/index.json';
      const MACHINE_CONFIG_DIR = 'slot-config/machines';
      const DROP_TABLE_URL = 'slot-config/drop-tables.json';
      const GEAR_DEFS_URL = 'slot-config/gear-definitions.json';
      const CARD_DEFS_URL = 'slot-config/card-definitions.json';
      const LOCAL_MACHINE_KEY = 'slotMachineActiveMachine';
      const LOCAL_EQUIPMENT_KEY = 'slotMachineEquipment';
      const LOCAL_CARD_KEY = 'slotMachineCards';
      const SESSION_SYNC_MS = 60000;
      let sessionSyncTimer = null;
      let sessionSyncInFlight = false;
      const storageKeys = {
        player: 'slotMachineDemoPlayerId',
        token: 'slotMachineAuthToken',
        user: 'slotMachineAuthUser'
      };
      const DEBUG_EMAIL = 'danielshort3@gmail.com';
      const requestFrame = window.requestAnimationFrame?.bind(window) || (cb => setTimeout(() => cb(performance.now()), 1000 / 60));
      const cancelFrame = window.cancelAnimationFrame?.bind(window) || clearTimeout;
      const AUTH_MODE_KEY = 'slotMachineAuthMode';
      const getStored = (key) => {
        const value = localStorage.getItem(key);
        return value && value !== 'null' ? value : null;
      };
      const DEFAULT_SYMBOLS = [
        { key: 'cherry', label: 'Cherry', asset: 'img/slot/classic/symbols/cherry.png' },
        { key: 'lemon', label: 'Lemon', asset: 'img/slot/classic/symbols/lemon.png' },
        { key: 'orange', label: 'Orange', asset: 'img/slot/classic/symbols/orange.png' },
        { key: 'plum', label: 'Plum', asset: 'img/slot/classic/symbols/plum.png' },
        { key: 'watermelon', label: 'Watermelon', asset: 'img/slot/classic/symbols/watermelon.png' },
        { key: 'horseshoe', label: 'Horseshoe', asset: 'img/slot/classic/symbols/horseshoe.png' },
        { key: 'bell', label: 'Bell', asset: 'img/slot/classic/symbols/bell.png' },
        { key: 'diamond', label: 'Diamond', asset: 'img/slot/classic/symbols/diamond.png' },
        { key: 'seven', label: 'Lucky Seven', asset: 'img/slot/classic/symbols/seven.png' },
        { key: 'crown', label: 'Crown', asset: 'img/slot/classic/symbols/crown.png' },
        { key: 'wild', label: 'Wild', asset: 'img/slot/classic/symbols/wild.png' },
        { key: 'bonus', label: 'Bonus Sigil', asset: 'img/slot/classic/symbols/bonus.png' }
      ];
      const PLACEHOLDER_ASSET = 'img/slot/placeholder.png';
      const buildSymbolMap = (symbols = [], baseMap = null, placeholderAsset = PLACEHOLDER_ASSET) => {
        const seedEntries = baseMap
          ? Array.from(baseMap.entries())
          : DEFAULT_SYMBOLS.map(entry => [entry.key, { ...entry }]);
        const map = new Map(seedEntries.map(([key, val]) => [key, { ...val, asset: val.asset || placeholderAsset }]));
        if (!Array.isArray(symbols) || !symbols.length) return map;
        symbols.forEach(entry => {
          if (!entry || !entry.key) return;
          const prev = map.get(entry.key) || { key: entry.key, label: entry.label || entry.key, asset: placeholderAsset };
          map.set(entry.key, {
            ...prev,
            ...entry,
            asset: entry.asset || prev.asset || placeholderAsset
          });
        });
        return map;
      };
      const cloneSymbolMap = (map) => new Map(Array.from(map.entries()).map(([key, val]) => [key, { ...val }]));
      const DEFAULT_SYMBOL_MAP = buildSymbolMap(DEFAULT_SYMBOLS, null, PLACEHOLDER_ASSET);
      const DAILY_LENGTH = 7;

      const state = {
        playerId: null,
        balance: 0,
        maxBet: DEFAULT_MAX_BET,
        bet: 25,
        busy: false,
        gameReady: false,
        auth: {
          token: getStored(storageKeys.token),
          username: getStored(storageKeys.user)
        },
        authMode: localStorage.getItem(AUTH_MODE_KEY) || 'login',
        machine: {
          id: 'classic',
          name: 'Lucky Lambda Classic',
          rows: 3,
          reels: 3,
          lineTier: 0,
          lines: [],
          payouts: {},
          assets: {},
          placeholder: PLACEHOLDER_ASSET,
          upgradeSettings: {
            baseRows: 3,
            maxRows: 5,
            baseReels: 3,
            maxReels: 5,
            costs: { rows: [], reels: [], lines: [] }
          },
          baseSymbolCount: 5,
          activeSymbols: [],
          spinTiming: { overspin: [10, 12, 15], brake: 180 }
        },
        drop: {
          tableKey: 'classic',
          table: { common: [], rare: [], epic: [] },
          tierWeights: { common: 0.8, rare: 0.15, epic: 0.05 },
          constants: { betScale: 0.1, win: 2, lose: 1, boostScale: 0.05 },
          inventory: {},
          lastDrops: [],
          history: [],
          lastTimestamp: 0
        },
        daily: {
          streak: 1,
          claimedToday: false,
          ready: false,
          lastClaimMs: 0,
          nextResetAt: 0,
          todayReward: null
        },
        skills: {
          dropRate: {
            active: false,
            expiresAt: 0,
            cooldownUntil: 0,
            spec: { durationMs: 60000, cooldownMs: 120000, multiplier: 1.05 }
          }
        },
        equipment: {
          slots: { Head: null, Outfit: null, Accessory: null, Pet: null, Trinket: null },
          inventory: [],
          slotCap: 3
        },
        cards: {
          deck: [],
          collection: [],
          slots: 3
        },
        symbolMap: cloneSymbolMap(DEFAULT_SYMBOL_MAP),
        gridCells: new Map(),
        serverUpgrades: {},
        pendingUpgrades: {},
        upgrades: {},
        upgradeCatalog: [],
        lineFlashTimer: null,
        symbolWeights: { entries: [], total: 0 },
        autoSpin: { active: false, remaining: 0 },
        lastWin: 0,
        pendingIdleCoins: 0,
        idleTicker: null,
        idleTickerActive: false,
        lastIdleTick: 0,
        spinCount: 0,
        currentRows: 3,
        currentReels: 3,
        currentLineTier: 0,
        sync: {
          rev: 0,
          dirty: false,
          inFlight: false,
          lastPush: 0,
          debounceTimer: null,
          queue: []
        },
        energy: {
          current: 20,
          max: 20,
          rechargePerSec: 0.5,
          lastUpdate: Date.now()
        },
        machines: {},
        worker: {
          active: false,
          timer: null,
          intervalMs: 1800
        },
        skills: {
          payout: { activeUntil: 0, cooldownUntil: 0, durationMs: 15000, cooldownMs: 30000, multiplier: 1.25 },
          dropRate: {
            active: false,
            expiresAt: 0,
            cooldownUntil: 0,
            spec: { durationMs: 60000, cooldownMs: 120000, multiplier: 1.05 }
          }
        },
        jackpots: {
          chance: 0.01,
          multiplier: 10,
          hotStreak: { wins: 0, bonusPct: 0.1 }
        }
      };
      window.slotDemoDebug = window.slotDemoDebug || {};
      window.slotDemoDebug.state = state;
      window.slotDemoDebug.log = debug;
      window.slotDemoDebug.dumpState = () => JSON.parse(JSON.stringify({
        ...state,
        symbolMap: Array.from(state.symbolMap.keys()),
        upgrades: { ...state.upgrades },
        dropInventory: { ...state.drop.inventory },
        daily: { ...state.daily }
      }));
      const machineCache = new Map();
      let machineList = [];
      let dropTableCache = null;
      let gearDefinitions = null;
      let cardDefinitions = null;
      const SYNC_ENDPOINT = '/sync';
      const SYNC_DEBOUNCE_MS = 5000;
      const EXPORT_VERSION = 1;

      const upgradeCatalogUrl = 'slot-config/upgrade-definitions.json';
      const loadUpgradeCatalog = async () => {
        if (state.upgradeCatalog.length) return state.upgradeCatalog;
        try {
          const res = await fetch(upgradeCatalogUrl, { cache: 'no-cache' });
          if (res.ok) {
            const defs = await res.json();
            if (Array.isArray(defs)) {
              state.upgradeCatalog = defs;
              applyUpgradeState(state.upgrades);
              renderUpgrades();
              return defs;
            }
          }
        } catch (error) {
          console.error('upgrade catalog load failed', error);
        }
        return state.upgradeCatalog;
      };

      const getUpgradeDef = (key) => state.upgradeCatalog.find(def => def.key === key);

      const getUpgradeMaxLevel = (key) => {
        const def = getUpgradeDef(key);
        if (!def) return 0;
        if (def.dynamicMax === 'premiumSymbols') {
          const base = state.machine.baseSymbolCount || 5;
          const available = (state.machine.symbols || []).filter(entry => entry.key !== 'wild').length;
          return Math.max(0, available - base);
        }
        if (def.dynamicMax === 'cullSymbols') {
          const base = state.machine.baseSymbolCount || 5;
          return Math.max(0, base - 1);
        }
        return Number.isFinite(def.max) ? def.max : 0;
      };

      const computeActiveSymbols = (upgrades = state.upgrades) => {
        const list = (state.machine.symbols || []).filter(entry => entry.key !== 'wild');
        const disable = Math.max(0, Math.floor(upgrades.disable || 0));
        const premium = Math.max(0, Math.floor(upgrades.premium || 0));
        const baseCount = state.machine.baseSymbolCount || 5;
        const start = Math.min(disable, list.length - 1);
        const count = Math.min(list.length - start, baseCount + premium);
        const pool = list.slice(start, start + count).map(entry => entry.key);
        if (upgrades.wildUnlock) pool.push('wild');
        return pool;
      };

      const currency = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      });
      const compactCurrency = new Intl.NumberFormat('en-US', {
        notation: 'compact',
        compactDisplay: 'short',
        maximumFractionDigits: 1,
        minimumFractionDigits: 0
      });
      const formatCompactMoney = (value = 0) => {
        const safe = Number.isFinite(value) ? value : 0;
        return `$${compactCurrency.format(safe)}`;
      };
      const compactNumber = new Intl.NumberFormat('en-US', {
        notation: 'compact',
        compactDisplay: 'short',
        maximumFractionDigits: 1,
        minimumFractionDigits: 0
      });
      const formatCompactNumber = (value = 0) => compactNumber.format(Math.max(0, Number.isFinite(value) ? value : 0));
      const formatTime = (ms = 0) => {
        const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
        const m = Math.floor(totalSeconds / 60);
        const s = totalSeconds % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      };
      const textEncoder = new TextEncoder();
      const textDecoder = new TextDecoder();
      const base64UrlEncode = (bytes) => {
        const bin = Array.from(bytes || []).map(b => String.fromCharCode(b)).join('');
        return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      };
      const base64UrlDecode = (str = '') => {
        const padded = str.replace(/-/g, '+').replace(/_/g, '/').padEnd(Math.ceil(str.length / 4) * 4, '=');
        const bin = atob(padded);
        const out = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i += 1) out[i] = bin.charCodeAt(i);
        return out;
      };
      const deriveKey = async (token = '', salt = new Uint8Array(0), usage = 'encrypt', context = API_BASE || '') => {
        const seed = textEncoder.encode(context ? `${token}::${context}` : token);
        const data = new Uint8Array(seed.length + salt.length);
        data.set(seed, 0);
        data.set(salt, seed.length);
        const hash = await crypto.subtle.digest('SHA-256', data);
        if (usage === 'hmac') {
          return crypto.subtle.importKey('raw', hash, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign', 'verify']);
        }
        return crypto.subtle.importKey('raw', hash, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
      };
      const encryptBlob = async (token, payload) => {
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const key = await deriveKey(token, salt, 'encrypt');
        const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, payload);
        return { salt, iv, cipher: new Uint8Array(cipher) };
      };
      const decryptBlob = async (token, blob) => {
        const key = await deriveKey(token, blob.salt, 'encrypt');
        const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: blob.iv }, key, blob.cipher);
        return new Uint8Array(plain);
      };
      const hmacSign = async (token, payload, context = '') => {
        const salt = crypto.getRandomValues(new Uint8Array(8));
        const key = await deriveKey(token, salt, 'hmac', context);
        const sig = await crypto.subtle.sign('HMAC', key, payload);
        return { salt, sig: new Uint8Array(sig) };
      };
      const hmacVerify = async (token, payload, signature = {}, context = '') => {
        if (!signature) return false;
        try {
          const salt = signature.salt ? base64UrlDecode(signature.salt) : (signature.s ? base64UrlDecode(signature.s) : null);
          const sig = signature.value ? base64UrlDecode(signature.value) : (signature.sig ? base64UrlDecode(signature.sig) : null);
          if (!salt || !sig) return false;
          const key = await deriveKey(token, salt, 'hmac', context);
          return crypto.subtle.verify('HMAC', key, sig, payload);
        } catch {
          return false;
        }
      };
      const safeJsonParse = (raw, fallback = null) => {
        try {
          return JSON.parse(raw);
        } catch {
          return fallback;
        }
      };
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const randomGaussian = (mean = 0.5, std = 0.15) => {
        let u = 0; let v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const norm = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        const value = mean + std * norm;
        return Math.min(1, Math.max(0, value));
      };
      const resolveMaxBet = (incoming) => {
        const numeric = Number(incoming);
        if (Number.isFinite(numeric) && numeric > 0) return numeric;
        if (typeof state !== 'undefined' && Number.isFinite(state.maxBet) && state.maxBet > 0) return state.maxBet;
        return DEFAULT_MAX_BET;
      };
      const xpNeeded = (lvl = 0) => Math.max(50, Math.round(80 * Math.pow(lvl + 1, 2)));
      const UPGRADE_COST_GROWTH = 1.85;
      const computeUpgradeCost = (def, level = 0) => {
        if (!def) return 0;
        const base = def.cost || 0;
        const growth = Number.isFinite(def.costGrowth) ? def.costGrowth : UPGRADE_COST_GROWTH;
        const step = Math.max(0, Math.floor(level));
        return Math.round(base * Math.pow(Math.max(1, growth), step));
      };
      const buildBetSteps = (maxBet = DEFAULT_MAX_BET) => {
        const max = Math.max(1, Math.round(Number(maxBet) || DEFAULT_MAX_BET));
        const stepCount = Math.max(8, Math.min(18, Math.ceil(Math.log10(max) * 4)));
        const ratio = Math.pow(max, 1 / Math.max(1, stepCount - 1));
        const steps = new Set([1, max]);
        for (let i = 1; i < stepCount - 1; i += 1) {
          const value = Math.max(1, Math.round(Math.pow(ratio, i)));
          steps.add(value);
        }
        return Array.from(steps).sort((a, b) => a - b);
      };
      let betSteps = buildBetSteps(DEFAULT_MAX_BET);
      const getNearestBetIndex = (value) => {
        const steps = betSteps.length ? betSteps : buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        let bestIndex = 0;
        let bestDelta = Infinity;
        steps.forEach((step, idx) => {
          const delta = Math.abs(step - value);
          if (delta < bestDelta) {
            bestDelta = delta;
            bestIndex = idx;
          }
        });
        return bestIndex;
      };
      const betFromIndex = (index) => {
        const steps = betSteps.length ? betSteps : buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        const clamped = clamp(Math.round(index), 0, Math.max(0, steps.length - 1));
        return steps[clamped] || 1;
      };
      const syncBetSteps = () => {
        betSteps = buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        if (els.betSlider) {
          els.betSlider.min = 0;
          els.betSlider.max = Math.max(0, betSteps.length - 1);
          els.betSlider.step = 1;
          els.betSlider.value = getNearestBetIndex(state.bet);
        }
      };
      const isAutoSpinUnlocked = () => (state.upgrades.autoSpinUnlock || 0) > 0;
      const getAutoSpinCount = () => {
        const level = Math.max(0, state.upgrades.autoSpinCount || 0);
        return 5 + level * 5;
      };
      const LOCAL_UPGRADES_KEY = 'slotDemoLocalUpgrades';
      const CLIENT_ONLY_UPGRADES = new Set(['autoSpinUnlock', 'autoSpinCount']);
      const loadLocalUpgrades = () => {
        try {
          const raw = localStorage.getItem(LOCAL_UPGRADES_KEY);
          const parsed = raw ? JSON.parse(raw) : {};
          return parsed && typeof parsed === 'object' ? parsed : {};
        } catch {
          return {};
        }
      };
      const saveLocalUpgrades = (data) => {
        try {
          localStorage.setItem(LOCAL_UPGRADES_KEY, JSON.stringify(data));
        } catch {
          // ignore
        }
      };
      const localUpgrades = loadLocalUpgrades(); // shape: { [machineId]: { upgradeKey: level } }
      const localUpgradeBucket = (machineId = state.machine.id) => {
        if (!localUpgrades[machineId]) localUpgrades[machineId] = {};
        return localUpgrades[machineId];
      };
      const clearLocalUpgradeState = () => {
        Object.keys(localUpgrades || {}).forEach(key => { delete localUpgrades[key]; });
        try {
          localStorage.removeItem(LOCAL_UPGRADES_KEY);
        } catch {
          // ignore
        }
      };
      const resetAutoState = () => {
        state.autoSpin = { active: false, remaining: 0 };
      };
      const getEffectiveUpgradeLevel = (key) => {
        const currentLocal = localUpgradeBucket();
        const base = Number(getMachineUpgrades(state.machine.id)?.[key] || state.serverUpgrades?.[key] || 0);
        const pending = Number(state.pendingUpgrades?.[key] || 0);
        const local = Number(currentLocal?.[key] || 0);
        return Math.max(0, base + pending + local);
      };

      const machineIndex = (id = state.machine.id) => Math.max(0, (machineList || []).indexOf(id));
      const ensureMachineProgress = (id = state.machine.id) => {
        if (!state.machines[id]) {
          state.machines[id] = { xp: 0, lvl: 0, unlocked: machineIndex(id) === 0, upgrades: {} };
        }
        return state.machines[id];
      };
      const getMachineUpgrades = (id = state.machine.id) => {
        const prog = ensureMachineProgress(id);
        prog.upgrades = prog.upgrades || {};
        return prog.upgrades;
      };
      const addMachineXp = (id, xp) => {
        const prog = ensureMachineProgress(id);
        prog.xp = Math.max(0, (prog.xp || 0) + xp);
        let leveled = false;
        while (prog.xp >= xpNeeded(prog.lvl)) {
          prog.xp -= xpNeeded(prog.lvl);
          prog.lvl += 1;
          leveled = true;
        }
        // unlock next machine when leveling
        if (leveled) {
          const idx = machineIndex(id);
          const nextId = machineList?.[idx + 1];
          if (nextId) {
            ensureMachineProgress(nextId).unlocked = true;
          }
        }
        return leveled;
      };

      const buildLinePatterns = (rows, reels) => {
        const patterns = [];
        // Tier 0: straight lines
        for (let r = 0; r < rows; r += 1) {
          patterns.push({ pattern: Array(reels).fill(r), tier: 0 });
        }
        if (rows >= 2) {
          // Tier 1: simple diagonals
          const down = Array.from({ length: reels }, (_, i) => Math.min(rows - 1, i));
          const up = Array.from({ length: reels }, (_, i) => Math.max(0, rows - 1 - i));
          patterns.push({ pattern: down, tier: 1 });
          patterns.push({ pattern: up, tier: 1 });
          // Tier 2: zigzag bounce
          const zig = [];
          const zag = [];
          let r1 = 0; let d1 = 1;
          let r2 = rows - 1; let d2 = -1;
          for (let i = 0; i < reels; i += 1) {
            zig.push(r1);
            zag.push(r2);
            r1 += d1;
            r2 += d2;
            if (r1 === rows - 1 || r1 === 0) d1 *= -1;
            if (r2 === rows - 1 || r2 === 0) d2 *= -1;
          }
          patterns.push({ pattern: zig, tier: 2 });
          patterns.push({ pattern: zag, tier: 2 });
        }
        // Tier 3: all-touching paths (-1/0/+1 steps)
        if (rows > 0 && reels > 0) {
          const path = Array(reels).fill(0);
          const enumerate = (col, row) => {
            path[col] = row;
            if (col === reels - 1) {
              patterns.push({ pattern: [...path], tier: 3 });
              return;
            }
            for (const delta of [-1, 0, 1]) {
              const nr = row + delta;
              if (nr >= 0 && nr < rows) enumerate(col + 1, nr);
            }
          };
          for (let r = 0; r < rows; r += 1) enumerate(0, r);
        }
        return patterns;
      };

      const els = {
        connectionPill: document.getElementById('connection-pill'),
        connectionText: document.getElementById('connection-text'),
        slotGrid: document.getElementById('slot-grid'),
        lineOverlay: document.getElementById('line-overlay'),
        lineFlashBtn: document.getElementById('line-flash-btn'),
        spinBtn: document.getElementById('spin-btn'),
        autoSpinBtn: document.getElementById('auto-spin-btn'),
        premiumBtn: document.getElementById('premium-shop-btn'),
        resetBtn: document.getElementById('reset-btn'),
        syncBtn: document.getElementById('sync-btn'),
        alert: document.getElementById('alert'),
        error: document.getElementById('error'),
        machineOutcome: document.getElementById('machine-outcome'),
        machineLines: document.getElementById('machine-lines'),
        reelStage: document.getElementById('reel-stage'),
        betSlider: document.getElementById('bet-range'),
        chipButtons: Array.from(document.querySelectorAll('[data-chip]')),
        hudBalance: document.getElementById('hud-balance'),
        hudBet: document.getElementById('hud-bet'),
        hudWin: document.getElementById('hud-win'),
        hudVip: document.getElementById('hud-vip'),
        hudEnergy: document.getElementById('hud-energy'),
        hudLevel: document.getElementById('hud-level'),
        balance: document.getElementById('balance'),
        playerId: document.getElementById('player-id'),
        maxBet: document.getElementById('max-bet'),
        spinCount: document.getElementById('spin-count'),
        lastOutcome: document.getElementById('last-outcome'),
        lastWin: document.getElementById('last-win'),
        lastMult: document.getElementById('last-multiplier'),
        lastTime: document.getElementById('last-time'),
        log: document.getElementById('log'),
        paytable: document.getElementById('paytable'),
        dropLog: document.getElementById('drop-log'),
        dropPanel: document.getElementById('drop-panel'),
        dropRatesBtn: document.getElementById('drop-rates-btn'),
        dropSkillBtn: document.getElementById('drop-skill-btn'),
        dropCloseBtn: document.getElementById('drop-close-btn'),
        inventoryGrid: document.getElementById('inventory-grid'),
        machineList: document.getElementById('machine-list'),
        machineName: document.getElementById('machine-name'),
        machineTier: document.getElementById('machine-tier'),
        dailyStatus: document.getElementById('daily-status'),
        dailyRewardMain: document.getElementById('daily-reward-main'),
        dailyItems: document.getElementById('daily-items'),
        dailyClaimBtn: document.getElementById('daily-claim-btn'),
        dailyNextReset: document.getElementById('daily-next-reset'),
        dailyStreak: document.getElementById('daily-streak'),
        bonusList: document.getElementById('bonus-list'),
        gearSlots: document.getElementById('gear-slots'),
        gearInventory: document.getElementById('gear-inventory'),
        gearSummary: document.getElementById('gear-summary'),
        gearCap: document.getElementById('gear-cap'),
        gearPanel: document.getElementById('gear-panel'),
        cardSlots: document.getElementById('card-slots'),
        cardCollection: document.getElementById('card-collection'),
        cardSummary: document.getElementById('card-summary'),
        cardCap: document.getElementById('card-cap'),
        cardPanel: document.getElementById('card-panel'),
        authOverlay: document.getElementById('auth-overlay'),
        authBody: document.getElementById('auth-body'),
        authAlert: document.getElementById('auth-alert'),
        authEmail: document.getElementById('auth-email'),
        authPassword: document.getElementById('auth-password'),
        authConfirmGroup: document.getElementById('auth-confirm-group'),
        authConfirm: document.getElementById('auth-confirm'),
        authSubmit: document.getElementById('auth-submit'),
        authInfo: document.getElementById('auth-info'),
        authTabs: Array.from(document.querySelectorAll('.auth-tab')),
        authOverlayNote: document.getElementById('auth-note'),
        accountPanel: document.getElementById('account-panel'),
        accountToggle: document.getElementById('account-toggle'),
        accountClose: document.getElementById('account-close'),
        accountUser: document.getElementById('account-user'),
        logoutBtn: document.getElementById('logout-btn'),
        deleteBtn: document.getElementById('delete-account-btn'),
        debugCoinBtn: document.getElementById('debug-add-coins'),
        upgradeGrid: document.getElementById('upgrade-grid'),
        upgradePanel: document.getElementById('upgrade-panel'),
        mobileNav: document.getElementById('mobile-nav'),
        exportStateBtn: document.getElementById('export-state-btn'),
        importStateBtn: document.getElementById('import-state-btn'),
        importStateInput: document.getElementById('import-state-input'),
        transferStatus: document.getElementById('transfer-status'),
        payoutSkillBtn: document.getElementById('payout-skill-btn'),
        workerBtn: document.getElementById('worker-btn')
      };
      const paneState = {
        mq: window.matchMedia('(max-width: 768px)'),
        active: 'play'
      };
      const mobileButtons = Array.from(els.mobileNav?.querySelectorAll('[data-mobile-target]') || []);
      const desktopButtons = Array.from(document.querySelectorAll('[data-pane-target]'));
      const mobilePanes = Array.from(document.querySelectorAll('[data-mobile-pane]'));
      const applyPaneMode = () => {
        const isMobile = paneState.mq.matches;
        document.body.dataset.mobile = isMobile ? 'true' : 'false';
        if (root) {
          root.dataset.tabs = 'true';
          root.dataset.paneMode = 'tabbed';
          root.dataset.activePane = paneState.active;
        }
        const allButtons = [...mobileButtons, ...desktopButtons];
        allButtons.forEach(btn => {
          const target = btn.dataset.mobileTarget || btn.dataset.paneTarget;
          btn.classList.toggle('active', target === paneState.active);
        });
        mobilePanes.forEach(pane => {
          const paneId = pane.dataset.mobilePane || 'play';
          const active = paneId === paneState.active;
          pane.dataset.mobileActive = active ? 'true' : 'false';
        });
      };
      const setPaneActive = (target) => {
        if (target) {
          paneState.active = target;
        }
        if (root) {
          root.dataset.activePane = paneState.active;
        }
        applyPaneMode();
      };
      mobileButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          setPaneActive(btn.dataset.mobileTarget);
        });
      });
      desktopButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          setPaneActive(btn.dataset.paneTarget);
        });
      });
      if (paneState.mq.addEventListener) {
        paneState.mq.addEventListener('change', applyPaneMode);
      } else if (paneState.mq.addListener) {
        paneState.mq.addListener(applyPaneMode);
      }
      applyPaneMode();
      loadUpgradeCatalog();
      els.accountToggle?.addEventListener('click', () => toggleAccountSheet(true));
      els.accountClose?.addEventListener('click', () => toggleAccountSheet(false));
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (!els.accountPanel?.hidden) {
            toggleAccountSheet(false);
          }
          if (!els.dropPanel?.hidden) {
            toggleDropPanel(false);
          }
        }
      });
      const probedSymbols = new Set();
      const reelState = new Map();
      let pendingWinGroups = [];
      let pendingSpinResult = null;
      let activeReelLocks = 0;
      const settleWaiters = [];
      const notifyReelsSettled = () => {
        if (activeReelLocks === 0 && !anyReelSpinning()) {
          const waiters = settleWaiters.splice(0, settleWaiters.length);
          waiters.forEach(fn => fn());
        }
      };
      const waitForReelsToSettle = () => new Promise(resolve => {
        settleWaiters.push(resolve);
        notifyReelsSettled();
      });
      const getPlaceholderAsset = () => state?.machine?.assets?.placeholder || state?.machine?.placeholder || PLACEHOLDER_ASSET;
      const auditSymbolAssets = () => {
        state.symbolMap.forEach(entry => {
          if (!entry || !entry.key || !entry.asset || probedSymbols.has(entry.key)) return;
          probedSymbols.add(entry.key);
          const img = new Image();
          img.addEventListener('load', () => {
            debug('asset:load-ok', { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.addEventListener('error', () => {
            debugError('asset:load-failed', new Error('Failed to load symbol asset'), { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.src = entry.asset;
        });
      };
      const attachImageDebugging = (img, symbolKey) => {
        if (!img || img.dataset.debugAttached) return;
        img.dataset.debugAttached = 'true';
        img.addEventListener('error', () => {
          debugError('image', new Error('Image failed to load'), { symbol: symbolKey || img.dataset.symbolKey || img.alt, src: img.currentSrc || img.src });
          img.src = getPlaceholderAsset();
        });
      };
      const getSymbolEntry = (symbolKey) => {
        if (!symbolKey) {
          return { key: 'placeholder', label: 'Symbol', asset: getPlaceholderAsset() };
        }
        const entry = state.symbolMap.get(symbolKey) || DEFAULT_SYMBOL_MAP.get(symbolKey);
        if (entry) {
          return { ...entry, asset: entry.asset || getPlaceholderAsset() };
        }
        return { key: symbolKey, label: symbolKey, asset: getPlaceholderAsset() };
      };
      const applySymbolToImage = (img, symbolKey) => {
        const info = getSymbolEntry(symbolKey);
        if (!img) return info;
        const needsUpdate = img.dataset.symbolKey !== info.key || img.dataset.symbolAsset !== info.asset;
        if (needsUpdate) {
          img.dataset.symbolKey = info.key;
          img.dataset.symbolAsset = info.asset;
          img.alt = info.label || info.key;
          img.src = info.asset || getPlaceholderAsset();
          if (!info.asset || info.asset === getPlaceholderAsset()) {
            debug('symbol:placeholder-used', { symbol: info.key, reason: 'missing asset' });
          }
        }
        attachImageDebugging(img, info.key);
        return info;
      };
      const upgradeDefinitions = {
        rows: {
          label: 'Extra Rows',
          description: 'Adds another horizontal row so more lines can form.',
          format: (current, max) => `${current}/${max} rows`
        },
        reels: {
          label: 'Extra Reels',
          description: 'Extends the machine vertically for longer combos.',
          format: (current, max) => `${current}/${max} reels`
        },
        lines: {
          label: 'Line Patterns',
          description: 'Unlocks diagonal and zig-zag paylines.',
          format: (current, max) => `${current}/${max} tiers`
        }
      };
      const getUpgradeSettings = () => {
        const defaults = {
          baseRows: 3,
          maxRows: 5,
          baseReels: 3,
          maxReels: 5,
          costs: { rows: [], reels: [], lines: [] }
        };
        const settings = state.machine.upgradeSettings || state.machine.upgrades || {};
        return {
          baseRows: settings.baseRows ?? defaults.baseRows,
          maxRows: settings.maxRows ?? defaults.maxRows,
          baseReels: settings.baseReels ?? defaults.baseReels,
          maxReels: settings.maxReels ?? defaults.maxReels,
          costs: settings.costs || defaults.costs
        };
      };
      state.playerId = state.auth.token ? null : getStored(storageKeys.player);

      const log = (message, data) => {
        debug('ui-log', { message, data, stateSnapshot: { busy: state.busy, auth: !!state.auth.token } });
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<strong>${time}</strong> ‚Äî ${message}${data ? `<br><span>${data}</span>` : ''}`;
        els.log.prepend(entry);
        const entries = els.log.querySelectorAll('.log-entry');
        if (entries.length > 40) {
          entries[entries.length - 1].remove();
        }
      };

      const setStatus = (text, stateAttr = 'ok') => {
        debug('ui:setStatus', { text, stateAttr });
        if (!els.connectionPill || !els.connectionText) return;
        els.connectionText.textContent = text;
        els.connectionPill.dataset.state = stateAttr;
        els.connectionPill.setAttribute('data-state', stateAttr === 'ok' ? 'ok' : stateAttr);
      };

      const showAlert = (text = '') => {
        els.alert.hidden = !text;
        els.alert.textContent = text;
        if (text) debug('ui:alert', text);
      };

      const showAuthAlert = (text = '') => {
        if (text) debug('auth:alert', text);
        if (!els.authAlert) return;
        els.authAlert.hidden = !text;
        els.authAlert.textContent = text;
        if (text) {
          requestFrame(() => {
            els.authAlert?.scrollIntoView?.({ block: 'nearest', behavior: 'smooth' });
            els.authAlert?.focus?.({ preventScroll: false });
          });
        }
      };

      const gamePanels = Array.from(document.querySelectorAll('[data-requires-auth]'));

      const setGameVisibility = (visible) => {
        debug('ui:setGameVisibility', { visible });
        state.gameReady = visible;
        gamePanels.forEach(panel => {
          panel.hidden = !visible;
        });
        if (!visible) {
          toggleAccountSheet(false);
          toggleDropPanel(false);
        }
        const disableInputs = !visible || state.busy;
        els.spinBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.resetBtn) els.resetBtn.disabled = disableInputs;
        if (els.dropRatesBtn) els.dropRatesBtn.disabled = disableInputs;
        renderUpgrades();
        renderSkillButton();
        renderPayoutSkill();
        renderDaily();
        renderBonusSummary();
        renderAutoSpinButton();
        renderWorkerButton();
        applyPaneMode();
        if (visible) startIdleTicker();
        else stopIdleTicker();
        if (visible) startSkillTicker();
        else stopSkillTicker();
      };

      const setBusy = (flag) => {
        debug('ui:setBusy', { flag, prev: state.busy });
        state.busy = flag;
        const disableInputs = flag || !state.gameReady;
        els.spinBtn.disabled = disableInputs;
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.dropRatesBtn) els.dropRatesBtn.disabled = disableInputs;
        if (els.payoutSkillBtn) els.payoutSkillBtn.disabled = disableInputs;
        if (els.workerBtn) els.workerBtn.disabled = disableInputs;
        if (disableInputs) toggleDropPanel(false);
        renderUpgrades();
        renderSkillButton();
        renderPayoutSkill();
        renderDaily();
        renderBonusSummary();
        renderAutoSpinButton();
        renderWorkerButton();
      };

      const toggleAuthInputs = (disabled) => {
        [els.authEmail, els.authPassword, els.authConfirm, els.authSubmit, els.authInfo].forEach(node => {
          if (node) node.disabled = disabled;
        });
        (els.authTabs || []).forEach(btn => {
          btn.disabled = disabled;
        });
      };

      const toggleAccountSheet = (force) => {
        if (!els.accountPanel) return;
        const shouldShow = typeof force === 'boolean' ? force : els.accountPanel.hidden;
        els.accountPanel.hidden = !shouldShow;
        els.accountPanel.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
        if (shouldShow) {
          els.accountPanel.focus({ preventScroll: false });
        }
      };

      const randomSymbolInfo = () => {
        const weights = state.symbolWeights?.entries || [];
        const total = state.symbolWeights?.total || 0;
        if (total > 0 && weights.length) {
          const target = Math.floor(Math.random() * total);
          const hit = weights.find(entry => entry.total > target);
          if (hit) return getSymbolEntry(hit.key);
        }
        const pool = Array.from(state.symbolMap.values());
        if (!pool.length) return getSymbolEntry('placeholder');
        return pool[Math.floor(Math.random() * pool.length)];
      };

      const describeUpgradeExtra = (key) => {
        const settings = getUpgradeSettings();
        switch (key) {
          case 'rows':
            return `${state.currentRows || settings.baseRows}/${settings.maxRows} rows`;
          case 'reels':
            return `${state.currentReels || settings.baseReels}/${settings.maxReels} reels`;
          case 'lines': {
            const tier = state.currentLineTier ?? 0;
            return `Tier ${tier}`;
          }
          case 'idle':
            return `Idle +${state.upgrades.idle || 0}/sec`;
          case 'speed':
            return `${(state.upgrades.speed || 0) * 10}% faster`;
          case 'retrigger':
            return `${(state.upgrades.retrigger || 0) * 5}% chance`;
          case 'dropBoost':
            return `${(state.upgrades.dropBoost || 0) * 5}% drops`;
          case 'premium': {
            const active = state.machine.activeSymbols?.length || 0;
            return `${active} symbols active`;
          }
          case 'betMultiplier':
            return `Max bet ${currency.format(state.maxBet || DEFAULT_MAX_BET)}`;
          default:
            return '';
        }
      };

      const buildUpgradeCard = (def) => {
        const loggedIn = Boolean(state.auth.token);
        const level = Math.max(0, state.upgrades?.[def.key] || 0);
        const maxLevel = Math.max(0, getUpgradeMaxLevel(def.key));
        const reqs = def.requires ? (Array.isArray(def.requires) ? def.requires : [def.requires]) : [];
        const requirementsMet = reqs.every(req => (state.upgrades?.[req] || 0) > 0);
        const locked = reqs.length > 0 && !requirementsMet;
        const currentLabel = level > 0
          ? (def.levels?.[level - 1] || `Level ${level}`)
          : 'Not unlocked';
        const nextLabel = level >= maxLevel
          ? 'Maxed'
          : (def.levels?.[level] || `Level ${level + 1}`);
        const cost = level >= maxLevel ? null : computeUpgradeCost(def, level);
        const clientOnly = Boolean(def.clientOnly);
        const buttonDisabled = (!loggedIn && !clientOnly) || state.busy || locked || level >= maxLevel || (!Number.isFinite(cost) && !clientOnly);
        const buttonText = locked
          ? 'Locked'
          : level >= maxLevel
            ? 'Maxed'
            : clientOnly
              ? 'Unlock (local)'
              : `Unlock (${currency.format(cost)})`;
        const requirementNote = locked
          ? `Requires ${reqs.map(req => getUpgradeDef(req)?.label || req).join(', ')}`
          : '';
        const extra = describeUpgradeExtra(def.key);
        return `
          <div class="upgrade-card" data-upgrade-key="${def.key}">
            <h4>${def.label}</h4>
            <p>${def.description}</p>
            <div class="upgrade-card__meta">
              <span>Level ${Math.min(level, maxLevel)}/${maxLevel}</span>
              ${extra ? `<span>${extra}</span>` : ''}
            </div>
            <div class="upgrade-card__note">Current: ${currentLabel}</div>
            <div class="upgrade-card__note">Next: ${nextLabel}</div>
            <button type="button" data-upgrade="${def.key}" ${buttonDisabled ? 'data-disabled="true" disabled' : ''}>${buttonText}</button>
            ${requirementNote ? `<div class="upgrade-card__note">${requirementNote}</div>` : ''}
          </div>
        `;
      };

      const renderUpgrades = () => {
        if (!els.upgradeGrid) return;
        const loggedIn = Boolean(state.auth.token);
        if (els.upgradePanel) {
          els.upgradePanel.hidden = !state.gameReady || !loggedIn;
        }
        if (!loggedIn) {
          // allow local upgrades without sign-in
        }
        if (!state.upgradeCatalog.length) {
          els.upgradeGrid.innerHTML = '<p class="muted-text">Loading upgrades‚Ä¶</p>';
          return;
        }
        const grouped = state.upgradeCatalog.reduce((acc, def) => {
          if (!acc[def.category]) acc[def.category] = [];
          acc[def.category].push(def);
          return acc;
        }, {});
        const categoryOrder = ['Economy', 'Spin', 'Layout', 'Symbols', 'Drops', 'Skills'];
        const seen = new Set();
        const sections = [];
        [...categoryOrder, ...Object.keys(grouped)].forEach(category => {
          if (!category || seen.has(category)) return;
          seen.add(category);
          const defs = grouped[category];
          if (!defs || !defs.length) return;
          sections.push(`
            <div class="upgrade-category" data-category="${category}">
              <h3>${category}</h3>
              <div class="upgrade-grid">
                ${defs.map(buildUpgradeCard).join('')}
              </div>
            </div>
          `);
        });
        els.upgradeGrid.innerHTML = sections.join('') || '<p class="muted-text">No upgrades available.</p>';
      };

      const DROP_ITEM_NAMES = {
        goldChip: 'Golden Chip',
        scratchCard: 'Scratch Card',
        circuit: 'Circuit',
        inventorySlotCoupon: 'Inventory Slot Coupon',
        gearSlotCoupon: 'Gear Slot Coupon',
        storageSlotCoupon: 'Storage Slot Coupon',
        deckSlotCoupon: 'Deck Slot Coupon',
        cardSlotCoupon: 'Card Slot Coupon',
        vipMarks: 'VIP Mark',
        reelMod: 'Reel Mod',
        spinBooster: 'Spin Booster',
        card: 'Card',
        gear: 'Gear'
      };
      const DROP_ITEM_ICONS = {
        goldChip: 'img/slot/items/gold_chip.png',
        scratchCard: 'img/slot/items/scratch_card.png',
        circuit: 'img/slot/items/circuit.png',
        inventorySlotCoupon: 'img/slot/items/inventory_slot_coupon.png',
        gearSlotCoupon: 'img/slot/items/gear_slot_coupon.png',
        storageSlotCoupon: 'img/slot/items/storage_slot_coupon.png',
        deckSlotCoupon: 'img/slot/items/deck_slot_coupon.png',
        cardSlotCoupon: 'img/slot/items/card_slot_coupon.png',
        vipMarks: 'img/slot/items/vip_mark.png',
        reelMod: 'img/slot/items/reel_mod_t1.png',
        spinBooster: 'img/slot/items/spinBoosterT1.png',
        card: 'img/slot/items/card.png',
        gear: 'img/slot/items/gear.png'
      };
      const DROP_TIER_ORDER = ['common', 'rare', 'epic'];
      const MAX_DROP_HISTORY = 25;
      const dropPercent = (value = 0) => `${(Math.min(1, Math.max(0, value)) * 100).toFixed(2)}%`;

      const normalizeDrop = (entry = {}) => {
        const type = entry.type || 'item';
        const name = entry.name || DROP_ITEM_NAMES[type] || type;
        const icon = entry.icon || DROP_ITEM_ICONS[type] || getPlaceholderAsset();
        const amount = Number.isFinite(entry.amount) ? entry.amount : 1;
        return {
          type,
          amount,
          name,
          icon,
          rarity: entry.rarity,
          tier: entry.tier
        };
      };

      const dropKey = (drop = {}) => {
        if (drop.type === 'gear') {
          return `gear:${drop.rarity || drop.tier || 'Basic'}`;
        }
        if (drop.type === 'card') {
          return `card:${drop.tier || drop.rarity || 'Basic'}`;
        }
        if (drop.type === 'reelMod' || drop.type === 'spinBooster') {
          return `${drop.type}:${drop.tier || 1}`;
        }
        return drop.type || 'item';
      };

      const inventoryMeta = (key = '') => {
        const [type, variant] = key.split(':');
        switch (type) {
          case 'gear':
            return { name: `${variant || 'Basic'} Gear`, icon: DROP_ITEM_ICONS.gear };
          case 'card':
            return { name: `${variant || 'Card'} Card`, icon: DROP_ITEM_ICONS.card };
          case 'reelMod':
            return { name: `Reel Mod ${variant ? `T${variant}` : ''}`.trim(), icon: DROP_ITEM_ICONS.reelMod };
          case 'spinBooster':
            return { name: `Spin Booster ${variant ? `T${variant}` : ''}`.trim(), icon: DROP_ITEM_ICONS.spinBooster };
          default:
            return { name: DROP_ITEM_NAMES[type] || type || 'Item', icon: DROP_ITEM_ICONS[type] || getPlaceholderAsset() };
        }
      };

      const applyDropState = (dropState = {}) => {
        if (!dropState || typeof dropState !== 'object') return;
        if (dropState.tableKey) state.drop.tableKey = dropState.tableKey;
        if (dropState.table) state.drop.table = dropState.table;
        if (dropState.tierWeights) {
          state.drop.tierWeights = { ...state.drop.tierWeights, ...dropState.tierWeights };
        }
        if (dropState.constants) {
          const c = dropState.constants;
          state.drop.constants = {
            ...state.drop.constants,
            betScale: Number(c.BET_DROP_SCALE ?? c.betScale ?? state.drop.constants.betScale),
            win: Number(c.WIN_DROP_MULT ?? c.win ?? state.drop.constants.win),
            lose: Number(c.LOSE_DROP_MULT ?? c.lose ?? state.drop.constants.lose),
            boostScale: Number(c.DROP_BOOST_SCALE ?? c.boostScale ?? state.drop.constants.boostScale)
          };
        }
        if (dropState.inventory) {
          state.drop.inventory = { ...dropState.inventory };
        }
        if (Array.isArray(dropState.lastDrops) && dropState.lastDrops.length && !state.drop.history.length) {
          recordDrops(dropState.lastDrops, Date.now());
        } else {
          renderDropLog();
        }
        updateSkillSpec();
        renderSkillButton();
        renderInventory();
        renderGear();
        renderCards();
        updateHud();
        renderBonusSummary();
      };

      const recordDrops = (drops = [], timestamp = Date.now()) => {
        if (!Array.isArray(drops) || !drops.length) return;
        const ts = Number.isFinite(timestamp) ? timestamp : Date.now();
        if (ts <= (state.drop.lastTimestamp || 0)) {
          state.drop.lastDrops = drops.map(normalizeDrop);
          return;
        }
        const normalized = drops.map(normalizeDrop);
        state.drop.lastDrops = normalized;
        state.drop.lastTimestamp = ts;
        state.drop.history.unshift({ timestamp: ts, drops: normalized });
        if (state.drop.history.length > MAX_DROP_HISTORY) {
          state.drop.history.length = MAX_DROP_HISTORY;
        }
        renderDropLog();
      };

      const applyDropsToInventory = (drops = [], timestamp = Date.now()) => {
        if (!Array.isArray(drops) || !drops.length) return;
        drops.forEach(drop => {
          const key = dropKey(drop);
          const amount = Number.isFinite(drop.amount) ? drop.amount : 1;
          state.drop.inventory[key] = (state.drop.inventory[key] || 0) + amount;
          if (drop.type === 'vipMarks') {
            state.drop.inventory.vipMarks = state.drop.inventory[key];
          }
          if (drop.type === 'gear') {
            for (let i = 0; i < amount; i += 1) addGear(generateGear(drop.rarity || drop.tier));
          }
          if (drop.type === 'card') {
            for (let i = 0; i < amount; i += 1) addCard(generateCard(drop.rarity || drop.tier));
          }
          if (drop.type === 'gearSlotCoupon') {
            state.equipment.slotCap = Math.min(gearSlotsList().length, (state.equipment.slotCap || 0) + amount);
          }
          if (drop.type === 'deckSlotCoupon' || drop.type === 'cardSlotCoupon') {
            state.cards.slots = Math.min(5, (state.cards.slots || 0) + amount);
          }
        });
        recordDrops(drops, timestamp);
        renderInventory();
        renderGear();
        renderCards();
        renderBonusSummary();
        updateHud();
        saveLocalEquipment();
        saveLocalCards();
        markDirty('drop');
      };

      const consumeSpinModifiers = () => {
        const inventory = state.drop.inventory || {};
        let extraReels = 0;
        let payoutMult = 1;
        const consumed = [];
        const reelKey = Object.keys(inventory).find(key => key.startsWith('reelMod') && inventory[key] > 0);
        if (reelKey) {
          inventory[reelKey] -= 1;
          if (inventory[reelKey] <= 0) delete inventory[reelKey];
          extraReels = 1;
          consumed.push('Reel Mod');
        }
        const boosterKey = Object.keys(inventory).find(key => key.startsWith('spinBooster') && inventory[key] > 0);
        if (boosterKey) {
          inventory[boosterKey] -= 1;
          if (inventory[boosterKey] <= 0) delete inventory[boosterKey];
          payoutMult = 2;
          consumed.push('Spin Booster');
        }
        if (consumed.length) {
          renderInventory();
          renderBonusSummary();
          markDirty('drop');
          log('Modifiers applied', consumed.join(' ‚Ä¢ '));
        }
        return { extraReels, payoutMult };
      };

      const renderInventory = () => {
        if (!els.inventoryGrid) return;
        const entries = Object.entries(state.drop.inventory || {}).filter(([, count]) => Number(count) > 0);
        if (!entries.length) {
          els.inventoryGrid.innerHTML = '<span class="muted-text">No drops yet.</span>';
          return;
        }
        entries.sort((a, b) => b[1] - a[1]);
        const chips = entries.slice(0, 6).map(([key, count]) => {
          const meta = inventoryMeta(key);
          return `
            <span class="inventory-chip" data-key="${key}">
              <img src="${meta.icon}" alt="${meta.name}">
              <span>${meta.name}</span>
              <strong class="drop-amount">√ó${count}</strong>
            </span>
          `;
        });
        els.inventoryGrid.innerHTML = chips.join('');
      };

      const renderDropLog = () => {
        if (!els.dropLog) return;
        const history = state.drop.history || [];
        if (!history.length) {
          els.dropLog.textContent = 'Spin to collect items.';
          return;
        }
        const rows = history.slice(0, 8).map(entry => {
          const time = new Date(entry.timestamp).toLocaleTimeString();
          const parts = entry.drops.map(drop => {
            const info = normalizeDrop(drop);
            return `<span class="rate-item"><img class="drop-icon" src="${info.icon}" alt="${info.name}">${info.name} √ó${info.amount}</span>`;
          }).join(', ');
          return `<div class="drop-entry"><strong>${time}</strong><span aria-hidden="true">‚Äî</span><span>${parts}</span></div>`;
        });
        els.dropLog.innerHTML = rows.join('');
      };

      const getDropTable = () => state.drop.table || { common: [], rare: [], epic: [] };
      const getTierWeights = () => state.drop.tierWeights || { common: 0.8, rare: 0.15, epic: 0.05 };

      const isDropSkillActive = () => {
        const skill = state.skills.dropRate;
        if (!skill) return false;
        const now = Date.now();
        if (skill.active && skill.expiresAt && now >= skill.expiresAt) {
          skill.active = false;
        }
        if (!skill.active && skill.expiresAt && now >= skill.expiresAt) {
          skill.expiresAt = 0;
        }
        if (skill.cooldownUntil && now >= skill.cooldownUntil) {
          skill.cooldownUntil = 0;
        }
        return skill.active;
      };

      const computeDropMultiplier = ({ bet = 1, payout = 0 } = {}) => {
        const constants = state.drop.constants || {};
        const betScale = Number(constants.betScale) || 0.1;
        const boostScale = Number(constants.boostScale) || 0.05;
        const winMult = Number(constants.win) || 2;
        const loseMult = Number(constants.lose) || 1;
        const dropBoost = Math.max(0, state.upgrades.dropBoost || 0);
        const base = 1 + boostScale * dropBoost;
        const safeBet = Math.max(0, bet);
        const betMult = 1 + betScale * Math.log(1 + safeBet);
        const skillMult = isDropSkillActive() ? (state.skills.dropRate?.spec?.multiplier || 1) : 1;
        const outcome = payout > 0 ? winMult : loseMult;
        const equip = computeEquipmentStats();
        const equipMult = 1 + Math.max(0, equip.dropPct || 0) / 100;
        return {
          total: base * betMult * skillMult * outcome * equipMult,
          components: { base, bet: betMult, skill: skillMult, outcome, equip: equipMult }
        };
      };

      const getDropMultiplier = (win = false) => computeDropMultiplier({
        bet: state.bet || 1,
        payout: win ? 1 : 0
      });

      const computeDropRates = (mult = 1) => {
        const table = getDropTable();
        const tiers = DROP_TIER_ORDER.filter(tier => Array.isArray(table[tier]) && table[tier].length);
        const weights = tiers.map(tier => getTierWeights()[tier] || 0);
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0) || 1;
        const rates = [];
        tiers.forEach((tier, idx) => {
          const tierProb = (weights[idx] || 0) / totalWeight;
          (table[tier] || []).forEach(entry => {
            const baseChance = Math.max(0, Number(entry.chance) || 0);
            const chance = Math.min(1, baseChance * mult) * tierProb;
            const drop = normalizeDrop(entry);
            rates.push({ ...drop, chance, tier });
          });
        });
        return rates.sort((a, b) => b.chance - a.chance);
      };

      const rollDropsForSpin = (bet = 1, payout = 0) => {
        const table = getDropTable();
        const tiers = DROP_TIER_ORDER.filter(tier => Array.isArray(table[tier]) && table[tier].length);
        if (!tiers.length) return { drops: [], multiplier: computeDropMultiplier({ bet, payout }) };
        const weights = tiers.map(tier => getTierWeights()[tier] || 0);
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0) || 1;
        const mult = computeDropMultiplier({ bet, payout });
        const drops = [];
        tiers.forEach((tier, idx) => {
          const tierProb = (weights[idx] || 0) / totalWeight;
          (table[tier] || []).forEach(entry => {
            const baseChance = Math.max(0, Number(entry.chance) || 0);
            const chance = Math.min(1, baseChance * mult.total) * tierProb;
            if (chance > 0 && Math.random() < chance) {
              drops.push(normalizeDrop(entry));
            }
          });
        });
        return { drops, multiplier: mult };
      };

      const renderDropPanel = () => {
        if (!els.dropPanel) return;
        const lossMult = getDropMultiplier(false);
        const winMult = getDropMultiplier(true);
        const rates = computeDropRates(winMult.total);
        if (!rates.length) {
          els.dropPanel.innerHTML = '<p class="muted-text">Drop table not loaded yet.</p>';
          return;
        }
        const groups = DROP_TIER_ORDER.map(tier => ({
          tier,
          list: rates.filter(rate => rate.tier === tier)
        })).filter(group => group.list.length);
        const listHtml = groups.map(group => `
          <p class="drop-tier-label">${group.tier}</p>
          <ul>
            ${group.list.map(rate => `
              <li>
                <span class="rate-item"><img class="drop-icon" src="${rate.icon}" alt="${rate.name}">${rate.name}</span>
                <span class="drop-amount">${dropPercent(rate.chance)}</span>
              </li>
            `).join('')}
          </ul>
        `).join('');
        els.dropPanel.innerHTML = `
          <h4>Drop rates</h4>
          <p class="drop-mult">Win: ${winMult.total.toFixed(2)}√ó ‚Ä¢ Loss: ${lossMult.total.toFixed(2)}√ó</p>
          ${listHtml || '<p class="muted-text">No drops configured.</p>'}
        `;
      };

      const randomChoice = (arr = []) => {
        if (!Array.isArray(arr) || !arr.length) return null;
        return arr[Math.floor(Math.random() * arr.length)];
      };
      const rollRange = (value) => {
        if (Array.isArray(value) && value.length >= 2) {
          const [min, max] = value;
          const span = Math.max(0, (max ?? min) - (min ?? 0));
          return Math.round((min ?? 0) + Math.random() * span);
        }
        return Number.isFinite(value) ? value : 0;
      };

      const loadGearDefinitions = async () => {
        if (gearDefinitions) return gearDefinitions;
        try {
          const res = await fetch(GEAR_DEFS_URL, { cache: 'no-cache' });
          if (res.ok) {
            gearDefinitions = await res.json();
          }
        } catch (error) {
          debugError('gear-defs', error);
        }
        if (!gearDefinitions) {
          gearDefinitions = { slots: ['Head', 'Outfit', 'Accessory', 'Pet', 'Trinket'], rarities: [], names: {}, bonuses: {} };
        }
        return gearDefinitions;
      };

      const loadCardDefinitions = async () => {
        if (cardDefinitions) return cardDefinitions;
        try {
          const res = await fetch(CARD_DEFS_URL, { cache: 'no-cache' });
          if (res.ok) {
            cardDefinitions = await res.json();
          }
        } catch (error) {
          debugError('card-defs', error);
        }
        if (!cardDefinitions) {
          cardDefinitions = { definitions: [], effects: {} };
        }
        return cardDefinitions;
      };

      const loadLocalEquipment = () => {
        try {
          const raw = localStorage.getItem(LOCAL_EQUIPMENT_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch {
          return null;
        }
      };
      const saveLocalEquipment = () => {
        try {
          localStorage.setItem(LOCAL_EQUIPMENT_KEY, JSON.stringify(state.equipment));
        } catch {
          // ignore
        }
      };
      const defaultEquipmentState = () => ({
        slots: { Head: null, Outfit: null, Accessory: null, Pet: null, Trinket: null },
        inventory: [],
        slotCap: 3
      });
      const loadLocalCards = () => {
        try {
          const raw = localStorage.getItem(LOCAL_CARD_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch {
          return null;
        }
      };
      const saveLocalCards = () => {
        try {
          localStorage.setItem(LOCAL_CARD_KEY, JSON.stringify(state.cards));
        } catch {
          // ignore
        }
      };
      const defaultCardState = () => ({
        deck: [],
        collection: [],
        slots: 3
      });
      const resetLocalProgress = () => {
        clearLocalUpgradeState();
        state.pendingUpgrades = {};
        state.serverUpgrades = {};
        state.upgrades = {};
        state.pendingIdleCoins = 0;
        resetAutoState();
        state.drop.inventory = {};
        state.drop.history = [];
        state.drop.lastDrops = [];
        state.drop.lastTimestamp = 0;
        state.equipment = defaultEquipmentState();
        state.cards = defaultCardState();
        saveLocalEquipment();
        saveLocalCards();
        renderDropLog();
        renderInventory();
        renderGear();
        renderCards();
        renderBonusSummary();
        applyUpgradeState({});
        setBetValue(1);
      };

      const markDirty = (reason = 'change') => {
        state.sync.dirty = true;
        state.sync.queue.push({ reason, at: Date.now() });
        scheduleSync();
      };

      const buildSnapshot = () => ({
        v: 1,
        rev: state.sync.rev || 0,
        updatedAt: Date.now(),
        playerId: state.playerId,
        balance: state.balance,
        bet: state.bet,
        maxBet: state.maxBet,
        spinCount: state.spinCount,
        lastWin: state.lastWin,
        energy: state.energy,
        machines: state.machines,
        worker: { active: state.worker.active, intervalMs: state.worker.intervalMs },
        skills: { payout: state.skills.payout, dropRate: state.skills.dropRate },
        machine: {
          id: state.machine.id,
          rows: state.currentRows || state.machine.rows,
          reels: state.currentReels || state.machine.reels,
          lineTier: state.currentLineTier || 0,
          upgrades: { ...state.upgrades },
          spinTiming: state.machine.spinTiming
        },
        drop: {
          inventory: state.drop.inventory || {},
          history: state.drop.history || [],
          lastDrops: state.drop.lastDrops || [],
          lastTimestamp: state.drop.lastTimestamp || 0
        },
        equipment: state.equipment,
        cards: state.cards,
        daily: state.daily,
        idle: {
          pending: state.pendingIdleCoins || 0,
          lastTick: state.lastIdleTick || 0
        },
        upgrades: state.serverUpgrades,
        clientUpgrades: { ...localUpgrades },
        symbolMap: Array.from(state.symbolMap.entries() || [])
      });

      const applySnapshot = async (snapshot = {}, source = 'sync') => {
        if (!snapshot || typeof snapshot !== 'object') return;
        if (typeof snapshot.rev === 'number') state.sync.rev = Math.max(state.sync.rev || 0, snapshot.rev);
        if (typeof snapshot.balance === 'number') {
          state.balance = snapshot.balance;
          if (els.balance) els.balance.textContent = currency.format(state.balance);
        }
        if (Number.isFinite(snapshot.bet)) setBetValue(snapshot.bet);
        if (snapshot.maxBet) {
          state.maxBet = resolveMaxBet(snapshot.maxBet);
          els.maxBet.textContent = state.maxBet;
          syncBetSteps();
        }
        if (typeof snapshot.spinCount === 'number' && els.spinCount) els.spinCount.textContent = snapshot.spinCount;
        if (snapshot.daily) applyDailyState(snapshot.daily, snapshot.reward);
        if (snapshot.drop) applyDropState(snapshot.drop);
        if (snapshot.machines) {
          state.machines = { ...state.machines, ...snapshot.machines };
        }
        if (snapshot.equipment) {
          state.equipment = snapshot.equipment;
          saveLocalEquipment();
          renderGear();
        }
        if (snapshot.cards) {
          state.cards = snapshot.cards;
          saveLocalCards();
          renderCards();
        }
        if (snapshot.clientUpgrades) {
          Object.assign(localUpgrades, snapshot.clientUpgrades);
          saveLocalUpgrades(localUpgrades);
        }
        if (snapshot.upgrades) {
          ensureMachineProgress(state.machine.id).upgrades = { ...snapshot.upgrades };
        }
        if (snapshot.machine?.upgrades) {
          ensureMachineProgress(snapshot.machine.id || state.machine.id).upgrades = { ...snapshot.machine.upgrades };
        }
        if (snapshot.machine?.id) {
          await setActiveMachine(snapshot.machine.id, { silent: true });
        }
        if (snapshot.machine?.rows) state.currentRows = snapshot.machine.rows;
        if (snapshot.machine?.reels) state.currentReels = snapshot.machine.reels;
        if (snapshot.machine?.lineTier !== undefined) state.currentLineTier = snapshot.machine.lineTier;
        if (snapshot.machine?.spinTiming) state.machine.spinTiming = { ...snapshot.machine.spinTiming };
        if (Array.isArray(snapshot.symbolMap)) {
          state.symbolMap = new Map(snapshot.symbolMap);
          auditSymbolAssets();
          renderPaytable();
        }
        if (snapshot.energy) state.energy = { ...state.energy, ...snapshot.energy };
        if (snapshot.worker) state.worker = { ...state.worker, ...snapshot.worker };
        if (snapshot.skills?.payout) state.skills.payout = { ...state.skills.payout, ...snapshot.skills.payout };
        if (snapshot.idle) {
          state.pendingIdleCoins = snapshot.idle.pending || 0;
          state.lastIdleTick = snapshot.idle.lastTick || 0;
        }
        applyUpgradeState(getMachineUpgrades(state.machine.id));
        renderBonusSummary();
        updateHud();
        if (source === 'sync') {
          state.sync.dirty = false;
          state.sync.queue = [];
        }
      };

      const stopSessionSync = () => {
        if (sessionSyncTimer) {
          clearInterval(sessionSyncTimer);
          sessionSyncTimer = null;
        }
        if (state.sync.debounceTimer) {
          clearTimeout(state.sync.debounceTimer);
          state.sync.debounceTimer = null;
        }
        state.sync.inFlight = false;
      };

      const syncSnapshot = async (force = false) => {
        if (!state.auth.token) return;
        if (!force && !state.sync.dirty) return;
        if (state.sync.inFlight) return;
        state.sync.inFlight = true;
        const snapshot = buildSnapshot();
        const payloadBytes = textEncoder.encode(JSON.stringify(snapshot));
        let signature = null;
        try {
          const sig = await hmacSign(state.auth.token, payloadBytes, 'sync');
          signature = { salt: base64UrlEncode(sig.salt), value: base64UrlEncode(sig.sig) };
        } catch (error) {
          debugError('sync:hmac', error);
        }
        try {
          const res = await request(SYNC_ENDPOINT, { snapshot, signature });
          if (res?.snapshot) {
            await applySnapshot(res.snapshot, 'sync');
          } else if (typeof res?.rev === 'number') {
            state.sync.rev = Math.max(state.sync.rev || 0, res.rev);
            state.sync.dirty = false;
            state.sync.queue = [];
          }
          state.sync.lastPush = Date.now();
        } catch (error) {
          log('Sync failed', error.message || 'Sync error');
          debugError('sync', error);
        } finally {
          state.sync.inFlight = false;
        }
      };

      const scheduleSync = () => {
        if (state.sync.debounceTimer) {
          clearTimeout(state.sync.debounceTimer);
        }
        state.sync.debounceTimer = setTimeout(() => {
          syncSnapshot(false);
        }, SYNC_DEBOUNCE_MS);
      };

      const startSessionSync = () => {
        stopSessionSync();
        if (!state.auth.token) return;
        sessionSyncTimer = setInterval(() => {
          syncSnapshot(true);
        }, SESSION_SYNC_MS);
      };

      const exportStateKey = async () => {
        if (!state.auth.token) {
          showAuthAlert('Sign in to export your state.');
          return;
        }
        if (state.busy) return;
        const snapshot = buildSnapshot();
        const payload = textEncoder.encode(JSON.stringify(snapshot));
        try {
          const blob = await encryptBlob(state.auth.token, payload);
          const bundle = {
            v: EXPORT_VERSION,
            s: base64UrlEncode(blob.salt),
            i: base64UrlEncode(blob.iv),
            c: base64UrlEncode(blob.cipher)
          };
          const signBytes = textEncoder.encode(JSON.stringify({ v: bundle.v, s: bundle.s, i: bundle.i, c: bundle.c }));
          const sig = await hmacSign(state.auth.token, signBytes, 'export');
          bundle.h = { s: base64UrlEncode(sig.salt), v: base64UrlEncode(sig.sig) };
          const encoded = base64UrlEncode(textEncoder.encode(JSON.stringify(bundle)));
          if (els.importStateInput) els.importStateInput.value = encoded;
          if (els.transferStatus) {
            els.transferStatus.textContent = 'Exported encrypted key.';
          }
          try {
            await navigator.clipboard?.writeText?.(encoded);
          } catch {
            // clipboard may be unavailable; ignore
          }
          log('State exported', `rev ${state.sync.rev || 0}`);
        } catch (error) {
          if (els.transferStatus) {
            els.transferStatus.textContent = 'Export failed.';
          }
          debugError('export', error);
        }
      };

      const importStateKey = async () => {
        if (!state.auth.token) {
          showAuthAlert('Sign in to import a state key.');
          return;
        }
        const raw = (els.importStateInput?.value || '').trim();
        if (!raw) {
          if (els.transferStatus) els.transferStatus.textContent = 'Paste a key to import.';
          return;
        }
        try {
          const decoded = base64UrlDecode(raw);
          const parsed = safeJsonParse(textDecoder.decode(decoded));
          if (!parsed || parsed.v !== EXPORT_VERSION) throw new Error('Invalid key format.');
          const blob = {
            salt: base64UrlDecode(parsed.s || ''),
            iv: base64UrlDecode(parsed.i || ''),
            cipher: base64UrlDecode(parsed.c || '')
          };
          const forSign = { v: parsed.v, s: parsed.s, i: parsed.i, c: parsed.c };
          const valid = await hmacVerify(
            state.auth.token,
            textEncoder.encode(JSON.stringify(forSign)),
            { salt: parsed.h?.s || parsed.h?.salt, value: parsed.h?.v || parsed.h?.value },
            'export'
          );
          if (!valid) throw new Error('Export key signature invalid.');
          const plain = await decryptBlob(state.auth.token, blob);
          const snapshot = safeJsonParse(textDecoder.decode(plain));
          if (!snapshot) throw new Error('Invalid snapshot.');
          await applySnapshot(snapshot, 'import');
          markDirty('import');
          if (els.transferStatus) {
            els.transferStatus.textContent = 'Import applied. Syncing‚Ä¶';
          }
          syncSnapshot(true);
        } catch (error) {
          if (els.transferStatus) {
            els.transferStatus.textContent = error.message || 'Import failed.';
          }
          debugError('import', error);
        }
      };

      const hydrateLocalCollections = () => {
        const savedGear = loadLocalEquipment();
        if (savedGear) {
          state.equipment = {
            ...state.equipment,
            ...savedGear,
            slots: { ...state.equipment.slots, ...(savedGear.slots || {}) }
          };
        }
        const savedCards = loadLocalCards();
        if (savedCards) {
          state.cards = {
            ...state.cards,
            ...savedCards,
            deck: Array.isArray(savedCards.deck) ? savedCards.deck : [],
            collection: Array.isArray(savedCards.collection) ? savedCards.collection : []
          };
        }
      };

      const gearSlotsList = () => Object.keys(state.equipment.slots || { Head: null, Outfit: null, Accessory: null, Pet: null, Trinket: null });
      const unlockedGearSlots = () => Math.min(state.equipment.slotCap || gearSlotsList().length, gearSlotsList().length);
      const gearIconFor = (rarity = 'basic', slot = 'accessory') => `img/slot/gear/${rarity.toLowerCase()}/gear_${rarity.toLowerCase()}_${slot.toLowerCase()}.png`;

      const generateGear = (rarityHint = null) => {
        const defs = gearDefinitions || {};
        const rarities = defs.rarities || [];
        const rarity = rarityHint
          || (rarities.length
            ? (() => {
              const total = rarities.reduce((sum, r) => sum + (r.dropChance || 0), 0) || 1;
              let roll = Math.random() * total;
              for (const r of rarities) {
                roll -= r.dropChance || 0;
                if (roll <= 0) return r.name;
              }
              return rarities[0].name;
            })()
            : 'Basic');
        const slot = randomChoice(defs.slots || gearSlotsList()) || 'Accessory';
        const bonusPool = defs.bonuses?.[rarity]?.bonuses || [];
        const bonus = randomChoice(bonusPool) || { desc: '+0% drops', dropPct: [1, 2] };
        const effects = {
          coinFlat: rollRange(bonus.coinFlat),
          coinPct: rollRange(bonus.coinPct),
          dropPct: rollRange(bonus.dropPct),
          idlePct: rollRange(bonus.idlePct),
          gearDropPct: rollRange(bonus.gearDropPct) || 0,
          tierChance: bonus.tierChance || null,
          unique: bonus.unique || null
        };
        const desc = (bonus.desc || '').replace('{coinFlat}', effects.coinFlat || 0).replace('{coinPct}', effects.coinPct || 0).replace('{dropPct}', effects.dropPct || 0).replace('{idlePct}', effects.idlePct || 0).replace('{gearDropPct}', effects.gearDropPct || 0);
        const name = defs.names?.[rarity]?.[slot]?.name || `${rarity} ${slot}`;
        return {
          id: `gear-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
          rarity,
          slot,
          name,
          level: 1,
          desc,
          effects,
          icon: gearIconFor(rarity, slot)
        };
      };

      const addGear = (gear) => {
        if (!gear) return;
        if (!Array.isArray(state.equipment.inventory)) state.equipment.inventory = [];
        state.equipment.inventory.push(gear);
        saveLocalEquipment();
      };

      const equipGear = (gearId, targetSlot = null) => {
        const gear = (state.equipment.inventory || []).find(item => item.id === gearId);
        if (!gear) return;
        const slot = targetSlot || gear.slot || gearSlotsList()[0];
        const slotIndex = gearSlotsList().indexOf(slot);
        if (slotIndex >= unlockedGearSlots()) {
          showAlert('Unlock more equipment slots first.');
          return;
        }
        state.equipment.slots[slot] = gear;
        state.equipment.inventory = state.equipment.inventory.filter(item => item.id !== gearId);
        saveLocalEquipment();
        renderGear();
        renderBonusSummary();
        markDirty('gear-equip');
      };

      const unequipGear = (slot) => {
        const current = state.equipment.slots?.[slot];
        if (!current) return;
        state.equipment.slots[slot] = null;
        state.equipment.inventory.push(current);
        saveLocalEquipment();
        renderGear();
        renderBonusSummary();
        markDirty('gear-unequip');
      };

      const upgradeGear = (gearId) => {
        const vip = Number(state.drop.inventory?.vipMarks || 0);
        const allGear = [...(state.equipment.inventory || []), ...Object.values(state.equipment.slots || {})].filter(Boolean);
        const gear = allGear.find(item => item.id === gearId);
        if (!gear) return;
        const cost = Math.max(1, gear.level || 1);
        if (vip < cost) {
          showAlert('Not enough VIP marks to upgrade gear.');
          return;
        }
        state.drop.inventory.vipMarks = vip - cost;
        gear.level = (gear.level || 1) + 1;
        saveLocalEquipment();
        renderGear();
        renderInventory();
        renderBonusSummary();
        updateHud();
        markDirty('gear-upgrade');
      };

      const generateCard = (tierHint = null) => {
        const defs = cardDefinitions?.definitions || [];
        const filtered = defs.filter(c => !tierHint || c.tier === tierHint);
        const pick = randomChoice(filtered.length ? filtered : defs) || { name: 'Wildcard', tier: tierHint || 'Basic', icon: DROP_ITEM_ICONS.card, desc: 'Generic card from offline pool.' };
        const level = 1;
        const effectText = (cardDefinitions?.effects?.[pick.name] || [])[level - 1] || '';
        return {
          id: `card-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
          name: pick.name,
          tier: pick.tier || 'Basic',
          icon: pick.icon || DROP_ITEM_ICONS.card,
          desc: pick.desc || '',
          level,
          effect: effectText
        };
      };

      const addCard = (card) => {
        if (!card) return;
        if (!Array.isArray(state.cards.collection)) state.cards.collection = [];
        state.cards.collection.push(card);
        saveLocalCards();
      };

      const equipCard = (cardId, slotIndex = 0) => {
        const card = (state.cards.collection || []).find(c => c.id === cardId);
        if (!card) return;
        const maxSlots = Math.max(1, state.cards.slots || 1);
        if (slotIndex >= maxSlots) {
          showAlert('Unlock more card slots first.');
          return;
        }
        state.cards.deck = state.cards.deck || [];
        state.cards.deck[slotIndex] = cardId;
        saveLocalCards();
        renderCards();
        renderBonusSummary();
        markDirty('card-equip');
      };

      const unequipCard = (slotIndex = 0) => {
        if (!Array.isArray(state.cards.deck)) return;
        state.cards.deck[slotIndex] = null;
        saveLocalCards();
        renderCards();
        renderBonusSummary();
        markDirty('card-unequip');
      };

      const upgradeCard = (cardId) => {
        const vip = Number(state.drop.inventory?.vipMarks || 0);
        const card = (state.cards.collection || []).find(c => c.id === cardId);
        if (!card) return;
        const cost = Math.max(1, card.level || 1);
        if (vip < cost) {
          showAlert('Not enough VIP marks to upgrade this card.');
          return;
        }
        state.drop.inventory.vipMarks = vip - cost;
        card.level = (card.level || 1) + 1;
        const effectList = cardDefinitions?.effects?.[card.name] || [];
        card.effect = effectList[card.level - 1] || card.effect;
        saveLocalCards();
        renderCards();
        renderInventory();
        renderBonusSummary();
        updateHud();
        markDirty('card-upgrade');
      };

      const parseEffectText = (text = '') => {
        const stats = {};
        const pctMatch = text.match(/([+\\-]?\\d+(?:\\.\\d+)?)%/);
        const pct = pctMatch ? parseFloat(pctMatch[1]) : 0;
        if (/coin/i.test(text)) stats.coinPct = pct;
        if (/drop/i.test(text)) stats.dropPct = pct;
        if (/idle|delay/i.test(text)) stats.idlePct = pct;
        if (/speed|faster|spin/i.test(text)) stats.speedPct = pct;
        return stats;
      };

      const computeEquipmentStats = () => {
        const totals = { coinPct: 0, dropPct: 0, idlePct: 0 };
        Object.values(state.equipment.slots || {}).forEach(item => {
          if (!item) return;
          const level = Math.max(1, item.level || 1);
          const fx = item.effects || {};
          if (fx.coinPct) totals.coinPct += fx.coinPct * level;
          if (fx.dropPct) totals.dropPct += fx.dropPct * level;
          if (fx.idlePct) totals.idlePct += fx.idlePct * level;
        });
        if (Array.isArray(state.cards.deck)) {
          state.cards.deck.forEach(id => {
            const card = (state.cards.collection || []).find(c => c.id === id);
            if (!card) return;
            const stats = parseEffectText(card.effect || '');
            if (stats.coinPct) totals.coinPct += stats.coinPct;
            if (stats.dropPct) totals.dropPct += stats.dropPct;
            if (stats.idlePct) totals.idlePct += stats.idlePct;
          });
        }
        return totals;
      };

      const renderGear = () => {
        if (!els.gearSlots || !els.gearInventory) return;
        if (!state.equipment) return;
        const slots = gearSlotsList();
        const unlocked = unlockedGearSlots();
        const slotHtml = slots.map((slot, idx) => {
          const item = state.equipment.slots?.[slot];
          const locked = idx >= unlocked;
          const bonus = item ? `<p class=\"gear-slot__bonus\">${item.desc || ''}</p>` : '<p class=\"gear-slot__bonus\">Choose an item below to equip.</p>';
          const actions = locked
            ? '<span class=\"muted-text\">Locked slot</span>'
            : item
              ? `<div class=\"actions\"><button type=\"button\" class=\"ghost-btn secondary\" data-unequip-slot=\"${slot}\">Unequip</button><button type=\"button\" class=\"ghost-btn tertiary\" data-upgrade-gear=\"${item.id}\">Upgrade (VIP)</button></div>`
              : '<span class=\"muted-text\">Empty</span>';
          return `
            <div class="gear-slot ${locked ? 'locked' : ''}" data-slot="${slot}">
              <div class="gear-slot__meta">
                <strong class="gear-slot__name">${slot}</strong>
                ${item ? `<span class="rarity-tag">${item.rarity} ‚Ä¢ Lv ${item.level || 1}</span>` : ''}
              </div>
              ${bonus}
              ${actions}
            </div>
          `;
        }).join('');
        els.gearSlots.innerHTML = slotHtml;
        const equippedIds = new Set(Object.values(state.equipment.slots || {}).filter(Boolean).map(item => item.id));
        const inventory = (state.equipment.inventory || []).filter(item => item && !equippedIds.has(item.id));
        if (!inventory.length) {
          els.gearInventory.innerHTML = '<p class="muted-text">No spare gear. Spin to find equipment drops.</p>';
        } else {
          els.gearInventory.innerHTML = inventory.map(item => `
            <div class="gear-item" data-gear-id="${item.id}">
              <div class="gear-slot__meta">
                <span class="rarity-tag">${item.rarity}</span>
                <span class="hud-label">Lv ${item.level || 1}</span>
              </div>
              <p class="gear-slot__name">${item.name}</p>
              <p class="gear-slot__bonus">${item.desc || ''}</p>
              <div class="actions">
                <button type="button" class="ghost-btn secondary" data-equip-id="${item.id}">Equip</button>
                <button type="button" class="ghost-btn tertiary" data-upgrade-gear="${item.id}">Upgrade (VIP)</button>
              </div>
            </div>
          `).join('');
        }
        if (els.gearSummary) {
          const equipped = Object.values(state.equipment.slots || {}).filter(Boolean).length;
          els.gearSummary.textContent = `${equipped}/${unlocked} equipped`;
        }
        if (els.gearCap) {
          els.gearCap.textContent = `${unlocked} slots`;
        }
      };

      const renderCards = () => {
        if (!els.cardSlots || !els.cardCollection) return;
        const maxSlots = Math.max(1, state.cards.slots || 1);
        const deck = Array.isArray(state.cards.deck) ? state.cards.deck : [];
        const cards = Array.isArray(state.cards.collection) ? state.cards.collection : [];
        const slotHtml = Array.from({ length: maxSlots }).map((_, idx) => {
          const cardId = deck[idx];
          const card = cards.find(c => c && c.id === cardId);
          const body = card
            ? `<p class="gear-slot__name">${card.name}</p><p class="card-slot__effect">${card.effect || card.desc || ''}</p><div class="actions"><button type="button" class="ghost-btn secondary" data-unequip-card="${idx}">Remove</button><button type="button" class="ghost-btn tertiary" data-upgrade-card="${card.id}">Upgrade (VIP)</button></div>`
            : '<p class="gear-slot__bonus">Choose a card from your collection.</p>';
          return `
            <div class="card-slot" data-card-slot="${idx}">
              <div class="card-slot__meta">
                <strong class="card-slot__name">Slot ${idx + 1}</strong>
                ${card ? `<span class="rarity-tag">${card.tier} ‚Ä¢ Lv ${card.level || 1}</span>` : ''}
              </div>
              ${body}
            </div>
          `;
        }).join('');
        const lockedSlots = Array.from({ length: Math.max(0, 5 - maxSlots) }).map((_, idx) => `<div class="card-slot locked"><p class="muted-text">Locked slot ${maxSlots + idx + 1}</p></div>`).join('');
        els.cardSlots.innerHTML = slotHtml + lockedSlots;
        if (!cards.length) {
          els.cardCollection.innerHTML = '<p class="muted-text">No cards yet. Spin to collect VIP cards.</p>';
        } else {
          const equippedSet = new Set(deck.filter(Boolean));
          els.cardCollection.innerHTML = cards.map(card => `
            <div class="card-item" data-card-id="${card.id}">
              <div class="card-slot__meta">
                <span class="rarity-tag">${card.tier}</span>
                <span class="hud-label">Lv ${card.level || 1}</span>
              </div>
              <div class="card-slot__meta">
                <img src="${card.icon || DROP_ITEM_ICONS.card}" alt="${card.name}">
                <p class="gear-slot__name">${card.name}</p>
              </div>
              <p class="card-slot__effect">${card.effect || card.desc || ''}</p>
              <div class="actions">
                <button type="button" class="ghost-btn secondary" data-equip-card="${card.id}" ${equippedSet.has(card.id) ? 'disabled' : ''}>Add to deck</button>
                <button type="button" class="ghost-btn tertiary" data-upgrade-card="${card.id}">Upgrade (VIP)</button>
              </div>
            </div>
          `).join('');
        }
        if (els.cardSummary) {
          const active = deck.filter(Boolean).length;
          els.cardSummary.textContent = `Deck ${active}/${maxSlots}`;
        }
        if (els.cardCap) {
          els.cardCap.textContent = `${maxSlots} slots`;
        }
      };

      const toggleDropPanel = (force) => {
        if (!els.dropPanel) return;
        const willShow = typeof force === 'boolean' ? force : els.dropPanel.hidden;
        if (willShow) renderDropPanel();
        els.dropPanel.hidden = !willShow;
        if (!willShow) {
          els.dropRatesBtn?.focus?.();
        }
      };

      const renderSkillButton = () => {
        if (!els.dropSkillBtn) return;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        const skill = state.skills.dropRate;
        els.dropSkillBtn.hidden = !unlocked;
        if (!unlocked) return;
        const now = Date.now();
        const busy = state.busy || !state.gameReady;
        let label = 'Drop boost';
        if (skill.active && skill.expiresAt > now) {
          label = `Drop boost active (${formatTime(skill.expiresAt - now)})`;
          els.dropSkillBtn.dataset.state = 'active';
          els.dropSkillBtn.disabled = busy;
        } else if (skill.cooldownUntil && skill.cooldownUntil > now) {
          label = `Cooldown ${formatTime(skill.cooldownUntil - now)}`;
          els.dropSkillBtn.dataset.state = 'cooldown';
          els.dropSkillBtn.disabled = true;
        } else {
          els.dropSkillBtn.dataset.state = 'ready';
          els.dropSkillBtn.disabled = busy;
          const boost = Math.round(((state.skills.dropRate?.spec?.multiplier || 1) - 1) * 100);
          if (boost > 0) label = `Drop boost +${boost}%`;
        }
        els.dropSkillBtn.textContent = label;
      };

      const updateSkillSpec = () => {
        const effect = Math.max(0, state.upgrades.dropRateEffect || 0);
        const duration = Math.max(0, state.upgrades.dropRateDuration || 0);
        const baseBoost = state.drop.constants?.boostScale || 0.05;
        const durationMs = 60000 * (1 + duration);
        const cooldownMs = durationMs * 2;
        const multiplier = 1 + baseBoost * (1 + effect);
        state.skills.dropRate.spec = { durationMs, cooldownMs, multiplier };
        renderSkillButton();
      };

      const renderPayoutSkill = () => {
        if (!els.payoutSkillBtn) return;
        const now = Date.now();
        const skill = state.skills.payout;
        const active = skill.activeUntil > now;
        const cooling = skill.cooldownUntil > now;
        const busy = state.busy || !state.gameReady;
        let label = 'Payout +';
        if (active) {
          label = `Payout ${Math.round((skill.multiplier - 1) * 100)}% (${formatTime(skill.activeUntil - now)})`;
          els.payoutSkillBtn.dataset.state = 'active';
          els.payoutSkillBtn.disabled = busy;
        } else if (cooling) {
          label = `Cooldown ${formatTime(skill.cooldownUntil - now)}`;
          els.payoutSkillBtn.dataset.state = 'cooldown';
          els.payoutSkillBtn.disabled = true;
        } else {
          els.payoutSkillBtn.dataset.state = 'ready';
          els.payoutSkillBtn.disabled = busy;
        }
        els.payoutSkillBtn.textContent = label;
      };

      const tickSkills = () => {
        isDropSkillActive();
        renderSkillButton();
        renderBonusSummary();
      };

      let skillTimer = null;
      const startSkillTicker = () => {
        if (skillTimer) return;
        skillTimer = setInterval(tickSkills, 500);
      };
      const stopSkillTicker = () => {
        if (skillTimer) {
          clearInterval(skillTimer);
          skillTimer = null;
        }
      };

      function applyDailyState(dailyPayload = {}, rewardOverride = null) {
        const current = state.daily || {};
        const reward = rewardOverride || dailyPayload.todayReward || current.todayReward || null;
        const normalizedReward = reward
          ? { ...reward, drops: Array.isArray(reward.drops) ? reward.drops.map(normalizeDrop) : [] }
          : null;
        const ready = dailyPayload.ready !== undefined
          ? Boolean(dailyPayload.ready)
          : (!dailyPayload.claimedToday && (current.ready ?? true));
        state.daily = {
          streak: Number.isFinite(dailyPayload.streak) ? dailyPayload.streak : (current.streak || 1),
          claimedToday: Boolean(dailyPayload.claimedToday ?? current.claimedToday),
          ready,
          lastClaimMs: Number.isFinite(dailyPayload.lastClaimMs) ? Number(dailyPayload.lastClaimMs) : (current.lastClaimMs || 0),
          nextResetAt: Number.isFinite(dailyPayload.nextResetAt) ? Number(dailyPayload.nextResetAt) : (current.nextResetAt || 0),
          todayReward: normalizedReward
        };
        renderDaily();
      }

      function renderDaily() {
        if (!els.dailyStatus) return;
        const daily = state.daily || {};
        const reward = daily.todayReward;
        const ready = !daily.claimedToday && (daily.ready !== false);
        els.dailyStatus.textContent = ready ? 'Ready to claim' : 'Claimed';
        els.dailyStatus.dataset.state = ready ? 'ok' : 'muted';
        if (els.dailyStreak) {
          const day = Math.max(1, Math.floor(daily.streak || 1));
          els.dailyStreak.textContent = `Day ${day} of ${DAILY_LENGTH}`;
        }
        if (els.dailyRewardMain) {
          const parts = [];
          if (reward?.vipMarks) parts.push(`${reward.vipMarks} VIP`);
          if (reward?.credits) parts.push(currency.format(reward.credits));
          els.dailyRewardMain.textContent = parts.join(' ‚Ä¢ ') || 'Come back daily for prizes.';
        }
        if (els.dailyItems) {
          const drops = reward?.drops || [];
          if (!drops.length) {
            els.dailyItems.innerHTML = '<span class="muted-text">VIP marks and credits await.</span>';
          } else {
            els.dailyItems.innerHTML = drops.map(drop => {
              const info = normalizeDrop(drop);
              return `<span class="daily-item"><img src="${info.icon}" alt="${info.name}">${info.name} √ó${info.amount}</span>`;
            }).join('');
          }
        }
        if (els.dailyNextReset) {
          const nextReset = daily.nextResetAt ? new Date(daily.nextResetAt).toLocaleTimeString() : 'midnight';
          els.dailyNextReset.textContent = `Resets at ${nextReset}`;
        }
        if (els.dailyClaimBtn) {
          const disabled = !ready || state.busy || !state.gameReady || !state.auth.token;
          els.dailyClaimBtn.disabled = disabled;
        }
      }

      function renderBonusSummary() {
        if (!els.bonusList) return;
        const entries = [];
        const winMult = getDropMultiplier(true);
        const lossMult = getDropMultiplier(false);
        entries.push({
          label: 'Drop boost',
          value: `${winMult.total.toFixed(2)}√ó / ${lossMult.total.toFixed(2)}√ó`,
          note: 'Win / loss multiplier (bet, skill, upgrade)'
        });
        const equipStats = computeEquipmentStats();
        if (equipStats.coinPct) {
          entries.push({
            label: 'Coin bonus',
            value: `+${equipStats.coinPct.toFixed(1)}%`,
            note: 'From equipped gear and cards'
          });
        }
        if (equipStats.dropPct) {
          entries.push({
            label: 'Drop bonus',
            value: `+${equipStats.dropPct.toFixed(1)}%`,
            note: 'Gear/card bonuses applied to drop rates'
          });
        }
        if (equipStats.idlePct) {
          entries.push({
            label: 'Idle speed',
            value: `+${equipStats.idlePct.toFixed(1)}%`,
            note: 'Passive earnings tick faster'
          });
        }
        const idle = Math.max(0, state.upgrades.idle || 0);
        entries.push({
          label: 'Idle income',
          value: idle ? `+${idle}/s` : 'Locked',
          note: idle ? 'Earned passively while away' : 'Upgrade Idle Coins to start earning'
        });
        const maxBetMult = (state.maxBet || DEFAULT_MAX_BET) / DEFAULT_MAX_BET;
        entries.push({
          label: 'Max bet',
          value: `${maxBetMult.toFixed(1)}√ó`,
          note: `Cap ${currency.format(state.maxBet || DEFAULT_MAX_BET)}`
        });
        const rows = state.currentRows || state.machine?.rows || 3;
        const reels = state.currentReels || state.machine?.reels || 3;
        entries.push({
          label: 'Layout',
          value: `${rows} rows ¬∑ ${reels} reels`,
          note: `Line tier ${state.currentLineTier ?? 0}`
        });
        const skill = state.skills.dropRate?.spec;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        if (unlocked || skill) {
          const durationMin = skill ? Math.max(1, Math.round((skill.durationMs || 0) / 60000)) : 1;
          entries.push({
            label: 'Drop skill',
            value: isDropSkillActive() ? 'Boost active' : 'Ready',
            note: `${(skill?.multiplier || 1).toFixed(2)}√ó for ${durationMin}m`
          });
        }
        const html = entries.map(entry => `
          <li class="bonus-item">
            <div>
              <p class="bonus-label">${entry.label}</p>
              ${entry.note ? `<p class="bonus-note">${entry.note}</p>` : ''}
            </div>
            <strong class="bonus-value">${entry.value}</strong>
          </li>
        `).join('');
        els.bonusList.innerHTML = html || '<li class="bonus-item"><span class="bonus-label">No bonuses yet.</span></li>';
      }

      const renderAutoSpinButton = () => {
        if (!els.autoSpinBtn) return;
        const unlocked = isAutoSpinUnlocked();
        const count = getAutoSpinCount();
        els.autoSpinBtn.textContent = unlocked ? `Auto (${count})` : 'Auto';
        els.autoSpinBtn.disabled = !state.gameReady || state.busy || !unlocked;
        els.autoSpinBtn.setAttribute('aria-pressed', state.autoSpin.active ? 'true' : 'false');
      };

      const renderWorkerButton = () => {
        if (!els.workerBtn) return;
        els.workerBtn.textContent = state.worker.active ? 'Worker On' : 'Worker Off';
        els.workerBtn.setAttribute('aria-pressed', state.worker.active ? 'true' : 'false');
        els.workerBtn.disabled = state.busy || !state.gameReady;
      };

      const toggleWorker = () => {
        state.worker.active = !state.worker.active;
        if (state.worker.timer) {
          clearTimeout(state.worker.timer);
          state.worker.timer = null;
        }
        if (state.worker.active) {
          const tick = () => {
            if (!state.worker.active) return;
            if (!state.busy) {
              spin(true);
            }
            state.worker.timer = setTimeout(tick, state.worker.intervalMs);
          };
          state.worker.timer = setTimeout(tick, state.worker.intervalMs);
        }
        renderWorkerButton();
      };

      const activateDropSkill = () => {
        if (!state.gameReady || state.busy) return;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        if (!unlocked) {
          showAlert('Unlock the drop boost skill first.');
          return;
        }
        const skill = state.skills.dropRate;
        const now = Date.now();
        if (!skill || (skill.cooldownUntil && skill.cooldownUntil > now) || skill.active) {
          return;
        }
        skill.active = true;
        skill.expiresAt = now + (skill.spec?.durationMs || 60000);
        skill.cooldownUntil = skill.expiresAt + (skill.spec?.cooldownMs || 120000);
        log('Drop boost activated', `Running for ${formatTime(skill.expiresAt - now)}.`);
        renderSkillButton();
        if (!els.dropPanel?.hidden) {
          renderDropPanel();
        }
      };

      const activatePayoutSkill = () => {
        if (!state.gameReady || state.busy) return;
        const skill = state.skills.payout;
        const now = Date.now();
        if (!skill) return;
        if (skill.cooldownUntil > now || skill.activeUntil > now) return;
        skill.activeUntil = now + (skill.durationMs || 15000);
        skill.cooldownUntil = skill.activeUntil + (skill.cooldownMs || 30000);
        renderPayoutSkill();
        log('Payout boost activated', `${Math.round((skill.multiplier - 1) * 100)}% for ${formatTime(skill.activeUntil - now)}.`);
      };

      const dropSkillPayload = () => ({
        dropRate: isDropSkillActive()
      });


      const ensureGrid = (rows, reels) => {
        if (!els.slotGrid) return;
        const currentRows = Number(els.slotGrid.dataset.rows) || 0;
        const currentReels = Number(els.slotGrid.dataset.reels) || 0;
        if (currentRows === rows && currentReels === reels && state.gridCells.size === rows * reels) {
          return;
        }
        debug('grid:rebuild', { rows, reels });
        state.gridCells.clear();
        els.slotGrid.dataset.rows = rows;
        els.slotGrid.dataset.reels = reels;
        els.slotGrid.style.setProperty('--row-count', rows);
        els.slotGrid.style.setProperty('--reel-count', reels);
        els.slotGrid.innerHTML = '';
        reelState.clear();
        for (let col = 0; col < reels; col += 1) {
          const reel = document.createElement('div');
          reel.className = 'slot-reel';
          reel.dataset.col = col.toString();
          reel.style.setProperty('--row-count', rows);
          for (let row = 0; row < rows; row += 1) {
            const cell = document.createElement('div');
            cell.className = 'slot-cell';
            cell.dataset.row = row.toString();
            cell.dataset.col = col.toString();
            const wrapper = document.createElement('div');
            wrapper.className = 'slot-cell__symbol';
            const img = document.createElement('img');
            const seedSymbol = randomSymbolInfo();
            applySymbolToImage(img, seedSymbol.key);
            wrapper.appendChild(img);
            cell.appendChild(wrapper);
            reel.appendChild(cell);
            cell.dataset.symbol = seedSymbol.key;
            state.gridCells.set(`${row}:${col}`, cell);
          }
          els.slotGrid.appendChild(reel);
          reelState.set(col, {
            reel,
            offset: 0,
            speed: 0,
            raf: null,
            spinning: false
          });
        }
      };

      const getCellHeight = () => {
        const sample = els.slotGrid?.querySelector('.slot-cell');
        return sample?.getBoundingClientRect().height || 80;
      };

      const anyReelSpinning = () => Array.from(reelState.values()).some(info => info.spinning);

      const stopReelSpin = (col, finalSymbols = null) => {
        const info = reelState.get(col);
        if (!info) return;
        info.spinning = false;
        if (info.raf) {
          cancelFrame(info.raf);
          info.raf = null;
        }
        info.offset = 0;
        info.reel.style.transform = 'translateY(0px)';
        const rows = state.currentRows || state.machine.rows;
        const symbols = Array.isArray(finalSymbols) && finalSymbols.length
          ? finalSymbols
          : Array.from({ length: rows }, () => randomSymbolInfo().key);
        info.reel.innerHTML = '';
        for (let row = 0; row < rows; row += 1) {
          const cell = document.createElement('div');
          cell.className = 'slot-cell';
          cell.dataset.row = row.toString();
          cell.dataset.col = col.toString();
          const wrapper = document.createElement('div');
          wrapper.className = 'slot-cell__symbol';
          const img = document.createElement('img');
          const key = symbols[row] || randomSymbolInfo().key;
          applySymbolToImage(img, key);
          wrapper.appendChild(img);
          cell.appendChild(wrapper);
          info.reel.appendChild(cell);
          cell.dataset.symbol = key;
          cell.dataset.state = 'settled';
          state.gridCells.set(`${row}:${col}`, cell);
        }
      };

      const spinReel = (col) => {
        const info = reelState.get(col);
        if (!info) return;
        const cellHeight = getCellHeight();
        info.offset = 0;
        info.speed = 9 + col;
        info.spinning = true;
        const step = () => {
          if (!info.spinning) return;
          info.offset += info.speed;
          if (info.offset >= cellHeight) {
            info.offset -= cellHeight;
            const last = info.reel.lastElementChild;
            if (last) info.reel.prepend(last);
          }
          info.reel.style.transform = `translateY(${info.offset}px)`;
          info.raf = requestFrame(step);
        };
        info.raf = requestFrame(step);
      };

      const updateMachineMeta = () => {
        if (!els.machineLines) return;
        const settings = getUpgradeSettings();
        const lineTier = state.currentLineTier ?? 0;
        const patterns = Array.isArray(state.machine.lines) ? state.machine.lines : [];
        const lineCount = patterns.filter(def => def.tier <= lineTier).length || patterns.length || 0;
        const rows = state.currentRows || settings.baseRows;
        const reels = state.currentReels || settings.baseReels;
        const parts = [
          `${rows}/${settings.maxRows} rows`,
          `${reels}/${settings.maxReels} reels`
        ];
        if (lineCount) parts.push(`${lineCount} lines`);
        if (Array.isArray(state.machine.activeSymbols) && state.machine.activeSymbols.length) {
          parts.push(`${state.machine.activeSymbols.length} symbols`);
        }
        els.machineLines.textContent = parts.join(' ‚Ä¢ ');
      };

      const applyMachineTheme = () => {
        if (!els.reelStage) return;
        const assets = state.machine.assets || {};
        const frame = assets.frame || null;
        els.reelStage.style.backgroundColor = 'rgba(2,6,23,.75)';
        if (frame) {
          els.reelStage.style.backgroundImage = `url('${frame}')`;
          els.reelStage.style.backgroundSize = 'contain';
          els.reelStage.style.backgroundRepeat = 'no-repeat';
          els.reelStage.style.backgroundPosition = 'center';
        } else {
          els.reelStage.style.backgroundImage = '';
        }
      };

      const updateGridSymbols = (grid = []) => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        ensureGrid(rows, reels);
        for (let row = 0; row < rows; row += 1) {
          const rowSymbols = grid[row] || [];
          for (let col = 0; col < reels; col += 1) {
            const symbolKey = rowSymbols[col] || randomSymbolInfo().key;
            const cell = state.gridCells.get(`${row}:${col}`);
            if (!cell) continue;
            const img = cell.querySelector('img');
            const info = applySymbolToImage(img, symbolKey);
            cell.dataset.symbol = info.key;
            if (cell.dataset.state !== 'win') {
              cell.dataset.state = 'settled';
            }
            debug('grid:update-cell', { row, col, symbol: info.key });
          }
        }
      };

      const setGridState = (mode) => {
        state.gridCells.forEach(cell => {
          cell.dataset.state = mode;
        });
      };

      const getSpinIntervalDelay = (col) => {
        const timing = state.machine.spinTiming || {};
        const overspin = Array.isArray(timing.overspin) ? timing.overspin : [];
        const step = overspin.length ? overspin[col % overspin.length] : 12;
        const base = (step || 12) * 6;
        const speedLevel = Math.max(0, state.upgrades.speed || 0);
        const factor = Math.max(35, 100 - 10 * speedLevel);
        return Math.max(20, Math.trunc((base * factor) / 100));
      };

      const getReelStopDelay = (col) => {
        const timing = state.machine.spinTiming || {};
        const brake = Number.isFinite(timing.brake) ? timing.brake : 180;
        const base = brake + col * Math.max(60, Math.trunc(brake * 0.6));
        const speedLevel = Math.max(0, state.upgrades.speed || 0);
        const autoLevel = Math.max(0, state.upgrades.autoSpeed || 0);
        const factor = Math.max(55, 100 - 8 * (speedLevel + autoLevel));
        return Math.max(70, Math.trunc((base * factor) / 100));
      };

      const startGridSpin = () => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        ensureGrid(rows, reels);
        activeReelLocks = reels;
        pendingSpinResult = null;
        pendingWinGroups = [];
        clearLineFlash(true);
        state.gridCells.forEach(cell => {
          cell.classList.remove('slot-lock');
          cell.dataset.state = 'spinning';
        });
        setGridState('spinning');
        for (let col = 0; col < reels; col += 1) {
          spinReel(col);
        }
      };

      function flushPendingSpinResult() {
        if (pendingSpinResult && activeReelLocks === 0 && !anyReelSpinning()) {
          const data = pendingSpinResult;
          pendingSpinResult = null;
          updateLastSpin(data);
        }
      }

      const stopGridSpin = (grid) => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        if (!Array.isArray(grid)) {
          reelState.forEach((_, col) => stopReelSpin(col, null));
          state.gridCells.forEach(cell => {
            if (cell.dataset.state === 'spinning') cell.dataset.state = 'settled';
          });
          activeReelLocks = 0;
          flushPendingSpinResult();
          notifyReelsSettled();
          return;
        }
        activeReelLocks = reels;
        for (let col = 0; col < reels; col += 1) {
          const columnSymbols = [];
          for (let row = 0; row < rows; row += 1) {
            columnSymbols[row] = grid[row]?.[col];
          }
          const delay = getReelStopDelay(col) + Math.random() * 120;
          setTimeout(() => {
            stopReelSpin(col, columnSymbols);
            activeReelLocks = Math.max(0, activeReelLocks - 1);
            flushPendingSpinResult();
            notifyReelsSettled();
          }, delay);
        }
      };

      const highlightWins = (groups = []) => {
        state.gridCells.forEach(cell => {
          if (cell.dataset.state === 'spinning') return;
          cell.dataset.state = 'settled';
        });
        if (!groups.length) return;
        groups.forEach(group => {
          if (group.symbol === 'bonus') {
            state.gridCells.forEach(cell => {
              if (cell.dataset.symbol === 'bonus') cell.dataset.state = 'win';
            });
            return;
          }
          if (!Array.isArray(group.pattern) || !Array.isArray(group.indexes)) return;
          const rows = state.currentRows || state.machine.rows;
          group.indexes.forEach(index => {
            const row = Math.max(0, Math.min(group.pattern[index] ?? 0, rows - 1));
            const cell = state.gridCells.get(`${row}:${index}`);
            if (cell) cell.dataset.state = 'win';
          });
        });
      };

      const evaluateClientOutcome = (grid = [], bet = 1) => {
        const rows = grid.length;
        const reels = grid[0]?.length || 0;
        const patterns = (state.machine.lines || []).filter(def => (def.tier ?? 0) <= (state.currentLineTier ?? 0));
        const groups = [];
        let payout = 0;
        patterns.forEach(def => {
          const pattern = def.pattern || [];
          let base = null;
          const indexes = [];
          for (let col = 0; col < Math.min(pattern.length, reels); col += 1) {
            const row = Math.max(0, Math.min(rows - 1, pattern[col]));
            const symbol = grid[row]?.[col];
            if (col === 0) {
              base = symbol === 'wild' ? null : symbol;
              indexes.push(col);
              continue;
            }
            if (symbol === base || symbol === 'wild' || base === null) {
              if (base === null && symbol !== 'wild') base = symbol;
              indexes.push(col);
            } else {
              break;
            }
          }
          const count = indexes.length;
          const key = base || 'wild';
          if (count >= 3) {
            const pay = (state.machine.payouts?.[key] || 1) * Math.max(1, count - 2) * bet;
            payout += pay;
            groups.push({ symbol: key, count, indexes, pattern, payout: pay });
          }
        });
        const equip = computeEquipmentStats();
        const coinMult = 1 + Math.max(0, equip.coinPct || 0) / 100;
        return { payout: payout * coinMult, groups, coinMult };
      };

      const runClientSpin = (bet, overrides = {}) => {
        const rows = (overrides.rows ?? state.currentRows) || state.machine.rows;
        const reels = (overrides.reels ?? state.currentReels) || state.machine.reels;
        ensureGrid(rows, reels);
        const spinOnce = () => {
          const grid = Array.from({ length: rows }, () => Array(reels).fill(''));
          for (let row = 0; row < rows; row += 1) {
            for (let col = 0; col < reels; col += 1) {
              const symbol = randomSymbolInfo();
              grid[row][col] = symbol.key;
            }
          }
          const { payout, groups } = evaluateClientOutcome(grid, bet);
          return { grid, payout, groups };
        };
        let result = spinOnce();
        let retriggered = false;
        const base = 0.05 * Math.max(0, state.upgrades.retrigger || 0);
        const bonus = 0.05 * Math.max(0, state.upgrades.retriggerQuality || 0);
        const retriggerChance = Math.min(0.95, base + bonus);
        if (result.payout <= 0 && retriggerChance > 0 && Math.random() < retriggerChance) {
          retriggered = true;
          result = spinOnce();
        }
        return {
          grid: result.grid,
          winAmount: result.payout,
          winGroups: result.groups,
          retriggered,
          outcome: result.payout > 0 ? 'Win' : 'No win',
          timestamp: new Date().toISOString()
        };
      };

      function renderPaytable() {
        if (!els.paytable) return;
        if (!state.symbolMap.size) {
          state.symbolMap = cloneSymbolMap(DEFAULT_SYMBOL_MAP);
        }
        const entries = Array.from(state.symbolMap.values());
        const activeSet = new Set(state.machine.activeSymbols || []);
        els.paytable.innerHTML = entries.map(entry => {
          const payout = state.machine.payouts[entry.key] || 0;
          const tiers = [1, 2, 3].map(mult => `${mult + 2}√ó ${payout ? payout * mult : 0}√ó bet`).join(' ‚Ä¢ ');
          const asset = entry.asset || getPlaceholderAsset();
          if (!entry.asset || asset === getPlaceholderAsset()) {
            debug('paytable:placeholder', { symbol: entry.key });
          }
          const isActive = activeSet.size === 0 || activeSet.has(entry.key);
          return `
            <li data-active="${isActive ? 'true' : 'false'}">
              <div class="paytable-symbol">
                <img src="${asset}" alt="${entry.label}" data-symbol="${entry.key}" loading="lazy">
                ${entry.label}
              </div>
              <div class="paytable-meta">${tiers}</div>
            </li>
          `;
        }).join('');
        els.paytable.querySelectorAll('.paytable-symbol img').forEach(img => {
          attachImageDebugging(img, img.dataset.symbol);
        });
        debug('paytable:render', { symbols: entries.length });
      }

      const setSymbolMap = (symbols = [], reason = 'update') => {
        const list = Array.isArray(symbols) ? symbols : [];
        state.symbolMap = buildSymbolMap(list, state.symbolMap || DEFAULT_SYMBOL_MAP, getPlaceholderAsset());
        if (list.length) {
          state.machine.symbols = list.map(entry => ({ ...entry }));
        } else if (!state.machine.symbols || !state.machine.symbols.length) {
          state.machine.symbols = Array.from(state.symbolMap.values()).map(entry => ({
            key: entry.key,
            label: entry.label,
            asset: entry.asset
          }));
        }
        debug('symbols:set', { reason, count: state.symbolMap.size });
        auditSymbolAssets();
        rebuildSymbolWeights();
        renderPaytable();
      };
      setSymbolMap(DEFAULT_SYMBOLS, 'init');
      applyUpgradeState(getMachineUpgrades(state.machine.id));

      function applyUpgradeState(incoming = getMachineUpgrades(state.machine.id)) {
        const currentLocal = localUpgradeBucket();
        const baseUpgrades = getMachineUpgrades(state.machine.id);
        const source = incoming || baseUpgrades;
        let normalized = {};
        if (state.upgradeCatalog.length) {
          state.upgradeCatalog.forEach(def => {
            const next = Number.isFinite(source?.[def.key])
              ? source[def.key]
              : Number(baseUpgrades?.[def.key]) || 0;
            const max = getUpgradeMaxLevel(def.key);
            const clientBoost = Math.max(0, Math.floor(currentLocal[def.key] || 0));
            normalized[def.key] = Math.min(Math.max(0, Math.floor(next + clientBoost)), max);
          });
        } else {
          normalized = { ...baseUpgrades, ...source, ...currentLocal };
        }
        const settings = getUpgradeSettings();
        const rows = Math.min(
          settings.maxRows,
          (settings.baseRows || 3) + (normalized.rows || 0)
        );
        const reels = Math.min(
          settings.maxReels,
          (settings.baseReels || 3) + (normalized.reels || 0)
        );
        const maxLineTier = state.machine.lineTier || (state.machine.lines?.[state.machine.lines.length - 1]?.tier ?? 3);
        const lineTier = Math.min(maxLineTier, normalized.lines || 0);
        state.machine.lines = buildLinePatterns(rows, reels);
        const effective = { ...normalized };
        Object.entries(state.pendingUpgrades || {}).forEach(([key, val]) => {
          const appended = (effective[key] || 0) + val;
          const max = getUpgradeMaxLevel(key);
          effective[key] = Math.min(max, appended);
        });
        state.upgrades = effective;
        ensureMachineProgress(state.machine.id).upgrades = { ...normalized };
        state.currentRows = rows;
        state.currentReels = reels;
        state.currentLineTier = lineTier;
        state.machine.rows = rows;
        state.machine.reels = reels;
        state.machine.currentRows = rows;
        state.machine.currentReels = reels;
        state.machine.currentLineTier = lineTier;
        state.machine.activeSymbols = computeActiveSymbols(normalized);
        const betMult = Math.max(0, normalized.betMultiplier || 0);
        const baseMax = resolveMaxBet(root?.dataset?.maxBet || DEFAULT_MAX_BET);
        state.maxBet = resolveMaxBet(baseMax) * Math.max(1, 10 ** betMult);
        els.maxBet.textContent = state.maxBet;
        syncBetSteps();
        rebuildSymbolWeights();
        ensureGrid(rows, reels);
        renderUpgrades();
        updateMachineMeta();
        updateSkillSpec();
        renderSkillButton();
        renderBonusSummary();
        renderAutoSpinButton();
        startIdleTicker();
      }

      const syncMachineDefinition = (machine = {}) => {
        if (!machine || typeof machine !== 'object') return;
        state.machine.id = machine.id || state.machine.id;
        state.machine.name = machine.name || state.machine.name;
        state.machine.lineTier = Number(machine.lineTier) || state.machine.lineTier;
        state.machine.rows = Number(machine.rows) || state.machine.rows;
        state.machine.reels = Number(machine.reels) || state.machine.reels;
        state.machine.baseSymbolCount = Number(machine.baseSymbolCount) || state.machine.baseSymbolCount;
        if (Array.isArray(machine.lines)) state.machine.lines = machine.lines;
        if (machine.payouts) state.machine.payouts = machine.payouts;
        if (machine.assets) state.machine.assets = { ...state.machine.assets, ...machine.assets };
        if (Array.isArray(machine.activeSymbols)) state.machine.activeSymbols = machine.activeSymbols.slice();
        if (Array.isArray(machine.symbols)) {
          state.machine.symbols = machine.symbols.map(entry => ({ ...entry }));
        }
        if (machine.spinTiming) {
          state.machine.spinTiming = { ...machine.spinTiming };
        }
        const baseRows = Number(machine.baseRows ?? machine.upgrades?.baseRows ?? state.machine.upgradeSettings?.baseRows ?? state.machine.rows);
        const maxRows = Number(machine.maxRows ?? machine.upgrades?.maxRows ?? state.machine.upgradeSettings?.maxRows ?? state.machine.rows);
        const baseReels = Number(machine.baseReels ?? machine.upgrades?.baseReels ?? state.machine.upgradeSettings?.baseReels ?? state.machine.reels);
        const maxReels = Number(machine.maxReels ?? machine.upgrades?.maxReels ?? state.machine.upgradeSettings?.maxReels ?? state.machine.reels);
        const upgradeCosts = machine.upgrades?.costs
          || machine.upgradeSettings?.costs
          || machine.upgradeCosts
          || state.machine.upgradeSettings?.costs
          || {};
        state.machine.upgradeSettings = {
          baseRows,
          maxRows,
          baseReels,
          maxReels,
          costs: upgradeCosts
        };
        state.machine.rows = baseRows;
        state.machine.reels = baseReels;
        state.currentRows = baseRows;
        state.currentReels = baseReels;
        setSymbolMap(Array.isArray(machine.symbols) ? machine.symbols : [], 'syncMachineDefinition');
        applyUpgradeState(state.upgrades);
      };

      const machineConfigUrl = (machineId) => `${MACHINE_CONFIG_DIR}/${machineId}.json`;

      const fetchMachineConfig = async (machineId, allowFallback = false) => {
        if (!machineId) return null;
        if (machineCache.has(machineId)) return machineCache.get(machineId);
        const url = machineConfigUrl(machineId);
        try {
          const res = await fetch(url, { cache: 'no-cache' });
          if (res.ok) {
            const data = await res.json();
            machineCache.set(machineId, data);
            return data;
          }
        } catch (error) {
          debugError('machine-config', error, { machineId, url });
        }
        if (allowFallback && MACHINE_CONFIG_URL) {
          try {
            const res = await fetch(MACHINE_CONFIG_URL, { cache: 'no-cache' });
            if (res.ok) {
              const data = await res.json();
              machineCache.set(machineId, data);
              return data;
            }
          } catch (error) {
            debugError('machine-config:fallback', error, { machineId });
          }
        }
        return null;
      };

      const ensureDropTables = async () => {
        if (dropTableCache) return dropTableCache;
        try {
          const res = await fetch(DROP_TABLE_URL, { cache: 'no-cache' });
          if (res.ok) {
            dropTableCache = await res.json();
          }
        } catch (error) {
          debugError('drop-tables', error);
        }
        if (!dropTableCache) {
          dropTableCache = { tierWeights: state.drop.tierWeights, tables: { classic: state.drop.table } };
        }
        return dropTableCache;
      };

      const syncDropTableForMachine = async (machineId = 'classic') => {
        const tables = await ensureDropTables();
        const table = tables?.tables?.[machineId] || tables?.tables?.classic || { common: [], rare: [], epic: [] };
        state.drop.tableKey = machineId || 'classic';
        state.drop.table = table;
        if (tables?.tierWeights) {
          state.drop.tierWeights = { ...state.drop.tierWeights, ...tables.tierWeights };
        }
      };

      const renderMachineList = async () => {
        if (!els.machineList) return;
        const cards = await Promise.all((machineList || []).map(async id => {
          const cfg = await fetchMachineConfig(id).catch(() => null);
          const prog = ensureMachineProgress(id);
          return {
            id,
            name: cfg?.name || id,
            tier: cfg?.tier || 'Demo',
            icon: cfg?.assets?.icon || null,
            unlocked: prog.unlocked
          };
        }));
        els.machineList.innerHTML = cards.map(card => `
          <button type="button" class="machine-card" data-machine-id="${card.id}" data-active="${card.id === state.machine.id ? 'true' : 'false'}" data-locked="${card.unlocked ? 'false' : 'true'}" role="listitem" ${card.unlocked ? '' : 'disabled'}>
            <div class="machine-card__meta">
              ${card.icon ? `<img src="${card.icon}" alt="${card.name}" class="machine-card__icon" loading="lazy">` : ''}
              <span class="rarity-tag">${card.tier}</span>
            </div>
            <p class="machine-card__name">${card.name}</p>
            <p class="machine-card__meta">${card.id}</p>
          </button>
        `).join('');
      };

      const setActiveMachine = async (machineId, options = {}) => {
        const targetId = machineId || state.machine.id || 'classic';
        const prog = ensureMachineProgress(targetId);
        if (!prog.unlocked) {
          showAlert('Machine locked. Level up current machine to unlock.');
          return;
        }
        const cfg = await fetchMachineConfig(targetId, true);
        if (!cfg) {
          debugError('machine:set', new Error('Missing machine config'), { targetId });
          ensureGrid(state.machine.rows, state.machine.reels);
          return;
        }
        state.machine.id = cfg.id || targetId;
        machineCache.set(state.machine.id, cfg);
        syncMachineDefinition(cfg);
        setSymbolMap(cfg.symbols || DEFAULT_SYMBOLS, 'machine-switch');
        state.machine.activeSymbols = computeActiveSymbols(state.upgrades);
        ensureGrid(state.currentRows || state.machine.rows, state.currentReels || state.machine.reels);
        applyMachineTheme();
        renderPaytable();
        rebuildSymbolWeights();
        updateMachineMeta();
        renderBonusSummary();
        applyUpgradeState(getMachineUpgrades(state.machine.id));
        await syncDropTableForMachine(state.machine.id);
        renderDropPanel();
        renderMachineList();
        if (els.machineName) els.machineName.textContent = state.machine.name || state.machine.id;
        if (els.machineTier) els.machineTier.textContent = cfg.tier || 'Demo';
        const configuredMax = Number(cfg.maxBet);
        state.maxBet = resolveMaxBet(Number.isFinite(configuredMax) ? configuredMax : (root?.dataset?.maxBet || DEFAULT_MAX_BET));
        syncBetSteps();
        setBetValue(state.bet);
        try {
          localStorage.setItem(LOCAL_MACHINE_KEY, state.machine.id);
        } catch {
          // ignore
        }
        if (!options.silent) {
          log('Machine ready', `${state.machine.name || state.machine.id} loaded`);
          markDirty('machine-switch');
        }
      };

      const loadMachineList = async () => {
        try {
          const res = await fetch(MACHINE_LIST_URL, { cache: 'no-cache' });
          if (res.ok) {
            const ids = await res.json();
            if (Array.isArray(ids)) {
              machineList = ids;
              await renderMachineList();
            }
          }
        } catch (error) {
          debugError('machine-list', error);
        }
        const preferred = localStorage.getItem(LOCAL_MACHINE_KEY);
        const target = (machineList || []).includes(preferred)
          ? preferred
          : (machineList?.[0] || state.machine.id || 'classic');
        await setActiveMachine(target, { silent: true });
      };

      const loadMachineConfig = async () => {
        await loadMachineList();
      };

      const setAuthMode = (mode = 'login') => {
        debug('auth:setMode', mode);
        const nextMode = mode === 'register' ? 'register' : 'login';
        state.authMode = nextMode;
        localStorage.setItem(AUTH_MODE_KEY, nextMode);
        if (els.authBody) {
          els.authBody.dataset.mode = nextMode;
        }
        (els.authTabs || []).forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === nextMode);
        });
        if (els.authSubmit) {
          els.authSubmit.textContent = nextMode === 'register' ? 'Create Account' : 'Sign In';
        }
        if (els.authConfirmGroup) {
          els.authConfirmGroup.hidden = nextMode !== 'register';
        }
        if (nextMode !== 'register' && els.authConfirm) {
          els.authConfirm.value = '';
        }
        showAuthAlert('');
      };

      setGameVisibility(false);
      renderAutoSpinButton();
      setAuthMode(state.authMode);
      const handleAuthEnter = (event) => {
        if (event.key === 'Enter' && !state.busy) {
          event.preventDefault();
          if (document.activeElement === els.authEmail || document.activeElement === els.authPassword || document.activeElement === els.authConfirm) {
            loginOrRegister();
          }
        }
      };

      [els.authEmail, els.authPassword, els.authConfirm].forEach(input => {
        if (input) input.addEventListener('keydown', handleAuthEnter);
      });


      let hudScheduled = false;
      const updateHud = () => {
        if (hudScheduled) return;
        hudScheduled = true;
        requestFrame(() => {
          hudScheduled = false;
          const totalBalance = (state.balance || 0) + (state.pendingIdleCoins || 0);
          if (els.hudBalance) els.hudBalance.textContent = formatCompactMoney(totalBalance);
          if (els.hudBet) els.hudBet.textContent = formatCompactMoney(state.bet || 0);
          if (els.hudWin) els.hudWin.textContent = formatCompactMoney(state.lastWin || 0);
          if (els.hudVip) {
            const vipMarks = Number(state.drop?.inventory?.vipMarks || 0);
            els.hudVip.textContent = `${formatCompactNumber(vipMarks)} VIP`;
          }
          if (els.hudEnergy) {
            const current = Math.floor(state.energy.current || 0);
            const max = Math.floor(state.energy.max || 0);
            els.hudEnergy.textContent = `${current}/${max}`;
          }
          if (els.hudLevel) {
            const prog = ensureMachineProgress(state.machine.id);
            els.hudLevel.textContent = `Lv ${prog.lvl || 0}`;
          }
        });
      };
      const clearLineFlash = (reenable = false) => {
        if (state.lineFlashTimer) {
          clearTimeout(state.lineFlashTimer);
          state.lineFlashTimer = null;
        }
        state.gridCells.forEach(cell => cell.classList.remove('line-flash'));
        if (els.lineOverlay) {
          els.lineOverlay.innerHTML = '';
        }
        if (reenable && els.lineFlashBtn) {
          els.lineFlashBtn.disabled = false;
          els.lineFlashBtn.removeAttribute('aria-busy');
        }
      };
      const renderLineOverlay = (patterns = []) => {
        if (!els.lineOverlay || !els.slotGrid) return;
        const overlayRect = els.lineOverlay.getBoundingClientRect();
        const width = Math.max(1, overlayRect.width || els.slotGrid.offsetWidth || 1);
        const height = Math.max(1, overlayRect.height || els.slotGrid.offsetHeight || 1);
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        const rows = state.currentRows || state.machine.rows;
        patterns.forEach((pattern, idx) => {
          const points = [];
          (pattern.pattern || []).forEach((row, col) => {
            const r = Math.max(0, Math.min(rows - 1, row));
            const cell = state.gridCells.get(`${r}:${col}`);
            if (!cell) return;
            const rect = cell.getBoundingClientRect();
            const cx = (rect.left + rect.right) / 2 - overlayRect.left;
            const cy = (rect.top + rect.bottom) / 2 - overlayRect.top;
            points.push(`${cx},${cy}`);
          });
          if (points.length >= 2) {
            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            poly.setAttribute('points', points.join(' '));
            poly.classList.add('line-path');
            poly.style.setProperty('--line-hue', `${(idx * 53) % 360}`);
            poly.style.animationDelay = `${idx * 0.08}s`;
            svg.appendChild(poly);
          }
        });
        els.lineOverlay.innerHTML = '';
        if (svg.childElementCount) {
          els.lineOverlay.appendChild(svg);
        }
      };
      const flashActiveLines = () => {
        if (!state.gameReady) return;
        clearLineFlash();
        const patterns = (state.machine.lines || []).filter(def => (def.tier ?? 0) <= (state.currentLineTier ?? 0));
        if (!patterns.length) {
          showAlert('No active lines yet. Unlock multi-line upgrades to see more patterns.');
          return;
        }
        if (els.lineFlashBtn) {
          els.lineFlashBtn.disabled = true;
          els.lineFlashBtn.setAttribute('aria-busy', 'true');
        }
        const rows = state.currentRows || state.machine.rows;
        state.gridCells.forEach(cell => cell.classList.remove('line-flash'));
        patterns.forEach(pattern => {
          (pattern.pattern || []).forEach((row, col) => {
            const r = Math.max(0, Math.min(rows - 1, row));
            const cell = state.gridCells.get(`${r}:${col}`);
            if (cell) cell.classList.add('line-flash');
          });
        });
        renderLineOverlay(patterns);
        const duration = Math.min(3500, 800 + patterns.length * 140);
        state.lineFlashTimer = setTimeout(() => {
          clearLineFlash(true);
        }, duration);
      };
      function clearSyncedPending(snapshot = {}) {
        let changed = false;
        Object.entries(snapshot || {}).forEach(([key, value]) => {
          if (!value) return;
          const current = state.pendingUpgrades?.[key] || 0;
          const remaining = current - value;
          if (remaining > 0) {
            state.pendingUpgrades[key] = remaining;
          } else {
            delete state.pendingUpgrades[key];
          }
          changed = true;
        });
        if (changed) {
          applyUpgradeState(state.serverUpgrades);
          renderUpgrades();
        }
      }

      function stopIdleTicker() {
        if (state.idleTicker) {
          cancelFrame(state.idleTicker);
          state.idleTicker = null;
        }
        state.idleTickerActive = false;
        state.lastIdleTick = 0;
      }

      function idleStep(timestamp) {
        if (!state.idleTickerActive) return;
        if (!state.lastIdleTick) state.lastIdleTick = timestamp;
        // Energy regen
        const energyDelta = (timestamp - state.energy.lastUpdate) / 1000;
        if (energyDelta > 0) {
          const gain = energyDelta * (state.energy.rechargePerSec || 0);
          const next = Math.min(state.energy.max, state.energy.current + gain);
          if (next !== state.energy.current) {
            state.energy.current = next;
            state.energy.lastUpdate = timestamp;
            updateHud();
          }
        }
        // Payout skill expiration
        const payout = state.skills.payout;
        if (payout && payout.activeUntil && payout.activeUntil <= timestamp) {
          payout.activeUntil = 0;
          renderPayoutSkill();
        }
        const equip = computeEquipmentStats();
        const rate = Math.max(0, state.upgrades.idle || 0) * (1 + Math.max(0, equip.idlePct || 0) / 100);
        const delta = timestamp - state.lastIdleTick;
        if (rate > 0 && delta >= 1000) {
          const seconds = Math.floor(delta / 1000);
          const gained = rate * seconds;
          state.balance += gained;
          state.pendingIdleCoins = 0;
          state.lastIdleTick += seconds * 1000;
          if (els.balance) els.balance.textContent = currency.format(state.balance);
          updateHud();
        }
        state.idleTicker = requestFrame(idleStep);
      }

      function startIdleTicker() {
        stopIdleTicker();
        if (!state.gameReady || !state.auth.token) return;
        if ((state.upgrades.idle || 0) <= 0) return;
        state.idleTickerActive = true;
        state.lastIdleTick = 0;
        state.idleTicker = requestFrame(idleStep);
      }

      const setBetValue = (value) => {
        syncBetSteps();
        const capped = Math.min(value || 1, state.maxBet || DEFAULT_MAX_BET);
        const idx = getNearestBetIndex(capped);
        const safe = betFromIndex(idx);
        debug('bet:update', { requested: value, applied: safe, max: state.maxBet, idx });
        const prev = state.bet;
        state.bet = safe;
        if (els.betSlider) {
          els.betSlider.max = Math.max(0, betSteps.length - 1);
          els.betSlider.value = idx;
          els.betSlider.setAttribute('aria-valuenow', safe.toString());
          els.betSlider.setAttribute('aria-valuemax', (state.maxBet || DEFAULT_MAX_BET).toString());
        }
        if (prev !== safe) {
          markDirty('bet');
        }
        updateHud();
        if (els.dropPanel && !els.dropPanel.hidden) {
          renderDropPanel();
        }
        renderSkillButton();
        renderBonusSummary();
      };
      setBetValue(state.bet);

      const storeGuestPlayer = (value) => {
        if (value) {
          localStorage.setItem(storageKeys.player, value);
        }
      };
      const resetStoredPlayer = () => localStorage.removeItem(storageKeys.player);

      const updateAuthUI = () => {
        debug('auth:updateUI', { loggedIn: Boolean(state.auth.token) });
        const loggedIn = Boolean(state.auth.token);
        if (els.authOverlay) {
          els.authOverlay.dataset.hidden = loggedIn ? 'true' : 'false';
          els.authOverlay.setAttribute('aria-hidden', loggedIn ? 'true' : 'false');
          if (loggedIn && els.authOverlay.contains(document.activeElement)) {
            document.activeElement.blur?.();
          }
        }
        if (loggedIn && els.accountUser) {
          els.accountUser.textContent = state.auth.username || 'Account';
        }
        if (els.accountToggle) {
          els.accountToggle.disabled = !loggedIn;
        }
        if (els.logoutBtn) {
          els.logoutBtn.disabled = !loggedIn;
        }
        if (!loggedIn) {
          toggleAccountSheet(false);
        }
        if (els.deleteBtn) {
          els.deleteBtn.disabled = !loggedIn;
        }
        if (loggedIn) startIdleTicker();
        else {
          stopIdleTicker();
          state.pendingIdleCoins = 0;
          state.pendingUpgrades = {};
          updateHud();
        }
        if (els.debugCoinBtn) {
          const matchesDebug = loggedIn && (state.auth.username || '').toLowerCase() === DEBUG_EMAIL;
          els.debugCoinBtn.hidden = !matchesDebug;
          els.debugCoinBtn.disabled = !matchesDebug;
        }
        if (!loggedIn && els.authPassword) {
          els.authPassword.value = '';
          if (els.authConfirm) els.authConfirm.value = '';
        }
        if (!loggedIn) {
          if (els.machineOutcome) els.machineOutcome.textContent = 'Sign in to start spinning.';
          if (els.hudWin) els.hudWin.textContent = formatCompactMoney(0);
          updateHud();
        }
      };

      const setAuthState = ({ token, username } = {}) => {
        debug('auth:setState', { tokenPresent: Boolean(token), username });
        state.auth.token = token || null;
        state.auth.username = token ? (username || state.auth.username || null) : null;
        if (!state.auth.token) {
          resetLocalProgress();
          state.sync = { rev: 0, dirty: false, inFlight: false, lastPush: 0, debounceTimer: null, queue: [] };
          state.playerId = null;
          state.pendingIdleCoins = 0;
          stopIdleTicker();
          stopSessionSync();
          state.worker.active = false;
          if (state.worker.timer) {
            clearTimeout(state.worker.timer);
            state.worker.timer = null;
          }
          state.drop.inventory = {};
          state.drop.history = [];
          state.drop.lastDrops = [];
          state.drop.lastTimestamp = 0;
          state.daily = {
            streak: 1,
            claimedToday: false,
            ready: false,
            lastClaimMs: 0,
            nextResetAt: 0,
            todayReward: null
          };
          renderDropLog();
          renderInventory();
          renderDaily();
          renderBonusSummary();
          toggleDropPanel(false);
          updateHud();
          applyUpgradeState({});
        }
        if (state.auth.token) {
          clearLocalUpgradeState();
          resetAutoState();
          state.sync.rev = 0;
          state.sync.dirty = false;
          state.sync.queue = [];
          localStorage.setItem(storageKeys.token, state.auth.token);
          localStorage.setItem(storageKeys.user, state.auth.username || '');
          resetStoredPlayer();
        } else {
          localStorage.removeItem(storageKeys.token);
          localStorage.removeItem(storageKeys.user);
        }
        updateAuthUI();
        if (state.auth.token) startSessionSync();
      };

      const clearAuth = (message) => {
        debug('auth:clear', { message });
        if (!state.auth.token) return;
        setAuthState({});
        setGameVisibility(false);
        setStatus('Sign in to start', 'error');
        if (message) {
          showAuthAlert(message);
          log('Auth', message);
        }
      };

      const syncAuthFromPayload = (payload = {}) => {
        debug('auth:syncFromPayload', payload);
        if (payload.token && payload.username) {
          setAuthState({ token: payload.token, username: payload.username });
          showAuthAlert('');
        }
      };

      const withAuth = (payload = {}) => {
        if (state.auth.token) {
          return { ...payload, token: state.auth.token };
        }
        return payload;
      };

      const request = async (path, payload = {}, options = {}) => {
        const finalPayload = options.skipAuth ? payload : withAuth(payload);
        debug('request:start', { path, payload: finalPayload, options });
        let res;
        try {
          res = await fetch(`${API_BASE}${path}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(finalPayload)
          });
        } catch (networkError) {
          const err = new Error('Network request failed.');
          err.cause = networkError;
          debugError('request:network', networkError, { path, payload: finalPayload });
          throw err;
        }
        let data = {};
        try {
          data = await res.json();
        } catch {
          data = {};
        }
        debug('request:response', { path, status: res.status, ok: res.ok, body: data });
        if (!res.ok) {
          if (res.status === 401 && !options.skipAuth) {
            clearAuth('Session expired. Please sign in again.');
          }
          const err = new Error(data.error || data.message || 'Request failed');
          err.payload = data;
          err.status = res.status;
          debugError('request:error', err, { path, payload: finalPayload });
          throw err;
        }
        return data;
      };

      const updateStats = (payload = {}) => {
        debug('updateStats', payload);
        if (typeof payload.rev === 'number') {
          state.sync.rev = Math.max(state.sync.rev || 0, payload.rev);
          state.sync.dirty = false;
          state.sync.queue = [];
        }
        if (payload.playerId) {
          state.playerId = payload.playerId;
          els.playerId.textContent = payload.playerId;
          if (state.auth.token) {
            resetStoredPlayer();
          } else {
            storeGuestPlayer(payload.playerId);
          }
        }
        if (typeof payload.balance === 'number') {
          state.balance = payload.balance;
          els.balance.textContent = currency.format(payload.balance);
        }
        if (Number(payload.idleGained) > 0) {
          log('Idle payout collected', `+${currency.format(payload.idleGained)} credits while away.`);
          state.pendingIdleCoins = Math.max(0, (state.pendingIdleCoins || 0) - payload.idleGained);
          state.lastIdleTick = 0;
          startIdleTicker();
        }
        if (typeof payload.spins === 'number') {
          state.spinCount = payload.spins;
          els.spinCount.textContent = payload.spins;
        }
        if (payload.currentRows) state.currentRows = payload.currentRows;
        if (payload.currentReels) state.currentReels = payload.currentReels;
        if (payload.energy) state.energy = { ...state.energy, ...payload.energy };
        if (payload.worker) state.worker = { ...state.worker, ...payload.worker };
        if (payload.machines) state.machines = { ...state.machines, ...payload.machines };
        if (payload.machine) {
          syncMachineDefinition(payload.machine);
        }
        if (payload.dropState) {
          applyDropState(payload.dropState);
        } else if (payload.inventory) {
          applyDropState({ inventory: payload.inventory });
        }
        if (payload.daily) {
          applyDailyState(payload.daily, payload.reward);
        } else if (payload.reward && state.daily) {
          applyDailyState(state.daily, payload.reward);
        }

        if (payload.upgrades) {
          ensureMachineProgress(state.machine.id).upgrades = { ...payload.upgrades };
        }
        applyUpgradeState(getMachineUpgrades(state.machine.id));
        const incomingBet = Number(payload.bet);
        const fallbackBet = Number.isFinite(state.bet)
          ? state.bet
          : Number(els.betSlider?.value);
        const desiredBet = Number.isFinite(incomingBet)
          ? incomingBet
          : (Number.isFinite(fallbackBet) ? fallbackBet : 1);
        setBetValue(desiredBet || 1);
        updateHud();
        renderBonusSummary();
        renderAutoSpinButton();
      };

      const formatWinSummary = (groups = []) => {
        if (!groups?.length) return '';
        return groups
          .slice()
          .sort((a, b) => (b.payout || 0) - (a.payout || 0))
          .map(group => {
            const info = getSymbolEntry(group.symbol);
            return `${info.label || info.key} √ó${group.count}`;
          })
          .join(', ');
      };

      const updateLastSpin = (lastSpin) => {
        debug('updateLastSpin', lastSpin);
        if (!lastSpin) {
          state.lastWin = 0;
          if (els.lastOutcome) els.lastOutcome.textContent = '‚Äî';
          if (els.lastWin) els.lastWin.textContent = '‚Äî';
          if (els.lastMult) els.lastMult.textContent = '‚Äî';
          if (els.lastTime) els.lastTime.textContent = '‚Äî';
          if (els.machineOutcome) els.machineOutcome.textContent = 'Awaiting spin‚Ä¶';
          if (els.hudWin) els.hudWin.textContent = currency.format(0);
          highlightWins([]);
          updateHud();
          return;
        }
        if (activeReelLocks > 0 || anyReelSpinning()) {
          pendingSpinResult = lastSpin;
          pendingWinGroups = lastSpin.winGroups || [];
          return;
        }
        const summary = formatWinSummary(lastSpin.winGroups) || lastSpin.outcome || '‚Äî';
        if (els.lastOutcome) els.lastOutcome.textContent = summary;
        const winAmount = lastSpin.winAmount || 0;
        state.lastWin = winAmount;
        if (els.lastWin) els.lastWin.textContent = currency.format(winAmount);
        if (els.lastMult) {
          const lines = Array.isArray(lastSpin.winGroups) ? lastSpin.winGroups.length : 0;
          els.lastMult.textContent = lines ? `${lines} line${lines === 1 ? '' : 's'}` : '‚Äî';
        }
        if (els.lastTime) els.lastTime.textContent = new Date(lastSpin.timestamp).toLocaleString();
        if (els.machineOutcome) {
          const note = lastSpin.retriggered ? ' (Retriggered)' : '';
          els.machineOutcome.textContent = `${lastSpin.outcome || summary}${note}`;
        }
        if (els.hudWin) els.hudWin.textContent = formatCompactMoney(winAmount);
        if (Array.isArray(lastSpin.drops) && lastSpin.drops.length) {
          recordDrops(lastSpin.drops, Date.parse(lastSpin.timestamp) || Date.now());
          renderInventory();
        }
        pendingWinGroups = lastSpin.winGroups || [];
        if (activeReelLocks === 0 && !anyReelSpinning()) {
          highlightWins(pendingWinGroups);
          pendingWinGroups = [];
        }
        pendingSpinResult = null;
      };

      const hydrateSession = async (session, logMessage) => {
        debug('hydrateSession', session);
        syncAuthFromPayload(session);
        if (session.snapshot) {
          await applySnapshot(session.snapshot, 'sync');
        }
        if (session.machine) {
          syncMachineDefinition(session.machine);
        }
        if (session.upgrades) {
          applyUpgradeState(session.upgrades);
        }
        updateStats(session);
        updateLastSpin(session.lastSpin);
        setGameVisibility(true);
        setStatus('Connected to AWS Lambda', 'ok');
        if (logMessage) {
          log(logMessage, `${session.username || 'User'} ‚Ä¢ balance ${currency.format(state.balance || session.balance)}`);
        }
        if (state.auth.token) startSessionSync();
      };

      const bootstrap = async () => {
        debug('bootstrap:start');
        if (!state.auth.token) {
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          debug('bootstrap:skipped', 'missing auth token');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const session = await request('/session');
          await hydrateSession(session, 'Session synced');
          startSessionSync();
        } catch (error) {
          console.error(error);
          setGameVisibility(false);
          setStatus('Offline ‚Äî check CloudWatch logs', 'error');
          showAlert(error.message || 'Unable to reach AWS.');
          log('Connection failed', error.message);
          debugError('bootstrap', error);
        } finally {
          debug('bootstrap:end');
          setBusy(false);
        }
      };

      const startAutoSpin = () => {
        if (!isAutoSpinUnlocked() || state.busy || !state.gameReady) return;
        state.autoSpin.active = true;
        state.autoSpin.remaining = getAutoSpinCount();
        renderAutoSpinButton();
        spin(true);
      };

      const spin = async (auto = false) => {
        debug('spin:click', { busy: state.busy, authed: !!state.auth.token });
        if (state.busy) return;
        if (!auto) {
          state.autoSpin.active = false;
          state.autoSpin.remaining = 0;
          renderAutoSpinButton();
        }
        collectPendingIdle();
        const baseRows = state.currentRows || state.machine.rows;
        const baseReels = state.currentReels || state.machine.reels;
        const settings = getUpgradeSettings();
        const modifiers = consumeSpinModifiers();
        const effectiveRows = clamp(baseRows, settings.baseRows || baseRows, settings.maxRows || baseRows);
        const effectiveReels = clamp(
          baseReels + (modifiers.extraReels || 0),
          settings.baseReels || baseReels,
          settings.maxReels || baseReels
        );
        const bet = clamp(state.bet || 1, 1, state.maxBet || DEFAULT_MAX_BET);
        if ((state.energy.current || 0) < 1) {
          showAlert('Out of energy.');
          return;
        }
        if (state.balance < bet) {
          showAlert('Not enough credits to spin.');
          return;
        }
        state.energy.current = Math.max(0, (state.energy.current || 0) - 1);
        state.energy.lastUpdate = performance.now();
        setBetValue(bet);
        setBusy(true);
        showAlert('');
        if (els.error) els.error.textContent = '';
        const prevLines = state.machine.lines;
        state.currentRows = effectiveRows;
        state.currentReels = effectiveReels;
        state.machine.lines = buildLinePatterns(effectiveRows, effectiveReels);
        ensureGrid(effectiveRows, effectiveReels);
        startGridSpin();
        let spinData = null;
        try {
          spinData = runClientSpin(bet, { rows: effectiveRows, reels: effectiveReels });
          state.balance = Math.max(0, (state.balance || 0) - bet + (spinData.winAmount || 0));
          state.lastWin = spinData.winAmount || 0;
          state.spinCount = (state.spinCount || 0) + 1;
          if (spinData.retriggered) {
            log('Retriggered spin', 'Free retry activated');
          }
          // Apply skill and jackpot modifiers
          let finalWin = spinData.winAmount || 0;
          const nowMs = Date.now();
          const payoutSkill = state.skills.payout;
          const payoutActive = payoutSkill.activeUntil && payoutSkill.activeUntil > nowMs;
          if (payoutActive) {
            finalWin = Math.round(finalWin * (payoutSkill.multiplier || 1));
          }
          if ((modifiers.payoutMult || 1) > 1) {
            finalWin = Math.round(finalWin * modifiers.payoutMult);
          }
          if (Math.random() < (state.jackpots.chance || 0.01)) {
            finalWin = Math.round(finalWin * (state.jackpots.multiplier || 10));
            log('Jackpot!', `√ó${state.jackpots.multiplier || 10} payout`);
          }
          if (finalWin > 0) {
            state.jackpots.hotStreak.wins += 1;
            if (state.jackpots.hotStreak.wins >= 3) {
              finalWin = Math.round(finalWin * (1 + state.jackpots.hotStreak.bonusPct));
            }
          } else {
            state.jackpots.hotStreak.wins = 0;
          }
          spinData.winAmount = finalWin;

          const dropResult = rollDropsForSpin(bet, finalWin || 0);
          if (dropResult.drops?.length) {
            applyDropsToInventory(dropResult.drops, Date.now());
          }
          const xpGain = Math.max(1, Math.round(bet / 10));
          const leveled = addMachineXp(state.machine.id, xpGain);
          if (els.balance) els.balance.textContent = currency.format(state.balance);
          if (els.spinCount) els.spinCount.textContent = state.spinCount;
          updateLastSpin(spinData);
          updateHud();
          renderBonusSummary();
          if (leveled) {
            log('Level up', `${state.machine.name || state.machine.id} Lv ${ensureMachineProgress(state.machine.id).lvl}`);
            renderMachineList();
          }
          log('Spin processed locally', `${spinData.outcome} (balance ${currency.format(state.balance)})`);
          markDirty('spin');
        } catch (error) {
          const msg = error?.message || 'Spin failed.';
          showAlert(msg);
          debugError('spin', error || new Error(msg));
          state.autoSpin.active = false;
          state.autoSpin.remaining = 0;
        } finally {
          stopGridSpin(spinData?.grid);
          await waitForReelsToSettle();
          state.currentRows = baseRows;
          state.currentReels = baseReels;
          state.machine.lines = prevLines;
          setBusy(false);
          if (state.autoSpin.active && state.autoSpin.remaining > 0) {
            state.autoSpin.remaining -= 1;
            renderAutoSpinButton();
            setTimeout(() => spin(true), 120);
          } else {
            state.autoSpin.active = false;
            state.autoSpin.remaining = 0;
            renderAutoSpinButton();
          }
        }
      };

      const claimDaily = async () => {
        debug('daily:claim', { busy: state.busy, ready: state.daily?.ready });
        if (!state.auth.token) {
          showAuthAlert('Sign in to claim daily rewards.');
          return;
        }
        if (state.daily?.claimedToday) {
          showAlert('Already claimed today.');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const result = await request('/daily', { action: 'claim' });
          updateStats(result);
          if (result.reward) {
            const drops = Array.isArray(result.reward.drops) ? result.reward.drops : [];
            if (drops.length) {
              applyDropsToInventory(drops, Date.now());
            }
            const parts = [];
            if (result.reward.vipMarks) parts.push(`+${result.reward.vipMarks} VIP marks`);
            if (result.reward.credits) parts.push(`+${currency.format(result.reward.credits)} credits`);
            drops.filter(drop => drop.type !== 'vipMarks').forEach(drop => {
              const info = normalizeDrop(drop);
              parts.push(`${info.name} √ó${drop.amount || 1}`);
            });
            log('Daily reward claimed', parts.join(' ‚Ä¢ '));
            markDirty('daily-claim');
          }
        } catch (error) {
          const payload = error.payload || {};
          if (payload.daily) {
            applyDailyState(payload.daily, payload.reward);
          }
          showAlert(error.message || 'Unable to claim daily reward.');
          debugError('daily:claim', error, { payload });
        } finally {
          setBusy(false);
          renderDaily();
          renderBonusSummary();
        }
      };

      const loginOrRegister = async () => {
        const email = (els.authEmail?.value || '').trim().toLowerCase();
        const password = els.authPassword?.value || '';
        debug('auth:submit', { mode: state.authMode, email, hasPassword: Boolean(password) });
        if (!email || !password) {
          showAuthAlert('Enter your email and password.');
          return;
        }
        if (state.authMode === 'register') {
          const confirm = (els.authConfirm?.value || '').trim();
          if (!confirm) {
            showAuthAlert('Please confirm your password.');
            return;
          }
          if (confirm !== password) {
            showAuthAlert('Passwords do not match.');
            return;
          }
        }
        showAuthAlert('');
        toggleAuthInputs(true);
        try {
          const endpoint = state.authMode === 'register' ? '/auth/register' : '/auth/login';
          const result = await request(endpoint, { username: email, password }, { skipAuth: true });
          await hydrateSession(result, state.authMode === 'register' ? 'Account created' : 'Signed in');
          showAuthAlert(state.authMode === 'register' ? 'Account created! Credits synced.' : 'Signed in successfully.');
          debug('auth:success', { endpoint });
        } catch (error) {
          if (error && error.status === 409 && state.authMode === 'register') {
            setAuthMode('login');
            showAuthAlert('Account already exists. Sign in instead.');
          } else {
            showAuthAlert(error.message || 'Unable to process request.');
          }
          log('Auth failed', error.message);
          debugError('auth', error);
        } finally {
          toggleAuthInputs(false);
        }
      };

      const logout = async () => {
        debug('auth:logout-click', { authed: !!state.auth.token });
        if (!state.auth.token) return;
        showAuthAlert('');
        if (els.logoutBtn) els.logoutBtn.disabled = true;
        try {
          await request('/auth/logout', {});
        } catch (error) {
          console.error(error);
          debugError('logout', error);
        } finally {
          if (els.logoutBtn) els.logoutBtn.disabled = false;
          setAuthState({});
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          log('Signed out', '');
          showAuthAlert('Signed out.');
        }
      };

      const deleteAccount = async () => {
        if (!state.auth.token) return;
        const confirmed = window.confirm('Delete your account and all slot progress? This cannot be undone.');
        debug('account:delete-click', { confirmed });
        if (!confirmed) return;
        showAuthAlert('');
        if (els.deleteBtn) els.deleteBtn.disabled = true;
        try {
          await request('/auth/delete', {});
          log('Account deleted', '');
          resetLocalProgress();
          clearLocalUpgradeState();
          resetAutoState();
          setAuthState({});
          setGameVisibility(false);
          setStatus('Account deleted', 'error');
          showAuthAlert('Account deleted. You can register again anytime.');
          toggleAccountSheet(false);
        } catch (error) {
          showAuthAlert(error.message || 'Unable to delete account right now.');
          log('Delete failed', error.message);
          debugError('delete-account', error);
        } finally {
          if (els.deleteBtn) els.deleteBtn.disabled = false;
        }
      };

      const grantDebugCoins = async () => {
        if (!state.auth.token) return;
        const email = (state.auth.username || '').toLowerCase();
        if (email !== DEBUG_EMAIL) return;
        debug('debug:grantCoins', email);
        setBusy(true);
        showAlert('');
        try {
          const result = await request('/session', { token: state.auth.token, action: 'debugCoins' });
          updateStats(result);
          log('Debug', '+100k credits granted.');
        } catch (error) {
          showAlert(error.message || 'Unable to grant coins.');
          debugError('debug-coins', error);
        } finally {
          setBusy(false);
        }
      };

      hydrateLocalCollections();
      loadGearDefinitions().then(() => {
        renderGear();
        renderBonusSummary();
      });
      loadCardDefinitions().then(() => {
        renderCards();
        renderBonusSummary();
      });
      updateAuthUI();
      ensureGrid(state.machine.rows, state.machine.reels);
      updateMachineMeta();
      renderPaytable();
      loadMachineConfig();
      renderDaily();
      renderBonusSummary();
      renderPayoutSkill();
      renderWorkerButton();
      updateHud();
      window.addEventListener('resize', applyMachineTheme);

      if (els.betSlider) {
        els.betSlider.addEventListener('input', (event) => {
          const idx = Number(event.target.value) || 0;
          const next = betFromIndex(idx);
          setBetValue(next);
        });
      }

      const handleChipAction = (action) => {
        debug('chip:action', { action, busy: state.busy, ready: state.gameReady });
        if (state.busy || !state.gameReady) return;
        const currentIndex = getNearestBetIndex(state.bet);
        if (action === 'increase') {
          setBetValue(betFromIndex(currentIndex + 1));
          return;
        }
        if (action === 'decrease') {
          setBetValue(betFromIndex(currentIndex - 1));
          return;
        }
        if (action === 'max') {
          setBetValue(state.maxBet || DEFAULT_MAX_BET);
        }
      };

      els.chipButtons.forEach(btn => {
        btn.addEventListener('click', () => handleChipAction(btn.dataset.chip));
      });

      els.dropRatesBtn?.addEventListener('click', () => {
        if (state.busy || !state.gameReady) return;
        toggleDropPanel();
      });

      els.dropSkillBtn?.addEventListener('click', () => {
        activateDropSkill();
      });
      els.payoutSkillBtn?.addEventListener('click', activatePayoutSkill);
      els.workerBtn?.addEventListener('click', toggleWorker);

      els.dropCloseBtn?.addEventListener('click', () => toggleDropPanel(false));
      els.dropPanel?.addEventListener('click', (event) => {
        const target = event.target;
        if (target === els.dropPanel) {
          toggleDropPanel(false);
        }
      });
      els.machineList?.addEventListener('click', (event) => {
        const card = event.target.closest('[data-machine-id]');
        if (!card || state.busy) return;
        const id = card.dataset.machineId;
        if (id) setActiveMachine(id);
      });
      els.dailyClaimBtn?.addEventListener('click', () => {
        if (state.busy) return;
        claimDaily();
      });

      els.gearPanel?.addEventListener('click', (event) => {
        const equipBtn = event.target.closest('[data-equip-id]');
        const unequipBtn = event.target.closest('[data-unequip-slot]');
        const upgradeBtn = event.target.closest('[data-upgrade-gear]');
        if (equipBtn) {
          equipGear(equipBtn.dataset.equipId);
        } else if (unequipBtn) {
          unequipGear(unequipBtn.dataset.unequipSlot);
        } else if (upgradeBtn) {
          upgradeGear(upgradeBtn.dataset.upgradeGear);
        }
      });

      els.cardPanel?.addEventListener('click', (event) => {
        const equipBtn = event.target.closest('[data-equip-card]');
        const unequipBtn = event.target.closest('[data-unequip-card]');
        const upgradeBtn = event.target.closest('[data-upgrade-card]');
        if (equipBtn) {
          const deck = Array.isArray(state.cards.deck) ? state.cards.deck : [];
          const slotIndex = deck.findIndex(id => !id);
          equipCard(equipBtn.dataset.equipCard, slotIndex >= 0 ? slotIndex : 0);
        } else if (unequipBtn) {
          unequipCard(Number(unequipBtn.dataset.unequipCard) || 0);
        } else if (upgradeBtn) {
          upgradeCard(upgradeBtn.dataset.upgradeCard);
        }
      });

      els.upgradeGrid?.addEventListener('click', (event) => {
        const button = event.target.closest('[data-upgrade]');
        if (!button || button.dataset.disabled === 'true') return;
        if (state.busy) return;
        purchaseUpgrade(button.dataset.upgrade);
      });

      els.spinBtn.addEventListener('click', spin);
      els.lineFlashBtn?.addEventListener('click', flashActiveLines);
      els.autoSpinBtn?.addEventListener('click', startAutoSpin);

      els.resetBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) {
          showAuthAlert('Sign in to use the slot machine.');
          return;
        }
        resetLocalProgress();
        bootstrap();
      });

      els.syncBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) return;
        syncSnapshot(true);
      });

      els.exportStateBtn?.addEventListener('click', exportStateKey);
      els.importStateBtn?.addEventListener('click', importStateKey);

      const purchaseUpgrade = async (type) => {
        const def = getUpgradeDef(type);
        if (!def) {
          showAlert('Upgrade unavailable.');
          return;
        }
        const clientOnly = Boolean(def.clientOnly);
        if (!clientOnly && !state.auth.token) {
          showAuthAlert('Sign in to upgrade your machine.');
          return;
        }
        const bucket = getMachineUpgrades(state.machine.id);
        const serverLevel = bucket?.[type] || 0;
        const currentLevel = getEffectiveUpgradeLevel(type);
        const maxLevel = getUpgradeMaxLevel(type);
        if (currentLevel >= maxLevel) {
          showAlert('Upgrade already maxed.');
          return;
        }
        if (def.requires) {
          const requirements = Array.isArray(def.requires) ? def.requires : [def.requires];
          const met = requirements.every(req => {
            return getEffectiveUpgradeLevel(req) > 0;
          });
          if (!met) {
            showAlert('Unlock the prerequisite upgrade first.');
            return;
          }
        }
        const localBucket = localUpgradeBucket();
        const localLevel = Math.max(0, Number(localBucket[type] || 0));
        if (localLevel >= maxLevel) {
          showAlert('Upgrade already maxed.');
          return;
        }
        const cost = computeUpgradeCost(def, currentLevel);
        if ((state.balance || 0) < cost) {
          showAlert(`Need ${currency.format(cost)} to upgrade.`);
          return;
        }
        // Legacy note for server builds: request('/session', { type }) would sync upgrades when online.
        state.balance = Math.max(0, (state.balance || 0) - cost);
        if (els.balance) els.balance.textContent = currency.format(state.balance);
        localBucket[type] = localLevel + 1;
        saveLocalUpgrades(localUpgrades);
        ensureMachineProgress(state.machine.id).upgrades = { ...bucket, [type]: serverLevel };
        applyUpgradeState(bucket);
        renderUpgrades();
        renderAutoSpinButton();
        updateHud();
        markDirty('upgrade');
        log('Upgrade applied locally', def.label || type);
        showAlert(clientOnly ? 'Upgrade applied locally.' : 'Upgrade applied locally (offline).');
      };

      if (els.authSubmit) {
        els.authSubmit.addEventListener('click', loginOrRegister);
      }
      (els.authTabs || []).forEach(btn => {
        btn.addEventListener('click', () => setAuthMode(btn.dataset.mode));
      });
      if (els.authInfo) {
        els.authInfo.addEventListener('click', () => {
          setAuthMode('register');
          els.authEmail?.focus();
        });
      }
      els.logoutBtn.addEventListener('click', logout);
      els.debugCoinBtn?.addEventListener('click', grantDebugCoins);
      els.deleteBtn?.addEventListener('click', deleteAccount);
      els.premiumBtn?.addEventListener('click', () => {
        showAlert('Premium shop is server-only. Coming soon.');
      });
      if (state.auth.token) {
        bootstrap();
      } else {
        setStatus('Sign in to start', 'error');
      }

      function rebuildSymbolWeights() {
        const pool = Array.isArray(state.machine.activeSymbols) && state.machine.activeSymbols.length
          ? state.machine.activeSymbols
          : Array.from(state.symbolMap.keys());
        const entries = [];
        let total = 0;
        pool.forEach(key => {
          const payout = state.machine.payouts?.[key] || 1;
          const weight = Math.max(1, Math.trunc(1000 / Math.max(1, payout)));
          total += weight;
          entries.push({ key, weight, total });
        });
        state.symbolWeights = { entries, total };
        debug('symbols:weights', { count: entries.length, total });
      }

      rebuildSymbolWeights();
    })();
  </script>
</body>
</html>
