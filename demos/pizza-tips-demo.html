<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <base href="/">
  <title>Pizza Tips Regression Map</title>
  <meta name="description" content="Estimate pizza tips by clicking a delivery map, adjusting weather, order time, and wait time." />
  <meta name="theme-color" content="#0D1117" />
  <link rel="icon" href="data:," />
  <link rel="stylesheet" href="dist/styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Poppins:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/vendor/leaflet/leaflet.css" />
  <style>
    :root {
      --radius: 14px;
      --shadow-1: 0 2px 10px rgba(0,0,0,.08), 0 1px 4px rgba(0,0,0,.08);
      --shadow-2: 0 10px 32px rgba(0,0,0,.16), 0 2px 10px rgba(0,0,0,.12);
      --muted: var(--text-muted, #aeb6c2);
      --text: var(--text-light, #f1f4f8);
      --surface-2: var(--surface-light, #1c2231);
      --page-pad: clamp(12px, 3vw, 24px);
      --accent: var(--primary, #2bbbad);
      --accent-2: color-mix(in srgb, var(--accent) 75%, #6adac6 25%);
      --border: var(--surface-accent, #222838);
      --danger: #e15b64;
      --success: #3cbf88;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    html[data-embedded="true"],
    html[data-embedded="true"] body { height: auto !important; min-height: 0 !important; }
    html[data-embedded="true"] {
      --page-pad: clamp(8px, 2vw, 16px);
    }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 500px at 50% -10%, color-mix(in srgb, var(--primary) 15%, transparent), transparent 60%)
        var(--bg, #0d1117);
      display: grid;
      place-items: start center;
      padding: var(--page-pad);
      overflow-x: hidden;
    }
    .card {
      width: min(100%, 1120px);
      background: var(--surface, #141a24);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-2);
      overflow: hidden;
    }
    .card-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 16px 18px;
      background: linear-gradient(0deg, var(--surface, #141a24), var(--surface-2));
      border-bottom: 1px solid var(--border);
    }
    .header-copy {
      min-width: 0;
      display: grid;
      gap: 6px;
    }
    .title {
      margin: 0;
      font-family: Poppins, Inter, system-ui, sans-serif;
      font-weight: 600;
      font-size: clamp(1.1rem, 2.2vw, 1.35rem);
    }
    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: .9rem;
      max-width: 60ch;
    }
    .health-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 8px 16px 0;
    }
    .health-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: .7rem;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted);
      background: var(--surface-2);
    }
    .health-pill::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }
    .health-pill[data-state="ok"] {
      color: var(--success);
      border-color: color-mix(in srgb, var(--success) 65%, var(--border) 35%);
    }
    .health-pill[data-state="err"] {
      color: var(--danger);
      border-color: color-mix(in srgb, var(--danger) 65%, var(--border) 35%);
    }
    .health-pill[data-state="warming"] {
      color: var(--warning, #f3b550);
      border-color: color-mix(in srgb, var(--warning, #f3b550) 65%, var(--border) 35%);
    }
    .section {
      padding: 18px;
    }
    .section + .section {
      border-top: 1px solid var(--border);
    }
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: minmax(260px, 1.1fr) minmax(280px, 1fr);
    }
    .panel {
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: var(--shadow-1);
    }
    .map-panel {
      display: grid;
      gap: 10px;
    }
    #map {
      height: 360px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .map-meta {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 12px;
      font-size: .85rem;
      color: var(--muted);
    }
    .map-meta span {
      width: 100%;
      text-align: center;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.04);
      border: 1px solid var(--border);
    }
    .heat-legend {
      background: rgba(12, 16, 24, 0.92);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: var(--shadow-1);
      color: var(--text);
      font-size: .78rem;
      min-width: 160px;
    }
    .heat-legend-title {
      text-transform: uppercase;
      letter-spacing: .08em;
      font-size: .7rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .heat-legend-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .heat-legend-bar {
      flex: 1;
      height: 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: linear-gradient(90deg, #123548, #2bbbad, #f8b500, #e15b64);
    }
    form {
      display: grid;
      gap: 12px;
    }
    label {
      font-size: .85rem;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }
    input[type="text"],
    input[type="number"],
    select {
      width: 100%;
      background: var(--surface-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: .95rem;
      outline: none;
    }
    .input-row {
      display: grid;
      gap: 8px;
    }
    .inline-fields {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }
    .range-row {
      display: grid;
      gap: 6px;
    }
    .range-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: .85rem;
      color: var(--muted);
    }
    .range-number input {
      width: 90px;
      text-align: right;
    }
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.18));
      border: 1px solid var(--border);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      border: 1px solid rgba(255,255,255,.3);
      box-shadow: var(--shadow-1);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      border: 1px solid rgba(255,255,255,.3);
      box-shadow: var(--shadow-1);
      cursor: pointer;
    }
    .actions {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 12px;
    }
    .actions .btn {
      width: 100%;
      min-width: 0;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-width: 180px;
      padding: 12px 18px;
      border-radius: 10px;
      border: 1px solid color-mix(in srgb, var(--accent) 85%, #fff 15%);
      color: var(--bg, #0d1117);
      font-weight: 600;
      letter-spacing: .01em;
      background: linear-gradient(180deg, color-mix(in srgb, var(--accent) 95%, #fff 5%), color-mix(in srgb, var(--accent) 75%, #000 25%));
      cursor: pointer;
    }
    .btn.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
      font-weight: 500;
    }
    .btn:disabled {
      opacity: .6;
      cursor: not-allowed;
    }
    .results {
      display: grid;
      gap: 14px;
    }
    .result-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .result-card {
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 14px;
      background: rgba(255,255,255,.02);
      display: grid;
      gap: 8px;
    }
    .result-label {
      font-size: .85rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .08em;
    }
    .result-value {
      font-size: 1.4rem;
      font-weight: 600;
    }
    .result-meta {
      font-size: .85rem;
      color: var(--muted);
    }
    .warning {
      color: var(--danger);
      font-size: .9rem;
    }
    .tip-breakdown {
      padding: 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,.02);
      display: grid;
      gap: 8px;
    }
    .breakdown-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 6px;
      font-size: .9rem;
    }
    .breakdown-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
    }
    .breakdown-list span {
      color: var(--muted);
    }
    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
      #map {
        height: 300px;
      }
    }

    @media (max-width: 600px) {
      :root {
        --page-pad: 10px;
      }
      .card-header {
        padding: 16px;
      }
      .headline {
        min-width: 0;
      }
      .section {
        padding: 16px;
      }
      h1 {
        font-size: 1.2rem;
      }
      .subhead {
        font-size: .85rem;
      }
      .status {
        justify-content: flex-start;
      }
      .actions {
        grid-template-columns: 1fr;
      }
      .btn {
        width: 100%;
        min-width: 0;
      }
      .range-head {
        flex-wrap: wrap;
        gap: 6px;
      }
      .result-grid {
        grid-template-columns: 1fr;
      }
      #map {
        height: 240px;
      }
      .map-meta {
        gap: 8px;
      }
      .heat-legend {
        width: 100%;
        min-width: 0;
      }
    }
  </style>
  <script>
    if (window.self !== window.top) {
      document.documentElement.setAttribute('data-embedded', 'true');
    }
  </script>
</head>
<body>
  <script>
    (function () {
      var CHANNEL = 'pizza-demo-resize';
      function calcHeight() {
        var doc = document.documentElement;
        var body = document.body || doc;
        return Math.ceil(Math.max(
          body.scrollHeight,
          body.offsetHeight,
          doc.clientHeight,
          doc.scrollHeight,
          doc.offsetHeight
        ));
      }
      function postHeight() {
        try { parent.postMessage({ type: CHANNEL, height: calcHeight() }, '*'); } catch (e) {}
      }
      window.addEventListener('load', postHeight);
      try { document.fonts?.ready?.then(postHeight); } catch (e) {}
      if ('ResizeObserver' in window) {
        var ro = new ResizeObserver(function () { postHeight(); });
        ro.observe(document.documentElement);
      } else {
        var prev = 0;
        setInterval(function () {
          var h = calcHeight();
          if (Math.abs(h - prev) > 4) {
            prev = h;
            postHeight();
          }
        }, 750);
      }
    })();
  </script>
  <main id="main" class="card">
    <header class="card-header">
      <div class="header-copy">
        <h1 class="title">Pizza Tips Regression</h1>
        <p class="subtitle">Click the map, set the scenario, and estimate tip amount + percentage.</p>
      </div>
    </header>
    <div class="health-row" role="status" aria-live="polite">
      <span class="health-pill" id="api-status" data-state="warming">Warming up</span>
    </div>

    <section class="section">
      <div class="grid">
        <div class="panel map-panel">
          <div id="map" aria-label="Delivery map"></div>
          <div class="map-meta">
            <span id="lat-display">Lat: --</span>
            <span id="lon-display">Lon: --</span>
            <span id="city-display">City: --</span>
            <span id="hour-display">Hour: --</span>
          </div>
        </div>

        <form id="scenario-form" class="panel" autocomplete="off">
          <input id="lat" type="hidden" />
          <input id="lon" type="hidden" />

          <div class="inline-fields">
            <div class="input-row">
              <label for="confidence">Confidence</label>
              <select id="confidence"></select>
            </div>
            <div class="input-row" data-feature="housing">
              <label for="housing">Housing</label>
              <select id="housing"></select>
            </div>
            <div class="input-row" data-feature="orderHour">
              <label for="order-hour">Order Time</label>
              <select id="order-hour"></select>
            </div>
            <div class="input-row" data-feature="cost">
              <label for="cost">Order Cost ($)</label>
              <input id="cost" type="number" min="0" step="0.01" />
            </div>
          </div>

          <div class="range-row" data-feature="deliveryMinutes">
            <div class="range-head">
              <span>Delivery Wait (minutes)</span>
              <div class="range-number">
                <input id="delivery-number" type="number" min="0" step="1" />
              </div>
            </div>
            <input id="delivery" type="range" min="0" max="135" step="1" />
          </div>

          <div class="inline-fields">
            <div class="input-row" data-feature="rain">
              <label for="rain">Rain (inches)</label>
              <input id="rain" type="number" min="0" step="0.01" />
            </div>
            <div class="input-row" data-feature="maxTemp">
              <label for="max-temp">Max Temp (F)</label>
              <input id="max-temp" type="number" step="1" />
            </div>
            <div class="input-row" data-feature="minTemp">
              <label for="min-temp">Min Temp (F)</label>
              <input id="min-temp" type="number" step="1" />
            </div>
          </div>

          <div class="actions">
            <button class="btn" type="submit" id="predict">Estimate Tip</button>
            <button class="btn secondary" type="button" id="reset">Reset</button>
          </div>
        </form>
      </div>
    </section>

    <section class="section results" aria-live="polite">
      <div class="result-grid">
        <div class="result-card">
          <div class="result-label">Tip (Amount)</div>
          <div class="result-value" id="tip-amount">--</div>
          <div class="result-meta" id="tip-interval">Confidence: --</div>
        </div>
        <div class="result-card">
          <div class="result-label">Tip (Percent)</div>
          <div class="result-value" id="tip-percent">--</div>
          <div class="result-meta" id="tip-percent-interval">Confidence: --</div>
        </div>
      </div>
      <div id="warnings" class="warning"></div>
      <div class="tip-breakdown">
        <div class="result-label">Tip Amount Breakdown</div>
        <ul class="breakdown-list" id="tip-breakdown"></ul>
      </div>
    </section>
  </main>

  <script src="js/vendor/leaflet/leaflet.js"></script>
  <script src="js/vendor/leaflet/leaflet-heat.js"></script>
  <script src="js/demos/pizza-tips-meta.js"></script>
  <script src="js/demos/aws-client.js"></script>
  <script type="module">
    const DEFAULT_FN_URL = 'https://2d6lrg4ozy564xymwi2epjbqty0nvhje.lambda-url.us-east-2.on.aws/';
    const STORAGE_KEY = "demo.endpoint.pizza";
    const { resolveEndpoint, listCandidates, postWithFallback, rememberEndpoint } = window.DemoAws;
    const META = window.PizzaTipsMeta || {};
    const MAP_BOUNDS = META.bounds
      ? {
        latMin: META.bounds.latitude.min,
        latMax: META.bounds.latitude.max,
        lonMin: META.bounds.longitude.min,
        lonMax: META.bounds.longitude.max
      }
      : {
        latMin: 33.0130544,
        latMax: 33.1949433,
        lonMin: -96.93078218,
        lonMax: -96.7145982
      };
    const CITY_BOUNDARIES = META.cityBoundaries || null;
    const HOUSING_OPTIONS = META.housingOptions || ['Residential'];
    const HOUSING_BASELINE = META.housingBaseline || HOUSING_OPTIONS[0];
    const INPUT_FEATURES = META.inputFeatures || ['cost', 'orderHour', 'deliveryMinutes', 'rain', 'maxTemp', 'minTemp'];
    const ACTIVE_FEATURES = new Set(INPUT_FEATURES);
    const USE_HOUSING = META.useHousing !== false;
    const DEFAULTS = {
      latitude: 33.110288,
      longitude: -96.824164,
      confidenceLevel: 0.8,
      cost: 35,
      housing: HOUSING_BASELINE,
      orderHour: 18,
      deliveryMinutes: 40,
      rain: 0,
      maxTemp: 85,
      minTemp: 65
    };
    const CONFIDENCE_LEVELS = [0.8, 0.85, 0.9, 0.95];
    const HEATMAP_GRID = { rows: 24, cols: 24 };
    const BREAKDOWN_LABELS = {
      baseline: 'Baseline',
      cost: 'Order Cost',
      orderHour: 'Order Hour',
      deliveryMinutes: 'Delivery Minutes',
      rain: 'Rain',
      maxTemp: 'Max Temp',
      minTemp: 'Min Temp'
    };

    const endpointConfig = { defaultUrl: DEFAULT_FN_URL, storageKey: STORAGE_KEY };
    const candidates = () => listCandidates(endpointConfig);
    const API_URL = resolveEndpoint(endpointConfig);
    const statusEl = document.getElementById('api-status');
    const latInput = document.getElementById('lat');
    const lonInput = document.getElementById('lon');
    const confidenceSelect = document.getElementById('confidence');
    const costInput = document.getElementById('cost');
    const housingSelect = document.getElementById('housing');
    const orderHourSelect = document.getElementById('order-hour');
    const deliveryInput = document.getElementById('delivery');
    const deliveryNumber = document.getElementById('delivery-number');
    const rainInput = document.getElementById('rain');
    const maxTempInput = document.getElementById('max-temp');
    const minTempInput = document.getElementById('min-temp');
    const form = document.getElementById('scenario-form');
    const resetBtn = document.getElementById('reset');
    const predictBtn = document.getElementById('predict');

    const latDisplay = document.getElementById('lat-display');
    const lonDisplay = document.getElementById('lon-display');
    const cityDisplay = document.getElementById('city-display');
    const hourDisplay = document.getElementById('hour-display');

    const tipAmountEl = document.getElementById('tip-amount');
    const tipIntervalEl = document.getElementById('tip-interval');
    const tipPercentEl = document.getElementById('tip-percent');
    const tipPercentIntervalEl = document.getElementById('tip-percent-interval');
    const warningsEl = document.getElementById('warnings');
    const tipBreakdownList = document.getElementById('tip-breakdown');
    let heatLayer = null;
    let legendMinEl = null;
    let legendMaxEl = null;
    let serverReady = false;

    function setStatus(state, text) {
      if (!statusEl) return;
      statusEl.dataset.state = state || '';
      statusEl.textContent = text;
    }

    function setServerReady(ready) {
      serverReady = ready;
      if (predictBtn) predictBtn.disabled = !ready;
    }

    function formatCurrency(value) {
      if (!Number.isFinite(value)) return '--';
      return `$${value.toFixed(2)}`;
    }

    function formatPercent(value) {
      if (!Number.isFinite(value)) return '--';
      return `${(value * 100).toFixed(1)}%`;
    }

    function formatSignedCurrency(value) {
      if (!Number.isFinite(value)) return '--';
      const sign = value < 0 ? '-' : '+';
      return `${sign}${formatCurrency(Math.abs(value))}`;
    }

    function formatBreakdownLabel(key) {
      if (BREAKDOWN_LABELS[key]) return BREAKDOWN_LABELS[key];
      if (key.startsWith('city:')) return `City: ${key.slice(5)}`;
      if (key.startsWith('housing:')) return `Housing: ${key.slice(8)}`;
      return key;
    }

    function buildTipBreakdown(result) {
      const breakdown = result.breakdown?.tip;
      if (!breakdown || !Array.isArray(breakdown.items)) return [];
      const items = breakdown.items;
      const scale = breakdown.scale || 'none';
      const output = [];
      if (scale === 'log1p' && items.length) {
        let cumulative = 0;
        let start = 0;
        if (items[0].key === 'intercept') {
          cumulative = items[0].contribution;
          const baseTip = Math.expm1(cumulative);
          output.push({ key: 'baseline', contribution: baseTip });
          start = 1;
        }
        for (let i = start; i < items.length; i++) {
          const prevTip = Math.expm1(cumulative);
          cumulative += items[i].contribution;
          const nextTip = Math.expm1(cumulative);
          const delta = nextTip - prevTip;
          if (Math.abs(delta) > 1e-4) {
            output.push({ key: items[i].key, contribution: delta });
          }
        }
        return output;
      }
      items.forEach((item) => {
        const key = item.key === 'intercept' ? 'baseline' : item.key;
        if (Math.abs(item.contribution) > 1e-4 || key === 'baseline') {
          output.push({ key, contribution: item.contribution });
        }
      });
      return output;
    }

    function renderTipBreakdown(result) {
      if (!tipBreakdownList) return;
      tipBreakdownList.innerHTML = '';
      const items = buildTipBreakdown(result);
      if (!items.length) {
        const li = document.createElement('li');
        li.textContent = 'No contributing factors for this scenario.';
        tipBreakdownList.appendChild(li);
        return;
      }
      items.forEach((entry) => {
        const li = document.createElement('li');
        const label = document.createElement('span');
        label.textContent = formatBreakdownLabel(entry.key);
        const value = document.createElement('strong');
        value.textContent = entry.key === 'baseline'
          ? formatCurrency(entry.contribution)
          : formatSignedCurrency(entry.contribution);
        li.append(label, value);
        tipBreakdownList.appendChild(li);
      });
    }

    function updateHeatmap(heatmap) {
      if (!heatLayer) return;
      if (!heatmap || !Array.isArray(heatmap.points) || !heatmap.points.length) {
        heatLayer.setLatLngs([]);
        updateLegend(null, null);
        return;
      }
      const min = Number(heatmap.min);
      const max = Number(heatmap.max);
      const range = max - min || 1;
      const points = heatmap.points.map((pt) => {
        const value = (pt.tip - min) / range;
        const intensity = Math.max(0, Math.min(1, value));
        return [pt.lat, pt.lon, intensity];
      });
      heatLayer.setLatLngs(points);
      updateLegend(min, max);
    }

    function updateLegend(min, max) {
      if (!legendMinEl || !legendMaxEl) return;
      if (!Number.isFinite(min) || !Number.isFinite(max)) {
        legendMinEl.textContent = '--';
        legendMaxEl.textContent = '--';
        return;
      }
      legendMinEl.textContent = formatCurrency(min);
      legendMaxEl.textContent = formatCurrency(max);
    }

    function populateHousing() {
      housingSelect.innerHTML = '';
      HOUSING_OPTIONS.forEach((name) => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        if (name === DEFAULTS.housing) opt.selected = true;
        housingSelect.appendChild(opt);
      });
    }

    function populateConfidence() {
      confidenceSelect.innerHTML = '';
      CONFIDENCE_LEVELS.forEach((level) => {
        const opt = document.createElement('option');
        opt.value = level;
        opt.textContent = `${Math.round(level * 100)}%`;
        if (level === DEFAULTS.confidenceLevel) opt.selected = true;
        confidenceSelect.appendChild(opt);
      });
    }

    function applyFeatureVisibility() {
      document.querySelectorAll('[data-feature]').forEach((el) => {
        const key = el.dataset.feature;
        const isActive = key === 'housing' ? USE_HOUSING : ACTIVE_FEATURES.has(key);
        el.style.display = isActive ? '' : 'none';
      });
      hourDisplay.style.display = ACTIVE_FEATURES.has('orderHour') ? '' : 'none';
    }

    function resolveCityLocal(lat, lon) {
      if (!CITY_BOUNDARIES || !Array.isArray(CITY_BOUNDARIES.features)) {
        return { city: null };
      }
      const point = [lon, lat];
      for (const feature of CITY_BOUNDARIES.features) {
        if (pointInGeometry(point, feature.geometry)) {
          return { city: feature.properties?.city || null };
        }
      }
      return { city: null };
    }

    function pointInRing(point, ring) {
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const xi = ring[i][0];
        const yi = ring[i][1];
        const xj = ring[j][0];
        const yj = ring[j][1];
        const intersect = ((yi > point[1]) !== (yj > point[1]))
          && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function pointInPolygon(point, rings) {
      if (!rings.length || !pointInRing(point, rings[0])) return false;
      for (let i = 1; i < rings.length; i++) {
        if (pointInRing(point, rings[i])) return false;
      }
      return true;
    }

    function pointInGeometry(point, geometry) {
      if (!geometry) return false;
      if (geometry.type === 'Polygon') {
        return pointInPolygon(point, geometry.coordinates || []);
      }
      if (geometry.type === 'MultiPolygon') {
        return (geometry.coordinates || []).some((rings) => pointInPolygon(point, rings));
      }
      return false;
    }

    function populateHours() {
      const hours = [];
      for (let h = 11; h <= 21; h++) hours.push(h);
      orderHourSelect.innerHTML = '';
      hours.forEach((h) => {
        const opt = document.createElement('option');
        opt.value = h;
        opt.textContent = formatHour(h);
        if (h === DEFAULTS.orderHour) opt.selected = true;
        orderHourSelect.appendChild(opt);
      });
    }

    function formatHour(hourValue) {
      const hour = Number(hourValue);
      if (!Number.isFinite(hour)) return '--';
      const period = hour >= 12 ? 'PM' : 'AM';
      const displayHour = hour % 12 === 0 ? 12 : hour % 12;
      return `${displayHour}:00 ${period}`;
    }

    function syncDeliveryValue() {
      deliveryNumber.value = deliveryInput.value;
    }

    function updateMapMeta() {
      const lat = Number(latInput.value);
      const lon = Number(lonInput.value);
      latDisplay.textContent = `Lat: ${lat.toFixed(5)}`;
      lonDisplay.textContent = `Lon: ${lon.toFixed(5)}`;
      const resolved = resolveCityLocal(lat, lon);
      cityDisplay.textContent = resolved.city ? `City: ${resolved.city}` : 'City: Outside coverage';
      if (ACTIVE_FEATURES.has('orderHour')) {
        hourDisplay.textContent = `Time: ${formatHour(orderHourSelect.value)}`;
      }
    }

    function setInputs(data) {
      latInput.value = data.latitude.toFixed(6);
      lonInput.value = data.longitude.toFixed(6);
      confidenceSelect.value = data.confidenceLevel ?? DEFAULTS.confidenceLevel;
      costInput.value = data.cost;
      housingSelect.value = data.housing;
      orderHourSelect.value = data.orderHour;
      deliveryInput.value = data.deliveryMinutes;
      deliveryNumber.value = data.deliveryMinutes;
      rainInput.value = data.rain;
      maxTempInput.value = data.maxTemp;
      minTempInput.value = data.minTemp;
      syncDeliveryValue();
      updateMapMeta();
    }


    const postToEndpoint = (urlBase, payload) => postWithFallback(urlBase, ['', 'predict'], payload);

    function currentPayload(includeGrid = false) {
      const confidenceValue = Number(confidenceSelect.value) || DEFAULTS.confidenceLevel;
      const payload = {
        latitude: Number(latInput.value),
        longitude: Number(lonInput.value),
        confidenceLevel: confidenceValue
      };
      if (ACTIVE_FEATURES.has('cost')) payload.cost = Number(costInput.value);
      if (USE_HOUSING) payload.housing = housingSelect.value;
      if (ACTIVE_FEATURES.has('orderHour')) payload.orderHour = Number(orderHourSelect.value);
      if (ACTIVE_FEATURES.has('deliveryMinutes')) payload.deliveryMinutes = Number(deliveryNumber.value);
      if (ACTIVE_FEATURES.has('rain')) payload.rain = Number(rainInput.value);
      if (ACTIVE_FEATURES.has('maxTemp')) payload.maxTemp = Number(maxTempInput.value);
      if (ACTIVE_FEATURES.has('minTemp')) payload.minTemp = Number(minTempInput.value);
      if (includeGrid) {
        payload.grid = {
          rows: HEATMAP_GRID.rows,
          cols: HEATMAP_GRID.cols,
          bounds: {
            latMin: MAP_BOUNDS.latMin,
            latMax: MAP_BOUNDS.latMax,
            lonMin: MAP_BOUNDS.lonMin,
            lonMax: MAP_BOUNDS.lonMax
          }
        };
      }
      return payload;
    }

    async function warmUpServer() {
      setServerReady(false);
      setStatus('warming', 'Warming AWS...');
      const endpoints = candidates();
      if (!endpoints.length) {
        setStatus('err', 'No endpoint');
        return;
      }
      const payload = currentPayload(false);
      let lastErr = null;
      for (const base of endpoints) {
        try {
          await postToEndpoint(base, payload);
          rememberEndpoint(base, STORAGE_KEY);
          setServerReady(true);
          setStatus('ok', 'Ready');
          return;
        } catch (err) {
          lastErr = err;
        }
      }
      setServerReady(false);
      setStatus('err', 'Unavailable');
      if (lastErr) console.error(lastErr);
    }

    function applyResponse(result) {
      const tip = result.predictions?.tip?.value;
      const tipInterval = result.predictions?.tip?.interval;
      const tipPercent = result.predictions?.tipPercent?.value;
      const tipPercentInterval = result.predictions?.tipPercent?.interval;
      if (result.bucket?.city) {
        cityDisplay.textContent = `City: ${result.bucket.city}`;
      }

      tipAmountEl.textContent = formatCurrency(tip);
      tipPercentEl.textContent = formatPercent(tipPercent);

      if (tipInterval) {
        tipIntervalEl.textContent = `Confidence ${(tipInterval.level * 100).toFixed(0)}%: ${formatCurrency(tipInterval.low)} to ${formatCurrency(tipInterval.high)}`;
      }
      if (tipPercentInterval) {
        tipPercentIntervalEl.textContent = `Confidence ${(tipPercentInterval.level * 100).toFixed(0)}%: ${formatPercent(tipPercentInterval.low)} to ${formatPercent(tipPercentInterval.high)}`;
      }

      warningsEl.textContent = (result.warnings || []).join(' ');

      updateHeatmap(result.heatmap);
      renderTipBreakdown(result);
    }

    populateHours();
    populateHousing();
    populateConfidence();
    applyFeatureVisibility();
    setServerReady(false);
    setStatus(API_URL ? 'warming' : 'err', API_URL ? 'Warming AWS...' : 'Unavailable');
    setInputs(DEFAULTS);
    if (API_URL) {
      warmUpServer();
    }

    const map = L.map('map', { zoomControl: true });
    const bounds = [
      [MAP_BOUNDS.latMin, MAP_BOUNDS.lonMin],
      [MAP_BOUNDS.latMax, MAP_BOUNDS.lonMax]
    ];
    map.fitBounds(bounds, { padding: [20, 20] });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    heatLayer = L.heatLayer([], {
      radius: 26,
      blur: 22,
      minOpacity: 0.25,
      gradient: {
        0.0: '#123548',
        0.4: '#2bbbad',
        0.7: '#f8b500',
        1.0: '#e15b64'
      }
    }).addTo(map);

    const legendControl = L.control({ position: 'bottomright' });
    legendControl.onAdd = () => {
      const div = L.DomUtil.create('div', 'heat-legend');
      div.innerHTML = `
        <div class="heat-legend-title">Predicted Tip Hotspots</div>
        <div class="heat-legend-row">
          <span data-legend="min">--</span>
          <div class="heat-legend-bar"></div>
          <span data-legend="max">--</span>
        </div>
      `;
      legendMinEl = div.querySelector('[data-legend="min"]');
      legendMaxEl = div.querySelector('[data-legend="max"]');
      L.DomEvent.disableClickPropagation(div);
      return div;
    };
    legendControl.addTo(map);

    if (CITY_BOUNDARIES) {
      L.geoJSON(CITY_BOUNDARIES, {
        style: () => ({
          color: '#2bbbad',
          weight: 2,
          fillOpacity: 0.08
        })
      }).addTo(map);
    }

    const marker = L.marker([DEFAULTS.latitude, DEFAULTS.longitude], { draggable: true }).addTo(map);

    function setLatLon(lat, lon) {
      latInput.value = lat.toFixed(6);
      lonInput.value = lon.toFixed(6);
      marker.setLatLng([lat, lon]);
      updateMapMeta();
    }

    map.on('click', (evt) => {
      setLatLon(evt.latlng.lat, evt.latlng.lng);
    });

    marker.on('dragend', (evt) => {
      const pos = evt.target.getLatLng();
      setLatLon(pos.lat, pos.lng);
    });

    [latInput, lonInput, orderHourSelect].forEach((el) => {
      el.addEventListener('change', () => {
        const lat = Number(latInput.value);
        const lon = Number(lonInput.value);
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          marker.setLatLng([lat, lon]);
        }
        updateMapMeta();
      });
    });

    deliveryInput.addEventListener('input', syncDeliveryValue);
    deliveryNumber.addEventListener('input', () => {
      deliveryInput.value = deliveryNumber.value;
      syncDeliveryValue();
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      if (!API_URL) {
        setStatus('err', 'Unavailable');
        return;
      }
      if (!serverReady) {
        setStatus('warming', 'Warming AWS...');
        return;
      }
      const lat = Number(latInput.value);
      const lon = Number(lonInput.value);
      const resolved = resolveCityLocal(lat, lon);
      if (!resolved.city) {
        setStatus('err', 'Unavailable');
        warningsEl.textContent = 'Choose a point inside the delivery cities to estimate tips.';
        return;
      }
      try {
        const result = await postToEndpoint(API_URL, currentPayload(true));
        applyResponse(result);
        setStatus('ok', 'Ready');
      } catch (err) {
        console.error(err);
        setStatus('err', 'Error');
        warningsEl.textContent = String(err.message || err);
      }
    });

    resetBtn.addEventListener('click', () => {
      setInputs(DEFAULTS);
      setLatLon(DEFAULTS.latitude, DEFAULTS.longitude);
      warningsEl.textContent = '';
      updateHeatmap(null);
      if (tipBreakdownList) {
        tipBreakdownList.innerHTML = '';
      }
    });

    syncDeliveryValue();
    updateMapMeta();
  </script>
</body>
</html>
