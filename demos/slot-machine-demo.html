<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <base href="/">
  <title>Server-Backed Slot Machine Demo</title>
  <meta name="theme-color" content="#0d1117" />
  <link rel="stylesheet" href="dist/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500&display=swap" />
  <style>
    :root {
      --app-vh: 1vh;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      color-scheme: light dark;
      --bg: #020617;
      --panel: color-mix(in srgb, var(--surface, #0f172a) 90%, black 10%);
      --panel-border: color-mix(in srgb, var(--surface-accent, #1e293b) 70%, transparent);
      --text: var(--text-light, #e2e8f0);
      --muted: color-mix(in srgb, var(--text) 65%, transparent);
      --accent: #facc15;
      --accent-2: #6366f1;
      --danger: #f87171;
      --radius: 16px;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 800px at 12% -10%, rgba(99, 102, 241, .14), transparent 55%),
        radial-gradient(1000px 700px at 88% 0%, rgba(14, 165, 233, .12), transparent 55%),
        linear-gradient(180deg, #010915, var(--bg));
      color: var(--text);
      padding: clamp(20px, 3vw, 36px);
      display: block;
      overflow-y: auto;
    }
    html[data-embedded="true"] body {
      display: block;
    }
    main {
      width: min(1100px, 100%);
      background: color-mix(in srgb, var(--panel) 90%, #0b1224 10%);
      border: 1px solid color-mix(in srgb, var(--panel-border) 70%, transparent);
      border-radius: 22px;
      box-shadow: 0 24px 120px rgba(2, 6, 23, .72);
      padding: clamp(24px, 3vw, 36px);
      display: grid;
      gap: 28px;
      margin: 0 auto;
    }
    header h1 {
      font-family: "Space Grotesk", Inter, sans-serif;
      font-size: clamp(1.75rem, 3vw, 2.5rem);
      margin: 0 0 8px;
    }
    header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: .9rem;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 60%, transparent);
      background: rgba(99, 102, 241, .12);
    }
    .status-pill.ghost {
      background: rgba(255,255,255,.12);
      border-color: rgba(255,255,255,.2);
      color: rgba(255,255,255,.85);
    }
    .status-pill[data-state="error"] {
      color: var(--danger);
      background: rgba(244, 114, 182, .1);
    }
    .grid {
      display: grid;
      gap: 16px;
    }
    .grid-two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .panel {
      border-radius: 18px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 55%, transparent);
      padding: 18px 20px;
      background: color-mix(in srgb, rgba(15, 23, 42, .9) 90%, rgba(6, 11, 22, .92) 10%);
      box-shadow: 0 16px 60px rgba(2, 6, 23, .5);
    }
    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      font-weight: 600;
    }
    dl {
      margin: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 16px;
      font-size: .95rem;
    }
    dt {
      color: var(--muted);
      font-weight: 500;
    }
    dd {
      margin: 0;
      font-weight: 600;
    }
    .reels {
      display: grid;
      grid-template-columns: repeat(3, minmax(80px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .slot-cell {
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, white 12%, transparent);
      display: grid;
      place-items: center;
      font-size: 2.75rem;
      background: rgba(15, 23, 42, .8);
      box-shadow: inset 0 0 30px rgba(0,0,0,.3);
      transition: transform .45s cubic-bezier(.34, 1.56, .64, 1);
    }
    .slot-cell.spin {
      transform: scale(1.08) rotateX(360deg);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .controls label {
      font-size: .9rem;
      color: var(--muted);
    }
    .controls input[type="number"] {
      width: 120px;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(15, 23, 42, .8);
      color: inherit;
      font-size: 1rem;
    }
    .controls button {
      border: none;
      border-radius: 999px;
      padding: 12px 28px;
      font-size: .95rem;
      font-weight: 600;
      cursor: pointer;
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      box-shadow: 0 10px 30px rgba(250, 204, 21, .35);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .controls button[disabled] {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .controls button:not([disabled]):active {
      transform: translateY(1px);
    }
    .alert {
      padding: 12px 14px;
      border-radius: 10px;
      font-size: .95rem;
      background: rgba(248, 113, 113, .1);
      border: 1px solid rgba(248, 113, 113, .4);
      color: var(--danger);
    }
    .log {
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
      max-height: 160px;
      overflow-y: auto;
    }
    .log-entry + .log-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .ghost-btn {
      border: 1px solid rgba(255,255,255,.25);
      color: var(--muted);
      background: transparent;
      border-radius: 10px;
      padding: 8px 14px;
      font-size: .85rem;
      cursor: pointer;
    }
    .ghost-btn:disabled {
      opacity: .5;
      cursor: default;
    }
    .ghost-btn.primary {
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      border-color: transparent;
      font-weight: 600;
      box-shadow: 0 15px 35px rgba(250, 204, 21, .35);
    }
    .ghost-btn.secondary {
      color: var(--text);
      border-color: rgba(255,255,255,.25);
    }
    .ghost-btn.tertiary {
      color: var(--muted);
      border-color: transparent;
      background: rgba(255,255,255,.08);
    }
    .ghost-btn.danger {
      color: var(--danger);
      border-color: rgba(248,113,113,.5);
      background: rgba(248,113,113,.08);
    }
    .auth-overlay {
      position: fixed;
      inset: 0;
      z-index: 40;
      background: radial-gradient(circle at top, rgba(15,23,42,.9), rgba(2,6,23,.98));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(16px, 4vw, 48px);
      transition: opacity .35s ease, visibility .35s ease;
    }
    .auth-overlay[data-hidden="true"] {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .auth-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(20px, 5vw, 36px);
      width: min(960px, 100%);
      border-radius: 26px;
      border: 1px solid rgba(99,102,241,.35);
      background: linear-gradient(135deg, rgba(15,23,42,.95), rgba(30,64,175,.9));
      padding: clamp(24px, 5vw, 48px);
      box-shadow: 0 40px 150px rgba(2, 6, 23, .9);
      position: relative;
      overflow: hidden;
    }
    .auth-card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at top right, rgba(99,102,241,.4), transparent 45%);
      pointer-events: none;
    }
    .auth-copy {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 12px;
    }
    .auth-copy h2 {
      margin: 0;
      font-size: clamp(1.6rem, 3vw, 2.4rem);
      font-weight: 600;
      color: #fff;
    }
    .auth-copy p {
      margin: 0;
      color: color-mix(in srgb, #fff 85%, rgba(255,255,255,.4));
      line-height: 1.6;
    }
    .auth-body {
      position: relative;
      z-index: 1;
      background: rgba(2, 6, 23, .7);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.08);
      padding: clamp(18px, 4vw, 28px);
      display: grid;
      gap: 18px;
    }
    .auth-tabs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      padding: 5px;
    }
    .auth-tab {
      border: none;
      background: transparent;
      color: rgba(255,255,255,.7);
      font-weight: 600;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: background .2s ease, color .2s ease;
    }
    .auth-tab.active {
      background: rgba(255,255,255,.14);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .auth-forms {
      display: grid;
      gap: 15px;
    }
    .auth-forms label {
      display: grid;
      gap: 6px;
      font-size: .9rem;
      color: rgba(255,255,255,.7);
    }
    .auth-forms input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(15, 23, 42, .85);
      color: inherit;
      font-size: 1rem;
      transition: border .2s ease, box-shadow .2s ease;
    }
    .auth-forms input:focus-visible {
      outline: none;
      border-color: rgba(250,204,21,.65);
      box-shadow: 0 0 0 2px rgba(250,204,21,.2);
    }
    .auth-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .muted-text {
      color: rgba(255,255,255,.65);
      margin: 0;
      font-size: .9rem;
    }
    .muted-text.small {
      font-size: .8rem;
    }
    .alert {
      margin-top: 4px;
    }
    .auth-body[data-mode="login"] #auth-confirm-group {
      display: none;
    }
    .auth-body[data-mode="register"] #auth-info {
      display: none;
    }
    .status-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 8px;
      gap: 12px;
      flex-wrap: wrap;
    }
    .status-row .status-pill {
      margin: 0;
      flex: 1 1 auto;
      min-width: 0;
    }
    .status-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      flex: 0 0 auto;
    }
    .status-icon {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(15,23,42,.7);
      display: grid;
      place-items: center;
      color: var(--text);
      cursor: pointer;
      padding: 0;
    }
    .status-icon:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .status-icon svg {
      width: 22px;
      height: 22px;
      display: block;
    }
    .account-sheet {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: min(420px, calc(100% - 32px));
      z-index: 30;
      box-shadow: 0 20px 80px rgba(2,6,23,.7);
      backdrop-filter: blur(6px);
    }
    .account-sheet[hidden] {
      display: none;
    }
    .account-sheet__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .slot-machine {
      background: linear-gradient(150deg, rgba(9,14,28,.94), rgba(5,10,22,.94));
      border: 1px solid rgba(148,163,184,.28);
      border-radius: 24px;
      box-shadow: 0 30px 90px rgba(2,6,23,.7);
      padding: clamp(18px, 2.4vw, 26px);
    }
    .slot-machine__body {
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 2.4vw, 24px);
      padding-top: 10px;
      align-items: stretch;
    }
    .machine-frame {
      position: relative;
      border-radius: 26px;
      border: 1px solid rgba(99,102,241,.28);
      padding: clamp(16px, 3vw, 24px);
      background:
        radial-gradient(circle at 22% 0%, rgba(59,130,246,.16), transparent 42%),
        linear-gradient(180deg, rgba(12,18,36,.94), rgba(6,11,22,.98));
      overflow: hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 18px 50px rgba(2,6,23,.7);
    }
    .machine-frame__glow {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 50% 18%, rgba(99,102,241,.22), transparent 48%);
      opacity: .9;
      pointer-events: none;
    }
    .machine-frame__reels {
      position: relative;
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, rgba(8,13,26,.86), rgba(4,7,16,.94));
      padding: clamp(16px, 3vw, 22px);
      border-radius: 22px;
      box-shadow: inset 0 0 32px rgba(0,0,0,.45), 0 12px 30px rgba(0,0,0,.4);
      overflow: hidden;
    }
    .slot-grid {
      --reel-count: 3;
      --row-count: 3;
      --cell-size: clamp(52px, 9vw, 96px);
      display: grid;
      grid-template-columns: repeat(var(--reel-count), minmax(var(--cell-size), 1fr));
      gap: clamp(8px, 1.5vw, 14px);
      perspective: 1200px;
      position: relative;
      padding: clamp(6px, 1vw, 12px);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.04);
      background: radial-gradient(circle at 50% 20%, rgba(255,255,255,.04), transparent 62%);
      width: 100%;
      min-width: 100%;
    }
    .slot-reel {
      position: relative;
      display: grid;
      grid-template-rows: repeat(var(--row-count), 1fr);
      gap: clamp(6px, 1.6vw, 12px);
      padding: clamp(6px, 1.4vw, 12px);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(16,24,40,.92), rgba(11,17,30,.92));
      border: 1px solid rgba(148,163,184,.22);
      box-shadow: inset 0 4px 12px rgba(0,0,0,.25), 0 10px 26px rgba(0,0,0,.28);
    }
    .slot-cell {
      position: relative;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      aspect-ratio: 1 / 1.1;
      display: grid;
      place-items: center;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 18px 35px rgba(0,0,0,.35);
      transition: transform .28s ease, box-shadow .28s ease, border-color .2s ease;
      pointer-events: none;
    }
    .slot-cell[data-state="spinning"] {
      opacity: .95;
    }
    .slot-cell[data-state="win"] {
      box-shadow: 0 0 0 2px rgba(250,204,21,.35), 0 22px 45px rgba(250,204,21,.28);
      transform: translateY(-2px) scale(1.02);
      border-color: rgba(250,204,21,.6);
    }
    .slot-cell__symbol {
      width: 80%;
      max-width: calc(var(--cell-size) * 0.9);
      display: grid;
      place-items: center;
    }
    .slot-cell__symbol img {
      width: 100%;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 12px 24px rgba(0,0,0,.45));
      transition: filter .2s ease, transform .2s ease;
    }
    .slot-cell[data-state="spinning"] .slot-cell__symbol {
      animation: slotReelSpin .35s linear infinite;
      opacity: .95;
    }
    .slot-cell[data-state="spinning"] .slot-cell__symbol img {
      filter: blur(1.4px) brightness(1.05);
    }
    .slot-cell.slot-lock .slot-cell__symbol {
      animation: none;
      transform: translateZ(0) scale(1.05);
      transition: transform .5s cubic-bezier(.19,1,.22,1);
    }
    .slot-cell.slot-lock .slot-cell__symbol img {
      filter: drop-shadow(0 15px 25px rgba(0,0,0,.35));
    }
    @media (hover: hover) {
      .slot-cell:not([data-state="spinning"]):hover {
        transform: translateY(-4px);
        box-shadow: 0 0 0 1px rgba(148,163,184,.3), 0 18px 36px rgba(0,0,0,.35);
      }
      .slot-cell:not([data-state="spinning"]):hover .slot-cell__symbol img {
        transform: translateY(-2px);
      }
    }
    @media (min-width: 1080px) {
      .machine-frame {
        min-height: 380px;
      }
      .machine-frame__reels {
        min-height: 300px;
        align-items: center;
        justify-content: center;
      }
      .control-deck {
        grid-template-rows: auto auto auto auto;
      }
      .hud {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }
    @keyframes slotReelSpin {
      0% { transform: translateY(-16%); }
      50% { transform: translateY(16%); }
      100% { transform: translateY(-16%); }
    }
    .line-overlay {
      position: absolute;
      inset: clamp(12px, 2vw, 26px);
      pointer-events: none;
    }
    .line-overlay svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      overflow: visible;
    }
    .line-path {
      fill: none;
      stroke: hsl(var(--line-hue, 220), 90%, 65%);
      stroke-width: 3.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.92;
      stroke-dasharray: 12 10;
      animation: drawLine .9s ease forwards;
    }
    @keyframes drawLine {
      from { stroke-dashoffset: 40; opacity: 0; }
      to { stroke-dashoffset: 0; opacity: 0.95; }
    }
    .slot-cell.line-flash {
      box-shadow: 0 0 0 2px rgba(99,102,241,.75), 0 0 32px rgba(99,102,241,.4);
      transform: translateY(-2px);
    }
    @keyframes slotPulse {
      0% { transform: translateY(-4px) scale(.98); opacity: .8; }
      100% { transform: translateY(4px) scale(1.02); opacity: 1; }
    }
    .control-deck {
      display: grid;
      gap: 14px;
      background: linear-gradient(165deg, rgba(15,23,42,.84), rgba(12,16,32,.9));
      border-radius: 22px;
      border: 1px solid rgba(148,163,184,.24);
      padding: clamp(16px, 3vw, 20px);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04), 0 10px 30px rgba(0,0,0,.35);
      align-content: start;
    }
    .control-deck .hud,
    .control-deck .bet-controls,
    .control-deck .machine-messages,
    .control-deck .action-buttons {
      background: rgba(255,255,255,.02);
      border: 1px solid rgba(148,163,184,.18);
      border-radius: 14px;
      padding: 12px 14px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .drop-stack {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.22);
      background: linear-gradient(180deg, rgba(15,23,42,.8), rgba(4,6,20,.92));
      padding: 14px;
      display: grid;
      gap: 12px;
      position: relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .drop-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .drop-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .inventory-grid {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .inventory-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(148,163,184,.25);
      font-size: .9rem;
      color: var(--text);
    }
    .inventory-chip img {
      width: 22px;
      height: 22px;
      object-fit: contain;
      display: block;
    }
    .daily-reward {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.03);
      padding: 10px 12px;
      display: grid;
      gap: 8px;
    }
    .daily-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .daily-items {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .daily-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(99,102,241,.12);
      border: 1px solid rgba(99,102,241,.3);
      font-weight: 600;
      color: var(--text);
    }
    .daily-item img {
      width: 22px;
      height: 22px;
      object-fit: contain;
    }
    .bonus-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }
    .bonus-item {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.03);
      padding: 10px 12px;
    }
    .bonus-label {
      margin: 0;
      font-weight: 600;
    }
    .bonus-note {
      margin: 2px 0 0;
      color: var(--muted);
      font-size: .9rem;
    }
    .bonus-value {
      font-weight: 700;
      white-space: nowrap;
    }
    .drop-log {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(2,6,23,.7);
      padding: 10px;
      max-height: 180px;
      overflow-y: auto;
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
    }
    .drop-entry {
      display: flex;
      gap: 8px;
      align-items: center;
      line-height: 1.3;
    }
    .drop-entry + .drop-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.06);
    }
    .drop-icon {
      width: 22px;
      height: 22px;
      object-fit: contain;
      border-radius: 6px;
      background: rgba(255,255,255,.05);
      padding: 3px;
      display: block;
    }
    .drop-amount {
      font-weight: 600;
      color: var(--text);
    }
    .drop-panel {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 10px;
      width: min(480px, 100%);
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(4,6,20,.96);
      box-shadow: 0 20px 50px rgba(2,6,23,.65);
      padding: 12px 14px;
      z-index: 8;
    }
    .drop-panel[hidden] {
      display: none;
    }
    .drop-panel h4 {
      margin: 0 0 8px;
      font-size: 1rem;
    }
    .drop-panel ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
    }
    .drop-panel li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.2);
      padding: 8px 10px;
      background: rgba(255,255,255,.03);
    }
    .rate-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .drop-tier-label {
      margin: 6px 0 4px;
      font-size: .8rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: var(--muted);
    }
    .drop-mult {
      margin: 4px 0;
      font-size: .85rem;
      color: var(--muted);
    }
    .upgrade-panel {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(15,23,42,.8);
      padding: 18px;
      display: grid;
      gap: 16px;
    }
    .upgrade-panel h2,
    .upgrade-panel h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .upgrade-category + .upgrade-category {
      margin-top: 28px;
    }
    .upgrade-category h3 {
      margin: 0 0 8px;
      font-size: .95rem;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: rgba(226,232,240,.75);
    }
    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 14px;
      align-items: stretch;
    }
    .upgrade-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.25);
      padding: 14px;
      background: linear-gradient(180deg, rgba(14,20,35,.9), rgba(6,10,22,.94));
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 210px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .upgrade-card__meta {
      font-size: .82rem;
      color: rgba(148,163,184,.85);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .upgrade-card__note {
      font-size: .78rem;
      color: rgba(248,250,252,.7);
      margin: 0;
    }
    .upgrade-card h4 {
      margin: 0;
      font-size: 1rem;
    }
    .upgrade-card p {
      margin: 0;
      font-size: .85rem;
      color: var(--muted);
      min-height: 32px;
      flex: 1;
    }
    .upgrade-card strong {
      font-size: .95rem;
    }
    .upgrade-card button {
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: .9rem;
      background: rgba(99,102,241,.12);
      color: var(--text);
      cursor: pointer;
      width: 100%;
      margin-top: auto;
    }
    .upgrade-card button[data-disabled="true"],
    .upgrade-card button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      align-items: stretch;
    }
    .hud-card {
      border-radius: 12px;
      padding: 12px 14px;
      background: linear-gradient(180deg, rgba(17,24,39,.94), rgba(11,16,30,.92));
      border: 1px solid rgba(148,163,184,.26);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .hud-label {
      margin: 0;
      font-size: .75rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: rgba(148,163,184,.8);
    }
    .hud-value {
      font-size: clamp(1rem, 2.2vw, 1.15rem);
      margin-top: 6px;
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-variant-numeric: tabular-nums;
    }
    .bet-controls {
      display: grid;
      grid-template-columns: 44px 1fr 44px auto;
      gap: 10px;
      align-items: center;
    }
    .bet-controls input[type="range"] {
      grid-column: 2;
      width: 100%;
      accent-color: var(--accent, #facc15);
      height: 6px;
      border-radius: 999px;
    }
    .bet-controls button:nth-of-type(1) { grid-column: 1; }
    .bet-controls button:nth-of-type(2) { grid-column: 3; }
    .bet-controls button:nth-of-type(3) { grid-column: 4; }
    .chip {
      border: 1px solid rgba(148,163,184,.45);
      background: linear-gradient(180deg, rgba(15,23,42,.95), rgba(9,14,26,.95));
      color: #e2e8f0;
      border-radius: 12px;
      padding: 9px 12px;
      font-size: .92rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
    }
    .chip:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .machine-messages {
      min-height: 40px;
      display: grid;
      gap: 6px;
    }
    .machine-outcome-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .machine-outcome {
      margin: 0;
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }
    .machine-lines {
      margin: 0;
      font-size: .85rem;
      color: var(--muted);
      word-break: break-word;
    }
    .machine-error {
      margin: 0;
      color: #f97316;
      font-size: .9rem;
    }
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      align-items: stretch;
      justify-items: stretch;
    }
    .action-buttons .line-btn {
      padding: 9px 12px;
      font-size: .85rem;
      border-radius: 12px;
      min-width: 0;
    }
    .action-buttons .spin-btn {
      width: 100%;
    }
    .spin-btn {
      border: none;
      border-radius: 16px;
      padding: 16px 22px;
      font-size: 1.05rem;
      font-weight: 700;
      letter-spacing: .01em;
      color: #041226;
      background: linear-gradient(120deg, #22d3ee, #facc15);
      box-shadow: 0 18px 36px rgba(34,211,238,.32);
      cursor: pointer;
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .spin-btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .spin-btn:not(:disabled):hover {
      box-shadow: 0 22px 44px rgba(34,211,238,.36);
      transform: translateY(-1px);
    }
    .spin-btn:not(:disabled):active {
      transform: translateY(0);
      box-shadow: 0 12px 28px rgba(34,211,238,.3);
    }
    .paytable-panel {
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.22);
      background: linear-gradient(180deg, rgba(10,16,30,.92), rgba(5,9,18,.95));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .paytable {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }
    .paytable li {
      display: flex;
      justify-content: space-between;
      background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(9,14,26,.9));
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 16px;
      padding: 12px 16px;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
    }
    .paytable li[data-active="false"] {
      opacity: .45;
    }
    .paytable-symbol {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }
    .paytable-symbol img {
      width: 36px;
      height: 36px;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
    }
    .paytable-meta {
      font-size: .9rem;
      color: rgba(148,163,184,.85);
    }
    .desktop-nav {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 8px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(145deg, rgba(10,16,30,.92), rgba(8,13,24,.94));
      padding: 10px;
      box-shadow: 0 14px 40px rgba(2,6,23,.45);
    }
    .desktop-nav button {
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(255,255,255,.03);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      letter-spacing: .01em;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: border .16s ease, background .16s ease, transform .16s ease, box-shadow .16s ease;
    }
    .desktop-nav button.active {
      background: linear-gradient(120deg, #22d3ee, #facc15);
      color: #041226;
      border-color: transparent;
      box-shadow: 0 12px 28px rgba(34,211,238,.35);
      transform: translateY(-1px);
    }
    .desktop-nav button:not(.active):hover {
      border-color: rgba(148,163,184,.55);
      transform: translateY(-1px);
    }
    .mobile-nav {
      display: none;
      gap: 6px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(15,23,42,.85);
      padding: 8px;
    }
    .mobile-nav button {
      flex: 1;
      border: none;
      border-radius: 14px;
      padding: 8px;
      background: rgba(99,102,241,.12);
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      min-width: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: .72rem;
      line-height: 1.1;
    }
    .mobile-nav button svg {
      width: 20px;
      height: 20px;
      display: block;
    }
    .mobile-nav button span {
      font-size: .72rem;
      letter-spacing: .04em;
    }
    .mobile-nav button.active {
      background: linear-gradient(120deg, var(--accent), #fde047);
      color: #020617;
      box-shadow: 0 6px 18px rgba(250,204,21,.3);
    }
    main[data-pane-mode="tabbed"] [data-mobile-pane] {
      display: none;
    }
    main[data-pane-mode="tabbed"] [data-mobile-pane][data-mobile-active="true"] {
      display: block;
    }
    @media (max-width: 768px) {
      html, body {
        height: 100%;
      }
      body {
        padding: var(--safe-top, 8px) 0 var(--safe-bottom, 16px);
        min-height: calc((var(--app-vh, 1vh) * 100) - var(--safe-top, 0px));
        background: #020617;
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
        overflow-y: auto;
      }
      main {
        border-radius: 0;
        min-height: calc((var(--app-vh, 1vh) * 100) - var(--safe-top, 0px));
        padding: 0;
        gap: 10px;
        box-shadow: none;
        border: none;
        display: flex;
        flex-direction: column;
        flex: 1;
        width: 100%;
        overflow: visible;
      }
      main > * {
        margin-inline: 16px;
      }
      .status-row {
        justify-content: space-between;
      }
      .slot-grid {
        gap: 8px;
      }
      .mobile-nav {
        display: flex;
        position: sticky;
        top: env(safe-area-inset-top, 8px);
        z-index: 5;
        background: rgba(2,6,23,.95);
        border-radius: 18px;
        border: 1px solid rgba(148,163,184,.25);
        box-shadow: 0 15px 40px rgba(2,6,23,.5);
        padding: 8px;
        flex-wrap: nowrap;
        justify-content: space-between;
      }
      .mobile-nav button {
        font-size: .85rem;
      }
      .desktop-nav {
        display: none;
      }
      main[data-tabs="true"] {
        gap: 8px;
        flex: 1;
      }
      main[data-tabs="true"] [data-mobile-pane] {
        display: none;
        margin-inline: 16px;
        min-height: 0;
      }
      main[data-tabs="true"] [data-mobile-pane][data-mobile-active="true"] {
        display: block;
        max-height: none;
        min-height: 0;
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      main[data-tabs="true"] [data-mobile-pane][data-mobile-active="true"].slot-machine {
        display: flex;
        flex-direction: column;
        overflow: hidden;
        flex: 1;
      }
      main[data-tabs="true"] section.panel {
        max-height: none;
        overflow: visible;
      }
      .slot-machine {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 12px 14px;
        border-radius: 20px;
        box-shadow: 0 25px 60px rgba(2,6,23,.65);
        min-height: 0;
      }
      .slot-machine__body {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding-top: 0;
        overflow: hidden;
      }
      .machine-frame {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        justify-content: center;
        min-height: calc(var(--app-vh, 1vh) * 0.55);
        padding: 8px;
      }
      .machine-frame__reels {
        flex: 1;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6px;
        overflow: hidden;
      }
      .machine-frame__reels .slot-grid {
        align-content: center;
        justify-content: center;
        justify-items: center;
        height: auto;
        min-width: 100%;
      }
      .machine-frame__reels .slot-cell {
        height: auto;
      }
      .control-deck {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 14px;
        flex: 0 0 auto;
      }
    .drop-log {
        max-height: 140px;
      }
      .drop-panel {
        position: fixed;
        left: 16px;
        right: 16px;
        bottom: clamp(96px, 22vh, 260px);
        top: auto;
        width: auto;
      }
      .slot-grid {
        gap: 6px;
      }
      .slot-grid .slot-cell {
        border-width: 1px;
        padding: 4px;
      }
      .slot-grid .slot-cell__symbol {
        max-width: 68px;
      }
      .hud {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 6px;
      }
      .hud-card {
        padding: 10px 12px;
      }
      .hud-value {
        font-size: .95rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-variant-numeric: tabular-nums;
      }
      .machine-messages {
        min-height: 42px;
      }
      .action-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 8px;
        justify-items: center;
      }
      .account-sheet {
        width: calc(100% - 32px);
        bottom: env(safe-area-inset-bottom, 16px);
      }
    }
  </style>
</head>
<body>
  <div class="auth-overlay" id="auth-overlay" aria-hidden="false" data-hidden="false">
    <div class="auth-card">
      <div class="auth-copy">
        <p class="status-pill ghost">üé∞ Demo Slot Machine</p>
        <h2>Log in to save your credits and keep the reels rolling.</h2>
        <p>This is a fun, server-backed slot machine demo‚Äîno real money is involved. Every spin is validated in AWS so balances carry across devices.</p>
        <p class="muted-text small">Passwords are hashed before storing and sessions auto-expire. Have fun exploring the animations and payouts.</p>
      </div>
      <div class="auth-body" id="auth-body" data-mode="login">
        <div class="auth-tabs" role="tablist">
          <button type="button" class="auth-tab active" data-mode="login">Sign In</button>
          <button type="button" class="auth-tab" data-mode="register">Create Account</button>
        </div>
        <div class="auth-forms">
          <label>
            Email
            <input type="email" id="auth-email" autocomplete="email" placeholder="you@example.com" required />
          </label>
          <label>
            Password
            <input type="password" id="auth-password" autocomplete="current-password" placeholder="At least 8 characters" required />
          </label>
          <label id="auth-confirm-group" hidden>
            Confirm password
            <input type="password" id="auth-confirm" autocomplete="new-password" placeholder="Repeat password" />
          </label>
          <div class="auth-actions">
            <button type="button" class="ghost-btn primary" id="auth-submit">Sign In</button>
            <button type="button" class="ghost-btn tertiary" id="auth-info">Need access? Register in seconds.</button>
          </div>
          <p class="muted-text small" id="auth-note">Passwords never leave AWS without hashing. Sessions expire automatically to keep balances safe.</p>
          <div class="alert" id="auth-alert" hidden role="status" aria-live="polite" tabindex="-1"></div>
        </div>
      </div>
    </div>
  </div>
  <a class="skip-link" href="#main">Skip to content</a>
  <main id="main" data-api-base="https://4kvebym8b3.execute-api.us-east-2.amazonaws.com/prod" data-max-bet="100" data-machine-config="slot-config/classic.json">
    <div class="status-row">
      <p class="status-pill" id="connection-pill" data-state="loading">
        <span aria-hidden="true">üõ∞Ô∏è</span>
        <span id="connection-text">Connecting to AWS‚Ä¶</span>
      </p>
      <div class="status-actions" data-requires-auth hidden>
        <button type="button" class="status-icon" id="account-toggle" aria-label="Account details">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <path d="M12 13.5c3.05 0 5.5-2.45 5.5-5.5S15.05 2.5 12 2.5 6.5 4.95 6.5 8s2.45 5.5 5.5 5.5zm0 2c-4.05 0-7.5 2.45-7.5 5.5 0 .28.22.5.5.5h14c.28 0 .5-.22.5-.5 0-3.05-3.45-5.5-7.5-5.5z" fill="currentColor"/>
          </svg>
        </button>
        <button type="button" class="status-icon" id="logout-btn" aria-label="Log out">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <path d="M14 3a1 1 0 00-1 1v4h2V5h4v14h-4v-3h-2v4a1 1 0 001 1h6a1 1 0 001-1V4a1 1 0 00-1-1h-6z" fill="currentColor"/>
            <path d="M15 11H7V9l-5 3 5 3v-2h8v-2z" fill="currentColor"/>
          </svg>
        </button>
      </div>
    </div>
    <nav class="desktop-nav" id="desktop-nav" aria-label="Game sections" data-requires-auth hidden>
      <button type="button" data-pane-target="play" class="active">Play</button>
      <button type="button" data-pane-target="stats">Stats</button>
      <button type="button" data-pane-target="paytable">Paytable</button>
      <button type="button" data-pane-target="items">Items</button>
      <button type="button" data-pane-target="log">Log</button>
      <button type="button" data-pane-target="upgrades">Upgrades</button>
    </nav>
    <nav class="mobile-nav" id="mobile-nav" aria-label="Game sections" data-requires-auth hidden>
      <button type="button" data-mobile-target="play" class="active" aria-label="Play">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="3" y="5" width="18" height="14" rx="3" ry="3" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <circle cx="9" cy="12" r="1.6" fill="currentColor"></circle>
          <circle cx="12" cy="12" r="1.6" fill="currentColor" opacity=".65"></circle>
          <circle cx="15" cy="12" r="1.6" fill="currentColor" opacity=".4"></circle>
        </svg>
        <span>Play</span>
      </button>
      <button type="button" data-mobile-target="stats" aria-label="Stats">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <path d="M5 17v-4m4 4V7m4 10v-7m4 7V9" fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.6"></path>
        </svg>
        <span>Stats</span>
      </button>
      <button type="button" data-mobile-target="paytable" aria-label="Paytable">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="5" y="6" width="14" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <path d="M8 9h8M8 12h8M8 15h5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Pay</span>
      </button>
      <button type="button" data-mobile-target="items" aria-label="Items">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="5" y="4" width="14" height="16" rx="3" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <path d="M9 9h6M9 13h3" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Items</span>
      </button>
      <button type="button" data-mobile-target="log" aria-label="Log">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <rect x="6" y="5" width="12" height="14" rx="2" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
          <path d="M9 9h6M9 12h6M9 15h4" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Log</span>
      </button>
      <button type="button" data-mobile-target="upgrades" aria-label="Upgrades">
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <path d="M12 5v14m0-14l-3 3m3-3l3 3" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" fill="none"></path>
          <path d="M7 19h10" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
        </svg>
        <span>Upg</span>
      </button>
    </nav>
    <section class="panel account-sheet" id="account-panel" role="dialog" aria-modal="true" aria-hidden="true" hidden tabindex="-1">
      <div class="account-sheet__header">
        <div>
          <p class="muted-text">Signed in as</p>
          <strong id="account-user"></strong>
        </div>
        <button type="button" class="ghost-btn tertiary" id="account-close" aria-label="Close account details">Close</button>
      </div>
      <div class="actions">
        <button type="button" class="ghost-btn secondary" id="sync-btn">Sync balance</button>
        <button type="button" class="ghost-btn tertiary" id="reset-btn">Reset session</button>
        <button type="button" class="ghost-btn primary" id="debug-add-coins" hidden>+100k credits</button>
        <button type="button" class="ghost-btn danger" id="delete-account-btn">Delete account</button>
      </div>
    </section>

    <section class="panel slot-machine" data-requires-auth hidden data-mobile-pane="play" data-mobile-active="true">
      <div class="slot-machine__body">
        <div class="machine-frame">
          <div class="machine-frame__glow"></div>
          <div class="machine-frame__reels" id="reel-stage">
            <div class="slot-grid" id="slot-grid" aria-live="polite"></div>
            <div class="line-overlay" id="line-overlay" aria-hidden="true"></div>
          </div>
        </div>
        <div class="control-deck">
          <div class="hud">
            <div class="hud-card">
              <p class="hud-label">Credits</p>
              <strong class="hud-value" id="hud-balance">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Bet</p>
              <strong class="hud-value" id="hud-bet">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">Last win</p>
              <strong class="hud-value" id="hud-win">$0</strong>
            </div>
            <div class="hud-card">
              <p class="hud-label">VIP Marks</p>
              <strong class="hud-value" id="hud-vip">0</strong>
            </div>
          </div>
          <div class="bet-controls">
            <button type="button" class="chip" data-chip="decrease" aria-label="Decrease bet">-</button>
            <input type="range" id="bet-range" min="0" max="10" value="0" aria-label="Bet amount" />
            <button type="button" class="chip" data-chip="increase" aria-label="Increase bet">+</button>
            <button type="button" class="chip" data-chip="max" aria-label="Max bet">Max</button>
          </div>
          <div class="machine-messages">
            <div class="machine-outcome-group">
              <p class="machine-outcome" id="machine-outcome">Sign in to start spinning.</p>
              <p class="machine-lines" id="machine-lines"></p>
            </div>
            <p class="machine-error" id="error" role="status" aria-live="polite"></p>
            <div class="alert" id="alert" hidden></div>
          </div>
          <div class="action-buttons">
            <button type="button" class="ghost-btn secondary line-btn" id="line-flash-btn">Show lines</button>
            <button type="button" class="ghost-btn secondary line-btn" id="auto-spin-btn">Auto</button>
            <button type="button" class="spin-btn" id="spin-btn" disabled>Spin</button>
          </div>
        </div>
      </div>
    </section>

    <section class="grid grid-two" data-requires-auth hidden data-mobile-pane="stats">
      <div class="panel">
        <h2>Session</h2>
        <dl id="session-stats">
          <dt>Player ID</dt><dd id="player-id">‚Äî</dd>
          <dt>Balance</dt><dd id="balance">‚Äî</dd>
          <dt>Max Bet</dt><dd id="max-bet">‚Äî</dd>
          <dt>Total Spins</dt><dd id="spin-count">‚Äî</dd>
        </dl>
      </div>
      <div class="panel">
        <h2>Last Result</h2>
        <dl>
          <dt>Outcome</dt><dd id="last-outcome">‚Äî</dd>
          <dt>Winnings</dt><dd id="last-win">‚Äî</dd>
          <dt>Multiplier</dt><dd id="last-multiplier">‚Äî</dd>
          <dt>Timestamp</dt><dd id="last-time">‚Äî</dd>
        </dl>
      </div>
      <div class="panel" id="daily-panel">
        <div class="status-row">
          <h2>Daily Rewards</h2>
          <span class="status-pill" id="daily-status">Syncing‚Ä¶</span>
        </div>
        <p class="muted-text" id="daily-streak">Day 1 of 7</p>
        <div class="daily-reward" id="daily-reward">
          <div class="daily-row">
            <span class="hud-label">Today&apos;s reward</span>
            <strong class="hud-value" id="daily-reward-main">$0</strong>
          </div>
          <div class="daily-items" id="daily-items"></div>
        </div>
        <div class="actions">
          <button type="button" class="ghost-btn primary" id="daily-claim-btn">Claim</button>
        </div>
        <p class="muted-text small" id="daily-next-reset">Resets daily</p>
      </div>
      <div class="panel" id="bonus-panel">
        <h2>Equipment Bonuses</h2>
        <ul class="bonus-list" id="bonus-list">
          <li class="bonus-item"><span class="bonus-label">Calculating bonuses‚Ä¶</span></li>
        </ul>
      </div>
    </section>

    <section class="panel paytable-panel" data-requires-auth hidden data-mobile-pane="paytable">
      <h2>Paytable</h2>
      <ul class="paytable" id="paytable"></ul>
      <p class="muted-text small">Multipliers apply to your active bet. Triple matches and pairs are calculated server-side.</p>
    </section>

    <section class="panel" data-requires-auth hidden data-mobile-pane="items">
      <div class="drop-stack">
        <div class="drop-header">
          <div>
            <p class="hud-label">Inventory</p>
            <div class="inventory-grid" id="inventory-grid"></div>
          </div>
          <div class="drop-actions">
            <button type="button" class="ghost-btn secondary" id="drop-rates-btn">Drop rates</button>
            <button type="button" class="ghost-btn tertiary" id="drop-skill-btn">Drop boost</button>
            <button type="button" class="ghost-btn tertiary" id="drop-close-btn">Close</button>
          </div>
        </div>
        <div class="drop-log" id="drop-log" aria-live="polite"></div>
        <div class="drop-panel" id="drop-panel" hidden aria-live="polite"></div>
      </div>
    </section>

    <section class="panel" data-requires-auth hidden data-mobile-pane="log">
      <h2>Server Event Log</h2>
      <div class="log" id="log" aria-live="polite"></div>
    </section>

    <section class="panel upgrade-panel" id="upgrade-panel" data-requires-auth hidden data-mobile-pane="upgrades">
      <h2>Machine Upgrades</h2>
      <div class="upgrade-grid" id="upgrade-grid"></div>
    </section>
  </main>

  <script>
    (() => {
      const DEBUG = true;
      const debug = (...args) => DEBUG && console.debug('[slot-demo]', ...args);
      const debugError = (scope, error, extra = {}) => {
        if (!DEBUG) return;
        console.error(`[slot-demo][${scope}]`, error, extra);
      };
      window.addEventListener('error', (event) => {
        debugError('window-error', event.error || event.message, { event });
      });
      window.addEventListener('unhandledrejection', (event) => {
        debugError('unhandled-rejection', event.reason, {});
      });

      const setViewportUnit = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--app-vh', `${vh}px`);
      };
      setViewportUnit();
      window.addEventListener('resize', setViewportUnit);
      window.addEventListener('orientationchange', setViewportUnit, { passive: true });

      const root = document.getElementById('main');
      if (!root) {
        debugError('init', 'Missing #main element');
        return;
      }
      const API_BASE = root.dataset.apiBase;
      const DEFAULT_MAX_BET = Number(root.dataset.maxBet) || 100;
      const MACHINE_CONFIG_URL = root.dataset.machineConfig || '';
      const storageKeys = {
        player: 'slotMachineDemoPlayerId',
        token: 'slotMachineAuthToken',
        user: 'slotMachineAuthUser'
      };
      const DEBUG_EMAIL = 'danielshort3@gmail.com';
      const requestFrame = window.requestAnimationFrame?.bind(window) || (cb => setTimeout(() => cb(performance.now()), 1000 / 60));
      const cancelFrame = window.cancelAnimationFrame?.bind(window) || clearTimeout;
      const AUTH_MODE_KEY = 'slotMachineAuthMode';
      const getStored = (key) => {
        const value = localStorage.getItem(key);
        return value && value !== 'null' ? value : null;
      };
      const DEFAULT_SYMBOLS = [
        { key: 'cherry', label: 'Cherry', asset: 'img/slot/classic/symbols/cherry.png' },
        { key: 'lemon', label: 'Lemon', asset: 'img/slot/classic/symbols/lemon.png' },
        { key: 'orange', label: 'Orange', asset: 'img/slot/classic/symbols/orange.png' },
        { key: 'plum', label: 'Plum', asset: 'img/slot/classic/symbols/plum.png' },
        { key: 'watermelon', label: 'Watermelon', asset: 'img/slot/classic/symbols/watermelon.png' },
        { key: 'horseshoe', label: 'Horseshoe', asset: 'img/slot/classic/symbols/horseshoe.png' },
        { key: 'bell', label: 'Bell', asset: 'img/slot/classic/symbols/bell.png' },
        { key: 'diamond', label: 'Diamond', asset: 'img/slot/classic/symbols/diamond.png' },
        { key: 'seven', label: 'Lucky Seven', asset: 'img/slot/classic/symbols/seven.png' },
        { key: 'crown', label: 'Crown', asset: 'img/slot/classic/symbols/crown.png' },
        { key: 'wild', label: 'Wild', asset: 'img/slot/classic/symbols/wild.png' },
        { key: 'bonus', label: 'Bonus Sigil', asset: 'img/slot/classic/symbols/bonus.png' }
      ];
      const PLACEHOLDER_ASSET = 'img/slot/placeholder.png';
      const buildSymbolMap = (symbols = [], baseMap = null, placeholderAsset = PLACEHOLDER_ASSET) => {
        const seedEntries = baseMap
          ? Array.from(baseMap.entries())
          : DEFAULT_SYMBOLS.map(entry => [entry.key, { ...entry }]);
        const map = new Map(seedEntries.map(([key, val]) => [key, { ...val, asset: val.asset || placeholderAsset }]));
        if (!Array.isArray(symbols) || !symbols.length) return map;
        symbols.forEach(entry => {
          if (!entry || !entry.key) return;
          const prev = map.get(entry.key) || { key: entry.key, label: entry.label || entry.key, asset: placeholderAsset };
          map.set(entry.key, {
            ...prev,
            ...entry,
            asset: entry.asset || prev.asset || placeholderAsset
          });
        });
        return map;
      };
      const cloneSymbolMap = (map) => new Map(Array.from(map.entries()).map(([key, val]) => [key, { ...val }]));
      const DEFAULT_SYMBOL_MAP = buildSymbolMap(DEFAULT_SYMBOLS, null, PLACEHOLDER_ASSET);
      const DAILY_LENGTH = 7;

      const state = {
        playerId: null,
        balance: 0,
        maxBet: DEFAULT_MAX_BET,
        bet: 25,
        busy: false,
        gameReady: false,
        auth: {
          token: getStored(storageKeys.token),
          username: getStored(storageKeys.user)
        },
        authMode: localStorage.getItem(AUTH_MODE_KEY) || 'login',
        machine: {
          id: 'classic',
          name: 'Lucky Lambda Classic',
          rows: 3,
          reels: 3,
          lineTier: 0,
          lines: [],
          payouts: {},
          assets: {},
          placeholder: PLACEHOLDER_ASSET,
          upgradeSettings: {
            baseRows: 3,
            maxRows: 5,
            baseReels: 3,
            maxReels: 5,
            costs: { rows: [], reels: [], lines: [] }
          },
          baseSymbolCount: 5,
          activeSymbols: []
        },
        drop: {
        tableKey: 'classic',
        table: { common: [], rare: [], epic: [] },
        tierWeights: { common: 0.8, rare: 0.15, epic: 0.05 },
        constants: { betScale: 0.1, win: 2, lose: 1, boostScale: 0.05 },
        inventory: {},
        lastDrops: [],
        history: [],
        lastTimestamp: 0
      },
      daily: {
        streak: 1,
        claimedToday: false,
        ready: false,
        lastClaimMs: 0,
        nextResetAt: 0,
        todayReward: null
      },
      skills: {
        dropRate: {
          active: false,
          expiresAt: 0,
          cooldownUntil: 0,
            spec: { durationMs: 60000, cooldownMs: 120000, multiplier: 1.05 }
          }
        },
        symbolMap: cloneSymbolMap(DEFAULT_SYMBOL_MAP),
        gridCells: new Map(),
        serverUpgrades: {},
        pendingUpgrades: {},
        upgrades: {},
        upgradeCatalog: [],
        lineFlashTimer: null,
        autoSpin: { active: false, remaining: 0 },
        lastWin: 0,
        pendingIdleCoins: 0,
        idleTicker: null,
        idleTickerActive: false,
        lastIdleTick: 0,
        currentRows: 3,
        currentReels: 3,
        currentLineTier: 0
      };
      window.slotDemoDebug = window.slotDemoDebug || {};
      window.slotDemoDebug.state = state;
      window.slotDemoDebug.log = debug;
      window.slotDemoDebug.dumpState = () => JSON.parse(JSON.stringify({
        ...state,
        symbolMap: Array.from(state.symbolMap.keys()),
        upgrades: { ...state.upgrades },
        dropInventory: { ...state.drop.inventory },
        daily: { ...state.daily }
      }));

      const upgradeCatalogUrl = 'slot-config/upgrade-definitions.json';
      const loadUpgradeCatalog = async () => {
        if (state.upgradeCatalog.length) return state.upgradeCatalog;
        try {
          const res = await fetch(upgradeCatalogUrl, { cache: 'no-cache' });
          if (res.ok) {
            const defs = await res.json();
            if (Array.isArray(defs)) {
              state.upgradeCatalog = defs;
              applyUpgradeState(state.upgrades);
              renderUpgrades();
              return defs;
            }
          }
        } catch (error) {
          console.error('upgrade catalog load failed', error);
        }
        return state.upgradeCatalog;
      };

      const getUpgradeDef = (key) => state.upgradeCatalog.find(def => def.key === key);

      const getUpgradeMaxLevel = (key) => {
        const def = getUpgradeDef(key);
        if (!def) return 0;
        if (def.dynamicMax === 'premiumSymbols') {
          const base = state.machine.baseSymbolCount || 5;
          const available = (state.machine.symbols || []).filter(entry => entry.key !== 'wild').length;
          return Math.max(0, available - base);
        }
        if (def.dynamicMax === 'cullSymbols') {
          const base = state.machine.baseSymbolCount || 5;
          return Math.max(0, base - 1);
        }
        return Number.isFinite(def.max) ? def.max : 0;
      };

      const computeActiveSymbols = (upgrades = state.upgrades) => {
        const list = (state.machine.symbols || []).filter(entry => entry.key !== 'wild');
        const disable = Math.max(0, Math.floor(upgrades.disable || 0));
        const premium = Math.max(0, Math.floor(upgrades.premium || 0));
        const baseCount = state.machine.baseSymbolCount || 5;
        const start = Math.min(disable, list.length - 1);
        const count = Math.min(list.length - start, baseCount + premium);
        const pool = list.slice(start, start + count).map(entry => entry.key);
        if (upgrades.wildUnlock) pool.push('wild');
        return pool;
      };

      const currency = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      });
      const compactCurrency = new Intl.NumberFormat('en-US', {
        notation: 'compact',
        compactDisplay: 'short',
        maximumFractionDigits: 1,
        minimumFractionDigits: 0
      });
      const formatCompactMoney = (value = 0) => {
        const safe = Number.isFinite(value) ? value : 0;
        return `$${compactCurrency.format(safe)}`;
      };
      const compactNumber = new Intl.NumberFormat('en-US', {
        notation: 'compact',
        compactDisplay: 'short',
        maximumFractionDigits: 1,
        minimumFractionDigits: 0
      });
      const formatCompactNumber = (value = 0) => compactNumber.format(Math.max(0, Number.isFinite(value) ? value : 0));
      const formatTime = (ms = 0) => {
        const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
        const m = Math.floor(totalSeconds / 60);
        const s = totalSeconds % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      };
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const resolveMaxBet = (incoming) => {
        const numeric = Number(incoming);
        if (Number.isFinite(numeric) && numeric > 0) return numeric;
        if (typeof state !== 'undefined' && Number.isFinite(state.maxBet) && state.maxBet > 0) return state.maxBet;
        return DEFAULT_MAX_BET;
      };
      const UPGRADE_COST_GROWTH = 1.85;
      const computeUpgradeCost = (def, level = 0) => {
        if (!def) return 0;
        const base = def.cost || 0;
        const growth = Number.isFinite(def.costGrowth) ? def.costGrowth : UPGRADE_COST_GROWTH;
        const step = Math.max(0, Math.floor(level));
        return Math.round(base * Math.pow(Math.max(1, growth), step));
      };
      const buildBetSteps = (maxBet = DEFAULT_MAX_BET) => {
        const max = Math.max(1, Math.round(Number(maxBet) || DEFAULT_MAX_BET));
        const stepCount = Math.max(8, Math.min(18, Math.ceil(Math.log10(max) * 4)));
        const ratio = Math.pow(max, 1 / Math.max(1, stepCount - 1));
        const steps = new Set([1, max]);
        for (let i = 1; i < stepCount - 1; i += 1) {
          const value = Math.max(1, Math.round(Math.pow(ratio, i)));
          steps.add(value);
        }
        return Array.from(steps).sort((a, b) => a - b);
      };
      let betSteps = buildBetSteps(DEFAULT_MAX_BET);
      const getNearestBetIndex = (value) => {
        const steps = betSteps.length ? betSteps : buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        let bestIndex = 0;
        let bestDelta = Infinity;
        steps.forEach((step, idx) => {
          const delta = Math.abs(step - value);
          if (delta < bestDelta) {
            bestDelta = delta;
            bestIndex = idx;
          }
        });
        return bestIndex;
      };
      const betFromIndex = (index) => {
        const steps = betSteps.length ? betSteps : buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        const clamped = clamp(Math.round(index), 0, Math.max(0, steps.length - 1));
        return steps[clamped] || 1;
      };
      const syncBetSteps = () => {
        betSteps = buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        if (els.betSlider) {
          els.betSlider.min = 0;
          els.betSlider.max = Math.max(0, betSteps.length - 1);
          els.betSlider.step = 1;
          els.betSlider.value = getNearestBetIndex(state.bet);
        }
      };
      const isAutoSpinUnlocked = () => (state.upgrades.autoSpinUnlock || 0) > 0;
      const getAutoSpinCount = () => {
        const level = Math.max(0, state.upgrades.autoSpinCount || 0);
        return 5 + level * 5;
      };

      const els = {
        connectionPill: document.getElementById('connection-pill'),
        connectionText: document.getElementById('connection-text'),
        slotGrid: document.getElementById('slot-grid'),
        lineOverlay: document.getElementById('line-overlay'),
        lineFlashBtn: document.getElementById('line-flash-btn'),
        spinBtn: document.getElementById('spin-btn'),
        autoSpinBtn: document.getElementById('auto-spin-btn'),
        resetBtn: document.getElementById('reset-btn'),
        syncBtn: document.getElementById('sync-btn'),
        alert: document.getElementById('alert'),
        error: document.getElementById('error'),
        machineOutcome: document.getElementById('machine-outcome'),
        machineLines: document.getElementById('machine-lines'),
        reelStage: document.getElementById('reel-stage'),
        betSlider: document.getElementById('bet-range'),
        chipButtons: Array.from(document.querySelectorAll('[data-chip]')),
        hudBalance: document.getElementById('hud-balance'),
        hudBet: document.getElementById('hud-bet'),
        hudWin: document.getElementById('hud-win'),
        hudVip: document.getElementById('hud-vip'),
        balance: document.getElementById('balance'),
        playerId: document.getElementById('player-id'),
        maxBet: document.getElementById('max-bet'),
        spinCount: document.getElementById('spin-count'),
        lastOutcome: document.getElementById('last-outcome'),
        lastWin: document.getElementById('last-win'),
        lastMult: document.getElementById('last-multiplier'),
        lastTime: document.getElementById('last-time'),
        log: document.getElementById('log'),
        paytable: document.getElementById('paytable'),
        dropLog: document.getElementById('drop-log'),
        dropPanel: document.getElementById('drop-panel'),
        dropRatesBtn: document.getElementById('drop-rates-btn'),
        dropSkillBtn: document.getElementById('drop-skill-btn'),
        dropCloseBtn: document.getElementById('drop-close-btn'),
        inventoryGrid: document.getElementById('inventory-grid'),
        dailyStatus: document.getElementById('daily-status'),
        dailyRewardMain: document.getElementById('daily-reward-main'),
        dailyItems: document.getElementById('daily-items'),
        dailyClaimBtn: document.getElementById('daily-claim-btn'),
        dailyNextReset: document.getElementById('daily-next-reset'),
        dailyStreak: document.getElementById('daily-streak'),
        bonusList: document.getElementById('bonus-list'),
        authOverlay: document.getElementById('auth-overlay'),
        authBody: document.getElementById('auth-body'),
        authAlert: document.getElementById('auth-alert'),
        authEmail: document.getElementById('auth-email'),
        authPassword: document.getElementById('auth-password'),
        authConfirmGroup: document.getElementById('auth-confirm-group'),
        authConfirm: document.getElementById('auth-confirm'),
        authSubmit: document.getElementById('auth-submit'),
        authInfo: document.getElementById('auth-info'),
        authTabs: Array.from(document.querySelectorAll('.auth-tab')),
        authOverlayNote: document.getElementById('auth-note'),
        accountPanel: document.getElementById('account-panel'),
        accountToggle: document.getElementById('account-toggle'),
        accountClose: document.getElementById('account-close'),
        accountUser: document.getElementById('account-user'),
        logoutBtn: document.getElementById('logout-btn'),
        deleteBtn: document.getElementById('delete-account-btn'),
        debugCoinBtn: document.getElementById('debug-add-coins'),
        upgradeGrid: document.getElementById('upgrade-grid'),
        upgradePanel: document.getElementById('upgrade-panel'),
        mobileNav: document.getElementById('mobile-nav')
      };
      const paneState = {
        mq: window.matchMedia('(max-width: 768px)'),
        active: 'play'
      };
      const mobileButtons = Array.from(els.mobileNav?.querySelectorAll('[data-mobile-target]') || []);
      const desktopButtons = Array.from(document.querySelectorAll('[data-pane-target]'));
      const mobilePanes = Array.from(document.querySelectorAll('[data-mobile-pane]'));
      const applyPaneMode = () => {
        const isMobile = paneState.mq.matches;
        document.body.dataset.mobile = isMobile ? 'true' : 'false';
        if (root) {
          root.dataset.tabs = 'true';
          root.dataset.paneMode = 'tabbed';
          root.dataset.activePane = paneState.active;
        }
        const allButtons = [...mobileButtons, ...desktopButtons];
        allButtons.forEach(btn => {
          const target = btn.dataset.mobileTarget || btn.dataset.paneTarget;
          btn.classList.toggle('active', target === paneState.active);
        });
        mobilePanes.forEach(pane => {
          const paneId = pane.dataset.mobilePane || 'play';
          const active = paneId === paneState.active;
          pane.dataset.mobileActive = active ? 'true' : 'false';
        });
      };
      const setPaneActive = (target) => {
        if (target) {
          paneState.active = target;
        }
        if (root) {
          root.dataset.activePane = paneState.active;
        }
        applyPaneMode();
      };
      mobileButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          setPaneActive(btn.dataset.mobileTarget);
        });
      });
      desktopButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          setPaneActive(btn.dataset.paneTarget);
        });
      });
      if (paneState.mq.addEventListener) {
        paneState.mq.addEventListener('change', applyPaneMode);
      } else if (paneState.mq.addListener) {
        paneState.mq.addListener(applyPaneMode);
      }
      applyPaneMode();
      loadUpgradeCatalog();
      els.accountToggle?.addEventListener('click', () => toggleAccountSheet(true));
      els.accountClose?.addEventListener('click', () => toggleAccountSheet(false));
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (!els.accountPanel?.hidden) {
            toggleAccountSheet(false);
          }
          if (!els.dropPanel?.hidden) {
            toggleDropPanel(false);
          }
        }
      });
      const probedSymbols = new Set();
      const reelState = new Map();
      let pendingWinGroups = [];
      let pendingSpinResult = null;
      let activeReelLocks = 0;
      const getPlaceholderAsset = () => state?.machine?.assets?.placeholder || state?.machine?.placeholder || PLACEHOLDER_ASSET;
      const auditSymbolAssets = () => {
        state.symbolMap.forEach(entry => {
          if (!entry || !entry.key || !entry.asset || probedSymbols.has(entry.key)) return;
          probedSymbols.add(entry.key);
          const img = new Image();
          img.addEventListener('load', () => {
            debug('asset:load-ok', { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.addEventListener('error', () => {
            debugError('asset:load-failed', new Error('Failed to load symbol asset'), { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.src = entry.asset;
        });
      };
      const attachImageDebugging = (img, symbolKey) => {
        if (!img || img.dataset.debugAttached) return;
        img.dataset.debugAttached = 'true';
        img.addEventListener('error', () => {
          debugError('image', new Error('Image failed to load'), { symbol: symbolKey || img.dataset.symbolKey || img.alt, src: img.currentSrc || img.src });
          img.src = getPlaceholderAsset();
        });
      };
      const getSymbolEntry = (symbolKey) => {
        if (!symbolKey) {
          return { key: 'placeholder', label: 'Symbol', asset: getPlaceholderAsset() };
        }
        const entry = state.symbolMap.get(symbolKey) || DEFAULT_SYMBOL_MAP.get(symbolKey);
        if (entry) {
          return { ...entry, asset: entry.asset || getPlaceholderAsset() };
        }
        return { key: symbolKey, label: symbolKey, asset: getPlaceholderAsset() };
      };
      const applySymbolToImage = (img, symbolKey) => {
        const info = getSymbolEntry(symbolKey);
        if (!img) return info;
        const needsUpdate = img.dataset.symbolKey !== info.key || img.dataset.symbolAsset !== info.asset;
        if (needsUpdate) {
          img.dataset.symbolKey = info.key;
          img.dataset.symbolAsset = info.asset;
          img.alt = info.label || info.key;
          img.src = info.asset || getPlaceholderAsset();
          if (!info.asset || info.asset === getPlaceholderAsset()) {
            debug('symbol:placeholder-used', { symbol: info.key, reason: 'missing asset' });
          }
        }
        attachImageDebugging(img, info.key);
        return info;
      };
      const upgradeDefinitions = {
        rows: {
          label: 'Extra Rows',
          description: 'Adds another horizontal row so more lines can form.',
          format: (current, max) => `${current}/${max} rows`
        },
        reels: {
          label: 'Extra Reels',
          description: 'Extends the machine vertically for longer combos.',
          format: (current, max) => `${current}/${max} reels`
        },
        lines: {
          label: 'Line Patterns',
          description: 'Unlocks diagonal and zig-zag paylines.',
          format: (current, max) => `${current}/${max} tiers`
        }
      };
      const getUpgradeSettings = () => {
        const defaults = {
          baseRows: 3,
          maxRows: 5,
          baseReels: 3,
          maxReels: 5,
          costs: { rows: [], reels: [], lines: [] }
        };
        const settings = state.machine.upgradeSettings || state.machine.upgrades || {};
        return {
          baseRows: settings.baseRows ?? defaults.baseRows,
          maxRows: settings.maxRows ?? defaults.maxRows,
          baseReels: settings.baseReels ?? defaults.baseReels,
          maxReels: settings.maxReels ?? defaults.maxReels,
          costs: settings.costs || defaults.costs
        };
      };
      state.playerId = state.auth.token ? null : getStored(storageKeys.player);

      const log = (message, data) => {
        debug('ui-log', { message, data, stateSnapshot: { busy: state.busy, auth: !!state.auth.token } });
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<strong>${time}</strong> ‚Äî ${message}${data ? `<br><span>${data}</span>` : ''}`;
        els.log.prepend(entry);
        const entries = els.log.querySelectorAll('.log-entry');
        if (entries.length > 40) {
          entries[entries.length - 1].remove();
        }
      };

      const setStatus = (text, stateAttr = 'ok') => {
        debug('ui:setStatus', { text, stateAttr });
        if (!els.connectionPill || !els.connectionText) return;
        els.connectionText.textContent = text;
        els.connectionPill.dataset.state = stateAttr;
        els.connectionPill.setAttribute('data-state', stateAttr === 'ok' ? 'ok' : stateAttr);
      };

      const showAlert = (text = '') => {
        els.alert.hidden = !text;
        els.alert.textContent = text;
        if (text) debug('ui:alert', text);
      };

      const showAuthAlert = (text = '') => {
        if (text) debug('auth:alert', text);
        if (!els.authAlert) return;
        els.authAlert.hidden = !text;
        els.authAlert.textContent = text;
        if (text) {
          requestFrame(() => {
            els.authAlert?.scrollIntoView?.({ block: 'nearest', behavior: 'smooth' });
            els.authAlert?.focus?.({ preventScroll: false });
          });
        }
      };

      const gamePanels = Array.from(document.querySelectorAll('[data-requires-auth]'));

      const setGameVisibility = (visible) => {
        debug('ui:setGameVisibility', { visible });
        state.gameReady = visible;
        gamePanels.forEach(panel => {
          panel.hidden = !visible;
        });
        if (!visible) {
          toggleAccountSheet(false);
          toggleDropPanel(false);
        }
        const disableInputs = !visible || state.busy;
        els.spinBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.resetBtn) els.resetBtn.disabled = disableInputs;
        if (els.dropRatesBtn) els.dropRatesBtn.disabled = disableInputs;
        renderUpgrades();
        renderSkillButton();
        renderDaily();
        renderBonusSummary();
        renderAutoSpinButton();
        applyPaneMode();
        if (visible) startIdleTicker();
        else stopIdleTicker();
        if (visible) startSkillTicker();
        else stopSkillTicker();
      };

      const setBusy = (flag) => {
        debug('ui:setBusy', { flag, prev: state.busy });
        state.busy = flag;
        const disableInputs = flag || !state.gameReady;
        els.spinBtn.disabled = disableInputs;
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.dropRatesBtn) els.dropRatesBtn.disabled = disableInputs;
        if (disableInputs) toggleDropPanel(false);
        renderUpgrades();
        renderSkillButton();
        renderDaily();
        renderBonusSummary();
        renderAutoSpinButton();
      };

      const toggleAuthInputs = (disabled) => {
        [els.authEmail, els.authPassword, els.authConfirm, els.authSubmit, els.authInfo].forEach(node => {
          if (node) node.disabled = disabled;
        });
        (els.authTabs || []).forEach(btn => {
          btn.disabled = disabled;
        });
      };

      const toggleAccountSheet = (force) => {
        if (!els.accountPanel) return;
        const shouldShow = typeof force === 'boolean' ? force : els.accountPanel.hidden;
        els.accountPanel.hidden = !shouldShow;
        els.accountPanel.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
        if (shouldShow) {
          els.accountPanel.focus({ preventScroll: false });
        }
      };

      const randomSymbolInfo = () => {
        let pool = [];
        if (Array.isArray(state.machine.activeSymbols) && state.machine.activeSymbols.length) {
          pool = state.machine.activeSymbols.map(key => getSymbolEntry(key)).filter(Boolean);
        }
        if (!pool.length || pool.length < 3) {
          pool = Array.from(state.symbolMap.values());
        }
        if (!pool.length) {
          return getSymbolEntry('placeholder');
        }
        return pool[Math.floor(Math.random() * pool.length)];
      };

      const describeUpgradeExtra = (key) => {
        const settings = getUpgradeSettings();
        switch (key) {
          case 'rows':
            return `${state.currentRows || settings.baseRows}/${settings.maxRows} rows`;
          case 'reels':
            return `${state.currentReels || settings.baseReels}/${settings.maxReels} reels`;
          case 'lines': {
            const tier = state.currentLineTier ?? 0;
            return `Tier ${tier}`;
          }
          case 'idle':
            return `Idle +${state.upgrades.idle || 0}/sec`;
          case 'speed':
            return `${(state.upgrades.speed || 0) * 10}% faster`;
          case 'retrigger':
            return `${(state.upgrades.retrigger || 0) * 5}% chance`;
          case 'dropBoost':
            return `${(state.upgrades.dropBoost || 0) * 5}% drops`;
          case 'premium': {
            const active = state.machine.activeSymbols?.length || 0;
            return `${active} symbols active`;
          }
          case 'betMultiplier':
            return `Max bet ${currency.format(state.maxBet || DEFAULT_MAX_BET)}`;
          default:
            return '';
        }
      };

      const buildUpgradeCard = (def) => {
        const loggedIn = Boolean(state.auth.token);
        const level = Math.max(0, state.upgrades?.[def.key] || 0);
        const maxLevel = Math.max(0, getUpgradeMaxLevel(def.key));
        const reqs = def.requires ? (Array.isArray(def.requires) ? def.requires : [def.requires]) : [];
        const requirementsMet = reqs.every(req => (state.upgrades?.[req] || 0) > 0);
        const locked = reqs.length > 0 && !requirementsMet;
        const currentLabel = level > 0
          ? (def.levels?.[level - 1] || `Level ${level}`)
          : 'Not unlocked';
        const nextLabel = level >= maxLevel
          ? 'Maxed'
          : (def.levels?.[level] || `Level ${level + 1}`);
        const cost = level >= maxLevel ? null : computeUpgradeCost(def, level);
        const buttonDisabled = !loggedIn || state.busy || locked || level >= maxLevel || !Number.isFinite(cost);
        const buttonText = locked
          ? 'Locked'
          : level >= maxLevel
            ? 'Maxed'
            : `Unlock (${currency.format(cost)})`;
        const requirementNote = locked
          ? `Requires ${reqs.map(req => getUpgradeDef(req)?.label || req).join(', ')}`
          : '';
        const extra = describeUpgradeExtra(def.key);
        return `
          <div class="upgrade-card" data-upgrade-key="${def.key}">
            <h4>${def.label}</h4>
            <p>${def.description}</p>
            <div class="upgrade-card__meta">
              <span>Level ${Math.min(level, maxLevel)}/${maxLevel}</span>
              ${extra ? `<span>${extra}</span>` : ''}
            </div>
            <div class="upgrade-card__note">Current: ${currentLabel}</div>
            <div class="upgrade-card__note">Next: ${nextLabel}</div>
            <button type="button" data-upgrade="${def.key}" ${buttonDisabled ? 'data-disabled="true" disabled' : ''}>${buttonText}</button>
            ${requirementNote ? `<div class="upgrade-card__note">${requirementNote}</div>` : ''}
          </div>
        `;
      };

      const renderUpgrades = () => {
        if (!els.upgradeGrid) return;
        const loggedIn = Boolean(state.auth.token);
        if (els.upgradePanel) {
          els.upgradePanel.hidden = !state.gameReady || !loggedIn;
        }
        if (!loggedIn) {
          els.upgradeGrid.innerHTML = '<p class="muted-text">Sign in to manage upgrades.</p>';
          return;
        }
        if (!state.upgradeCatalog.length) {
          els.upgradeGrid.innerHTML = '<p class="muted-text">Loading upgrades‚Ä¶</p>';
          return;
        }
        const grouped = state.upgradeCatalog.reduce((acc, def) => {
          if (!acc[def.category]) acc[def.category] = [];
          acc[def.category].push(def);
          return acc;
        }, {});
        const categoryOrder = ['Economy', 'Spin', 'Layout', 'Symbols', 'Drops', 'Skills'];
        const seen = new Set();
        const sections = [];
        [...categoryOrder, ...Object.keys(grouped)].forEach(category => {
          if (!category || seen.has(category)) return;
          seen.add(category);
          const defs = grouped[category];
          if (!defs || !defs.length) return;
          sections.push(`
            <div class="upgrade-category" data-category="${category}">
              <h3>${category}</h3>
              <div class="upgrade-grid">
                ${defs.map(buildUpgradeCard).join('')}
              </div>
            </div>
          `);
        });
        els.upgradeGrid.innerHTML = sections.join('') || '<p class="muted-text">No upgrades available.</p>';
      };

      const DROP_ITEM_NAMES = {
        goldChip: 'Golden Chip',
        scratchCard: 'Scratch Card',
        circuit: 'Circuit',
        inventorySlotCoupon: 'Inventory Slot Coupon',
        gearSlotCoupon: 'Gear Slot Coupon',
        storageSlotCoupon: 'Storage Slot Coupon',
        deckSlotCoupon: 'Deck Slot Coupon',
        cardSlotCoupon: 'Card Slot Coupon',
        vipMarks: 'VIP Mark',
        reelMod: 'Reel Mod',
        spinBooster: 'Spin Booster',
        card: 'Card',
        gear: 'Gear'
      };
      const DROP_ITEM_ICONS = {
        goldChip: 'img/slot/items/gold_chip.png',
        scratchCard: 'img/slot/items/scratch_card.png',
        circuit: 'img/slot/items/circuit.png',
        inventorySlotCoupon: 'img/slot/items/inventory_slot_coupon.png',
        gearSlotCoupon: 'img/slot/items/gear_slot_coupon.png',
        storageSlotCoupon: 'img/slot/items/storage_slot_coupon.png',
        deckSlotCoupon: 'img/slot/items/deck_slot_coupon.png',
        cardSlotCoupon: 'img/slot/items/card_slot_coupon.png',
        vipMarks: 'img/slot/items/vip_mark.png',
        reelMod: 'img/slot/items/reel_mod_t1.png',
        spinBooster: 'img/slot/items/spinBoosterT1.png',
        card: 'img/slot/items/card.png',
        gear: 'img/slot/items/gear.png'
      };
      const DROP_TIER_ORDER = ['common', 'rare', 'epic'];
      const MAX_DROP_HISTORY = 25;
      const dropPercent = (value = 0) => `${(Math.min(1, Math.max(0, value)) * 100).toFixed(2)}%`;

      const normalizeDrop = (entry = {}) => {
        const type = entry.type || 'item';
        const name = entry.name || DROP_ITEM_NAMES[type] || type;
        const icon = entry.icon || DROP_ITEM_ICONS[type] || getPlaceholderAsset();
        const amount = Number.isFinite(entry.amount) ? entry.amount : 1;
        return {
          type,
          amount,
          name,
          icon,
          rarity: entry.rarity,
          tier: entry.tier
        };
      };

      const inventoryMeta = (key = '') => {
        const [type, variant] = key.split(':');
        switch (type) {
          case 'gear':
            return { name: `${variant || 'Basic'} Gear`, icon: DROP_ITEM_ICONS.gear };
          case 'card':
            return { name: `${variant || 'Card'} Card`, icon: DROP_ITEM_ICONS.card };
          case 'reelMod':
            return { name: `Reel Mod ${variant ? `T${variant}` : ''}`.trim(), icon: DROP_ITEM_ICONS.reelMod };
          case 'spinBooster':
            return { name: `Spin Booster ${variant ? `T${variant}` : ''}`.trim(), icon: DROP_ITEM_ICONS.spinBooster };
          default:
            return { name: DROP_ITEM_NAMES[type] || type || 'Item', icon: DROP_ITEM_ICONS[type] || getPlaceholderAsset() };
        }
      };

      const applyDropState = (dropState = {}) => {
        if (!dropState || typeof dropState !== 'object') return;
        if (dropState.tableKey) state.drop.tableKey = dropState.tableKey;
        if (dropState.table) state.drop.table = dropState.table;
        if (dropState.tierWeights) {
          state.drop.tierWeights = { ...state.drop.tierWeights, ...dropState.tierWeights };
        }
        if (dropState.constants) {
          const c = dropState.constants;
          state.drop.constants = {
            ...state.drop.constants,
            betScale: Number(c.BET_DROP_SCALE ?? c.betScale ?? state.drop.constants.betScale),
            win: Number(c.WIN_DROP_MULT ?? c.win ?? state.drop.constants.win),
            lose: Number(c.LOSE_DROP_MULT ?? c.lose ?? state.drop.constants.lose),
            boostScale: Number(c.DROP_BOOST_SCALE ?? c.boostScale ?? state.drop.constants.boostScale)
          };
        }
        if (dropState.inventory) {
          state.drop.inventory = { ...dropState.inventory };
        }
        if (Array.isArray(dropState.lastDrops) && dropState.lastDrops.length && !state.drop.history.length) {
          recordDrops(dropState.lastDrops, Date.now());
        } else {
          renderDropLog();
        }
        updateSkillSpec();
        renderSkillButton();
        renderInventory();
        updateHud();
        renderBonusSummary();
      };

      const recordDrops = (drops = [], timestamp = Date.now()) => {
        if (!Array.isArray(drops) || !drops.length) return;
        const ts = Number.isFinite(timestamp) ? timestamp : Date.now();
        if (ts <= (state.drop.lastTimestamp || 0)) {
          state.drop.lastDrops = drops.map(normalizeDrop);
          return;
        }
        const normalized = drops.map(normalizeDrop);
        state.drop.lastDrops = normalized;
        state.drop.lastTimestamp = ts;
        state.drop.history.unshift({ timestamp: ts, drops: normalized });
        if (state.drop.history.length > MAX_DROP_HISTORY) {
          state.drop.history.length = MAX_DROP_HISTORY;
        }
        renderDropLog();
      };

      const renderInventory = () => {
        if (!els.inventoryGrid) return;
        const entries = Object.entries(state.drop.inventory || {}).filter(([, count]) => Number(count) > 0);
        if (!entries.length) {
          els.inventoryGrid.innerHTML = '<span class="muted-text">No drops yet.</span>';
          return;
        }
        entries.sort((a, b) => b[1] - a[1]);
        const chips = entries.slice(0, 6).map(([key, count]) => {
          const meta = inventoryMeta(key);
          return `
            <span class="inventory-chip" data-key="${key}">
              <img src="${meta.icon}" alt="${meta.name}">
              <span>${meta.name}</span>
              <strong class="drop-amount">√ó${count}</strong>
            </span>
          `;
        });
        els.inventoryGrid.innerHTML = chips.join('');
      };

      const renderDropLog = () => {
        if (!els.dropLog) return;
        const history = state.drop.history || [];
        if (!history.length) {
          els.dropLog.textContent = 'Spin to collect items.';
          return;
        }
        const rows = history.slice(0, 8).map(entry => {
          const time = new Date(entry.timestamp).toLocaleTimeString();
          const parts = entry.drops.map(drop => {
            const info = normalizeDrop(drop);
            return `<span class="rate-item"><img class="drop-icon" src="${info.icon}" alt="${info.name}">${info.name} √ó${info.amount}</span>`;
          }).join(', ');
          return `<div class="drop-entry"><strong>${time}</strong><span aria-hidden="true">‚Äî</span><span>${parts}</span></div>`;
        });
        els.dropLog.innerHTML = rows.join('');
      };

      const getDropTable = () => state.drop.table || { common: [], rare: [], epic: [] };
      const getTierWeights = () => state.drop.tierWeights || { common: 0.8, rare: 0.15, epic: 0.05 };

      const isDropSkillActive = () => {
        const skill = state.skills.dropRate;
        if (!skill) return false;
        const now = Date.now();
        if (skill.active && skill.expiresAt && now >= skill.expiresAt) {
          skill.active = false;
        }
        if (!skill.active && skill.expiresAt && now >= skill.expiresAt) {
          skill.expiresAt = 0;
        }
        if (skill.cooldownUntil && now >= skill.cooldownUntil) {
          skill.cooldownUntil = 0;
        }
        return skill.active;
      };

      const getDropMultiplier = (win = false) => {
        const constants = state.drop.constants || {};
        const betScale = Number(constants.betScale) || 0.1;
        const boostScale = Number(constants.boostScale) || 0.05;
        const winMult = Number(constants.win) || 2;
        const loseMult = Number(constants.lose) || 1;
        const dropBoost = Math.max(0, state.upgrades.dropBoost || 0);
        const base = 1 + boostScale * dropBoost;
        const bet = Math.max(0, state.bet || 1);
        const betMult = 1 + betScale * Math.log(1 + bet);
        const skillMult = isDropSkillActive() ? (state.skills.dropRate?.spec?.multiplier || 1) : 1;
        const outcome = win ? winMult : loseMult;
        return {
          total: base * betMult * skillMult * outcome,
          components: { base, bet: betMult, skill: skillMult, outcome }
        };
      };

      const computeDropRates = (mult = 1) => {
        const table = getDropTable();
        const tiers = DROP_TIER_ORDER.filter(tier => Array.isArray(table[tier]) && table[tier].length);
        const weights = tiers.map(tier => getTierWeights()[tier] || 0);
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0) || 1;
        const rates = [];
        tiers.forEach((tier, idx) => {
          const tierProb = (weights[idx] || 0) / totalWeight;
          (table[tier] || []).forEach(entry => {
            const baseChance = Math.max(0, Number(entry.chance) || 0);
            const chance = Math.min(1, baseChance * mult) * tierProb;
            const drop = normalizeDrop(entry);
            rates.push({ ...drop, chance, tier });
          });
        });
        return rates.sort((a, b) => b.chance - a.chance);
      };

      const renderDropPanel = () => {
        if (!els.dropPanel) return;
        const lossMult = getDropMultiplier(false);
        const winMult = getDropMultiplier(true);
        const rates = computeDropRates(winMult.total);
        if (!rates.length) {
          els.dropPanel.innerHTML = '<p class="muted-text">Drop table not loaded yet.</p>';
          return;
        }
        const groups = DROP_TIER_ORDER.map(tier => ({
          tier,
          list: rates.filter(rate => rate.tier === tier)
        })).filter(group => group.list.length);
        const listHtml = groups.map(group => `
          <p class="drop-tier-label">${group.tier}</p>
          <ul>
            ${group.list.map(rate => `
              <li>
                <span class="rate-item"><img class="drop-icon" src="${rate.icon}" alt="${rate.name}">${rate.name}</span>
                <span class="drop-amount">${dropPercent(rate.chance)}</span>
              </li>
            `).join('')}
          </ul>
        `).join('');
        els.dropPanel.innerHTML = `
          <h4>Drop rates</h4>
          <p class="drop-mult">Win: ${winMult.total.toFixed(2)}√ó ‚Ä¢ Loss: ${lossMult.total.toFixed(2)}√ó</p>
          ${listHtml || '<p class="muted-text">No drops configured.</p>'}
        `;
      };

      const toggleDropPanel = (force) => {
        if (!els.dropPanel) return;
        const willShow = typeof force === 'boolean' ? force : els.dropPanel.hidden;
        if (willShow) renderDropPanel();
        els.dropPanel.hidden = !willShow;
        if (!willShow) {
          els.dropRatesBtn?.focus?.();
        }
      };

      const renderSkillButton = () => {
        if (!els.dropSkillBtn) return;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        const skill = state.skills.dropRate;
        els.dropSkillBtn.hidden = !unlocked;
        if (!unlocked) return;
        const now = Date.now();
        const busy = state.busy || !state.gameReady;
        let label = 'Drop boost';
        if (skill.active && skill.expiresAt > now) {
          label = `Drop boost active (${formatTime(skill.expiresAt - now)})`;
          els.dropSkillBtn.dataset.state = 'active';
          els.dropSkillBtn.disabled = busy;
        } else if (skill.cooldownUntil && skill.cooldownUntil > now) {
          label = `Cooldown ${formatTime(skill.cooldownUntil - now)}`;
          els.dropSkillBtn.dataset.state = 'cooldown';
          els.dropSkillBtn.disabled = true;
        } else {
          els.dropSkillBtn.dataset.state = 'ready';
          els.dropSkillBtn.disabled = busy;
          const boost = Math.round(((state.skills.dropRate?.spec?.multiplier || 1) - 1) * 100);
          if (boost > 0) label = `Drop boost +${boost}%`;
        }
        els.dropSkillBtn.textContent = label;
      };

      const updateSkillSpec = () => {
        const effect = Math.max(0, state.upgrades.dropRateEffect || 0);
        const duration = Math.max(0, state.upgrades.dropRateDuration || 0);
        const baseBoost = state.drop.constants?.boostScale || 0.05;
        const durationMs = 60000 * (1 + duration);
        const cooldownMs = durationMs * 2;
        const multiplier = 1 + baseBoost * (1 + effect);
        state.skills.dropRate.spec = { durationMs, cooldownMs, multiplier };
        renderSkillButton();
      };

      const tickSkills = () => {
        isDropSkillActive();
        renderSkillButton();
        renderBonusSummary();
      };

      let skillTimer = null;
      const startSkillTicker = () => {
        if (skillTimer) return;
        skillTimer = setInterval(tickSkills, 500);
      };
      const stopSkillTicker = () => {
        if (skillTimer) {
          clearInterval(skillTimer);
          skillTimer = null;
        }
      };

      function applyDailyState(dailyPayload = {}, rewardOverride = null) {
        const current = state.daily || {};
        const reward = rewardOverride || dailyPayload.todayReward || current.todayReward || null;
        const normalizedReward = reward
          ? { ...reward, drops: Array.isArray(reward.drops) ? reward.drops.map(normalizeDrop) : [] }
          : null;
        const ready = dailyPayload.ready !== undefined
          ? Boolean(dailyPayload.ready)
          : (!dailyPayload.claimedToday && (current.ready ?? true));
        state.daily = {
          streak: Number.isFinite(dailyPayload.streak) ? dailyPayload.streak : (current.streak || 1),
          claimedToday: Boolean(dailyPayload.claimedToday ?? current.claimedToday),
          ready,
          lastClaimMs: Number.isFinite(dailyPayload.lastClaimMs) ? Number(dailyPayload.lastClaimMs) : (current.lastClaimMs || 0),
          nextResetAt: Number.isFinite(dailyPayload.nextResetAt) ? Number(dailyPayload.nextResetAt) : (current.nextResetAt || 0),
          todayReward: normalizedReward
        };
        renderDaily();
      }

      function renderDaily() {
        if (!els.dailyStatus) return;
        const daily = state.daily || {};
        const reward = daily.todayReward;
        const ready = !daily.claimedToday && (daily.ready !== false);
        els.dailyStatus.textContent = ready ? 'Ready to claim' : 'Claimed';
        els.dailyStatus.dataset.state = ready ? 'ok' : 'muted';
        if (els.dailyStreak) {
          const day = Math.max(1, Math.floor(daily.streak || 1));
          els.dailyStreak.textContent = `Day ${day} of ${DAILY_LENGTH}`;
        }
        if (els.dailyRewardMain) {
          const parts = [];
          if (reward?.vipMarks) parts.push(`${reward.vipMarks} VIP`);
          if (reward?.credits) parts.push(currency.format(reward.credits));
          els.dailyRewardMain.textContent = parts.join(' ‚Ä¢ ') || 'Come back daily for prizes.';
        }
        if (els.dailyItems) {
          const drops = reward?.drops || [];
          if (!drops.length) {
            els.dailyItems.innerHTML = '<span class="muted-text">VIP marks and credits await.</span>';
          } else {
            els.dailyItems.innerHTML = drops.map(drop => {
              const info = normalizeDrop(drop);
              return `<span class="daily-item"><img src="${info.icon}" alt="${info.name}">${info.name} √ó${info.amount}</span>`;
            }).join('');
          }
        }
        if (els.dailyNextReset) {
          const nextReset = daily.nextResetAt ? new Date(daily.nextResetAt).toLocaleTimeString() : 'midnight';
          els.dailyNextReset.textContent = `Resets at ${nextReset}`;
        }
        if (els.dailyClaimBtn) {
          const disabled = !ready || state.busy || !state.gameReady || !state.auth.token;
          els.dailyClaimBtn.disabled = disabled;
        }
      }

      function renderBonusSummary() {
        if (!els.bonusList) return;
        const entries = [];
        const winMult = getDropMultiplier(true);
        const lossMult = getDropMultiplier(false);
        entries.push({
          label: 'Drop boost',
          value: `${winMult.total.toFixed(2)}√ó / ${lossMult.total.toFixed(2)}√ó`,
          note: 'Win / loss multiplier (bet, skill, upgrade)'
        });
        const idle = Math.max(0, state.upgrades.idle || 0);
        entries.push({
          label: 'Idle income',
          value: idle ? `+${idle}/s` : 'Locked',
          note: idle ? 'Earned passively while away' : 'Upgrade Idle Coins to start earning'
        });
        const maxBetMult = (state.maxBet || DEFAULT_MAX_BET) / DEFAULT_MAX_BET;
        entries.push({
          label: 'Max bet',
          value: `${maxBetMult.toFixed(1)}√ó`,
          note: `Cap ${currency.format(state.maxBet || DEFAULT_MAX_BET)}`
        });
        const rows = state.currentRows || state.machine?.rows || 3;
        const reels = state.currentReels || state.machine?.reels || 3;
        entries.push({
          label: 'Layout',
          value: `${rows} rows ¬∑ ${reels} reels`,
          note: `Line tier ${state.currentLineTier ?? 0}`
        });
        const skill = state.skills.dropRate?.spec;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        if (unlocked || skill) {
          const durationMin = skill ? Math.max(1, Math.round((skill.durationMs || 0) / 60000)) : 1;
          entries.push({
            label: 'Drop skill',
            value: isDropSkillActive() ? 'Boost active' : 'Ready',
            note: `${(skill?.multiplier || 1).toFixed(2)}√ó for ${durationMin}m`
          });
        }
        const html = entries.map(entry => `
          <li class="bonus-item">
            <div>
              <p class="bonus-label">${entry.label}</p>
              ${entry.note ? `<p class="bonus-note">${entry.note}</p>` : ''}
            </div>
            <strong class="bonus-value">${entry.value}</strong>
          </li>
        `).join('');
        els.bonusList.innerHTML = html || '<li class="bonus-item"><span class="bonus-label">No bonuses yet.</span></li>';
      }

      const renderAutoSpinButton = () => {
        if (!els.autoSpinBtn) return;
        const unlocked = isAutoSpinUnlocked();
        const count = getAutoSpinCount();
        els.autoSpinBtn.textContent = unlocked ? `Auto (${count})` : 'Auto';
        els.autoSpinBtn.disabled = !state.gameReady || state.busy || !unlocked;
        els.autoSpinBtn.setAttribute('aria-pressed', state.autoSpin.active ? 'true' : 'false');
      };

      const activateDropSkill = () => {
        if (!state.gameReady || state.busy) return;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        if (!unlocked) {
          showAlert('Unlock the drop boost skill first.');
          return;
        }
        const skill = state.skills.dropRate;
        const now = Date.now();
        if (!skill || (skill.cooldownUntil && skill.cooldownUntil > now) || skill.active) {
          return;
        }
        skill.active = true;
        skill.expiresAt = now + (skill.spec?.durationMs || 60000);
        skill.cooldownUntil = skill.expiresAt + (skill.spec?.cooldownMs || 120000);
        log('Drop boost activated', `Running for ${formatTime(skill.expiresAt - now)}.`);
        renderSkillButton();
        if (!els.dropPanel?.hidden) {
          renderDropPanel();
        }
      };

      const dropSkillPayload = () => ({
        dropRate: isDropSkillActive()
      });


      const ensureGrid = (rows, reels) => {
        if (!els.slotGrid) return;
        const currentRows = Number(els.slotGrid.dataset.rows) || 0;
        const currentReels = Number(els.slotGrid.dataset.reels) || 0;
        if (currentRows === rows && currentReels === reels && state.gridCells.size === rows * reels) {
          return;
        }
        debug('grid:rebuild', { rows, reels });
        state.gridCells.clear();
        els.slotGrid.dataset.rows = rows;
        els.slotGrid.dataset.reels = reels;
        els.slotGrid.style.setProperty('--row-count', rows);
        els.slotGrid.style.setProperty('--reel-count', reels);
        els.slotGrid.innerHTML = '';
        reelState.clear();
        for (let col = 0; col < reels; col += 1) {
          const reel = document.createElement('div');
          reel.className = 'slot-reel';
          reel.dataset.col = col.toString();
          reel.style.setProperty('--row-count', rows);
          for (let row = 0; row < rows; row += 1) {
            const cell = document.createElement('div');
            cell.className = 'slot-cell';
            cell.dataset.row = row.toString();
            cell.dataset.col = col.toString();
            const wrapper = document.createElement('div');
            wrapper.className = 'slot-cell__symbol';
            const img = document.createElement('img');
            const seedSymbol = randomSymbolInfo();
            applySymbolToImage(img, seedSymbol.key);
            wrapper.appendChild(img);
            cell.appendChild(wrapper);
            reel.appendChild(cell);
            cell.dataset.symbol = seedSymbol.key;
            state.gridCells.set(`${row}:${col}`, cell);
          }
          els.slotGrid.appendChild(reel);
          reelState.set(col, {
            reel,
            offset: 0,
            speed: 0,
            raf: null,
            spinning: false
          });
        }
      };

      const getCellHeight = () => {
        const sample = els.slotGrid?.querySelector('.slot-cell');
        return sample?.getBoundingClientRect().height || 80;
      };

      const anyReelSpinning = () => Array.from(reelState.values()).some(info => info.spinning);

      const stopReelSpin = (col, finalSymbols = null) => {
        const info = reelState.get(col);
        if (!info) return;
        info.spinning = false;
        if (info.raf) {
          cancelFrame(info.raf);
          info.raf = null;
        }
        info.offset = 0;
        info.reel.style.transform = 'translateY(0px)';
        const rows = state.currentRows || state.machine.rows;
        const symbols = Array.isArray(finalSymbols) && finalSymbols.length
          ? finalSymbols
          : Array.from({ length: rows }, () => randomSymbolInfo().key);
        info.reel.innerHTML = '';
        for (let row = 0; row < rows; row += 1) {
          const cell = document.createElement('div');
          cell.className = 'slot-cell';
          cell.dataset.row = row.toString();
          cell.dataset.col = col.toString();
          const wrapper = document.createElement('div');
          wrapper.className = 'slot-cell__symbol';
          const img = document.createElement('img');
          const key = symbols[row] || randomSymbolInfo().key;
          applySymbolToImage(img, key);
          wrapper.appendChild(img);
          cell.appendChild(wrapper);
          info.reel.appendChild(cell);
          cell.dataset.symbol = key;
          cell.dataset.state = 'settled';
          state.gridCells.set(`${row}:${col}`, cell);
        }
      };

      const spinReel = (col) => {
        const info = reelState.get(col);
        if (!info) return;
        const cellHeight = getCellHeight();
        info.offset = 0;
        info.speed = 9 + col * 1.4;
        info.spinning = true;
        const step = () => {
          if (!info.spinning) return;
          info.offset += info.speed;
          if (info.offset >= cellHeight) {
            info.offset -= cellHeight;
            const last = info.reel.lastElementChild;
            if (last) info.reel.prepend(last);
          }
          info.reel.style.transform = `translateY(${info.offset}px)`;
          info.raf = requestFrame(step);
        };
        info.raf = requestFrame(step);
      };

      const updateMachineMeta = () => {
        if (!els.machineLines) return;
        const settings = getUpgradeSettings();
        const lineTier = state.currentLineTier ?? 0;
        const patterns = Array.isArray(state.machine.lines) ? state.machine.lines : [];
        const lineCount = patterns.filter(def => def.tier <= lineTier).length || patterns.length || 0;
        const rows = state.currentRows || settings.baseRows;
        const reels = state.currentReels || settings.baseReels;
        const parts = [
          `${rows}/${settings.maxRows} rows`,
          `${reels}/${settings.maxReels} reels`
        ];
        if (lineCount) parts.push(`${lineCount} lines`);
        if (Array.isArray(state.machine.activeSymbols) && state.machine.activeSymbols.length) {
          parts.push(`${state.machine.activeSymbols.length} symbols`);
        }
        els.machineLines.textContent = parts.join(' ‚Ä¢ ');
      };

      const applyMachineTheme = () => {
        if (!els.reelStage) return;
        const assets = state.machine.assets || {};
        const frame = assets.frame || null;
        els.reelStage.style.backgroundColor = 'rgba(2,6,23,.75)';
        if (frame) {
          els.reelStage.style.backgroundImage = `url('${frame}')`;
          els.reelStage.style.backgroundSize = 'contain';
          els.reelStage.style.backgroundRepeat = 'no-repeat';
          els.reelStage.style.backgroundPosition = 'center';
        } else {
          els.reelStage.style.backgroundImage = '';
        }
      };

      const updateGridSymbols = (grid = []) => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        ensureGrid(rows, reels);
        for (let row = 0; row < rows; row += 1) {
          const rowSymbols = grid[row] || [];
          for (let col = 0; col < reels; col += 1) {
            const symbolKey = rowSymbols[col] || randomSymbolInfo().key;
            const cell = state.gridCells.get(`${row}:${col}`);
            if (!cell) continue;
            const img = cell.querySelector('img');
            const info = applySymbolToImage(img, symbolKey);
            cell.dataset.symbol = info.key;
            if (cell.dataset.state !== 'win') {
              cell.dataset.state = 'settled';
            }
            debug('grid:update-cell', { row, col, symbol: info.key });
          }
        }
      };

      const setGridState = (mode) => {
        state.gridCells.forEach(cell => {
          cell.dataset.state = mode;
        });
      };

      const getSpinIntervalDelay = (col) => {
        const base = 70 + col * 15;
        const speedLevel = Math.max(0, state.upgrades.speed || 0);
        const factor = Math.max(0.35, 1 - 0.1 * speedLevel);
        return Math.max(20, base * factor);
      };

      const getReelStopDelay = (col) => {
        const base = 120 + col * 110;
        const speedLevel = Math.max(0, state.upgrades.speed || 0);
        const autoLevel = Math.max(0, state.upgrades.autoSpeed || 0);
        const factor = Math.max(0.55, 1 - 0.08 * (speedLevel + autoLevel));
        return Math.max(70, base * factor);
      };

      const startGridSpin = () => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        ensureGrid(rows, reels);
        activeReelLocks = reels;
        pendingSpinResult = null;
        pendingWinGroups = [];
        clearLineFlash(true);
        state.gridCells.forEach(cell => {
          cell.classList.remove('slot-lock');
          cell.dataset.state = 'spinning';
        });
        setGridState('spinning');
        for (let col = 0; col < reels; col += 1) {
          spinReel(col);
        }
      };

      function flushPendingSpinResult() {
        if (pendingSpinResult && activeReelLocks === 0 && !anyReelSpinning()) {
          const data = pendingSpinResult;
          pendingSpinResult = null;
          updateLastSpin(data);
        }
      }

      const stopGridSpin = (grid) => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        if (!Array.isArray(grid)) {
          reelState.forEach((_, col) => stopReelSpin(col, null));
          state.gridCells.forEach(cell => {
            if (cell.dataset.state === 'spinning') cell.dataset.state = 'settled';
          });
          activeReelLocks = 0;
          flushPendingSpinResult();
          return;
        }
        activeReelLocks = reels;
        for (let col = 0; col < reels; col += 1) {
          const columnSymbols = [];
          for (let row = 0; row < rows; row += 1) {
            columnSymbols[row] = grid[row]?.[col];
          }
          const delay = getReelStopDelay(col) + Math.random() * 120;
          setTimeout(() => {
            stopReelSpin(col, columnSymbols);
            activeReelLocks = Math.max(0, activeReelLocks - 1);
            flushPendingSpinResult();
          }, delay);
        }
      };

      const highlightWins = (groups = []) => {
        state.gridCells.forEach(cell => {
          if (cell.dataset.state === 'spinning') return;
          cell.dataset.state = 'settled';
        });
        if (!groups.length) return;
        groups.forEach(group => {
          if (group.symbol === 'bonus') {
            state.gridCells.forEach(cell => {
              if (cell.dataset.symbol === 'bonus') cell.dataset.state = 'win';
            });
            return;
          }
          if (!Array.isArray(group.pattern) || !Array.isArray(group.indexes)) return;
          const rows = state.currentRows || state.machine.rows;
          group.indexes.forEach(index => {
            const row = Math.max(0, Math.min(group.pattern[index] ?? 0, rows - 1));
            const cell = state.gridCells.get(`${row}:${index}`);
            if (cell) cell.dataset.state = 'win';
          });
        });
      };

      function renderPaytable() {
        if (!els.paytable) return;
        if (!state.symbolMap.size) {
          state.symbolMap = cloneSymbolMap(DEFAULT_SYMBOL_MAP);
        }
        const entries = Array.from(state.symbolMap.values());
        const activeSet = new Set(state.machine.activeSymbols || []);
        els.paytable.innerHTML = entries.map(entry => {
          const payout = state.machine.payouts[entry.key] || 0;
          const tiers = [1, 2, 3].map(mult => `${mult + 2}√ó ${payout ? payout * mult : 0}√ó bet`).join(' ‚Ä¢ ');
          const asset = entry.asset || getPlaceholderAsset();
          if (!entry.asset || asset === getPlaceholderAsset()) {
            debug('paytable:placeholder', { symbol: entry.key });
          }
          const isActive = activeSet.size === 0 || activeSet.has(entry.key);
          return `
            <li data-active="${isActive ? 'true' : 'false'}">
              <div class="paytable-symbol">
                <img src="${asset}" alt="${entry.label}" data-symbol="${entry.key}" loading="lazy">
                ${entry.label}
              </div>
              <div class="paytable-meta">${tiers}</div>
            </li>
          `;
        }).join('');
        els.paytable.querySelectorAll('.paytable-symbol img').forEach(img => {
          attachImageDebugging(img, img.dataset.symbol);
        });
        debug('paytable:render', { symbols: entries.length });
      }

      const setSymbolMap = (symbols = [], reason = 'update') => {
        const list = Array.isArray(symbols) ? symbols : [];
        state.symbolMap = buildSymbolMap(list, state.symbolMap || DEFAULT_SYMBOL_MAP, getPlaceholderAsset());
        if (list.length) {
          state.machine.symbols = list.map(entry => ({ ...entry }));
        } else if (!state.machine.symbols || !state.machine.symbols.length) {
          state.machine.symbols = Array.from(state.symbolMap.values()).map(entry => ({
            key: entry.key,
            label: entry.label,
            asset: entry.asset
          }));
        }
        debug('symbols:set', { reason, count: state.symbolMap.size });
        auditSymbolAssets();
        renderPaytable();
      };
      setSymbolMap(DEFAULT_SYMBOLS, 'init');
      applyUpgradeState(state.upgrades);

      function applyUpgradeState(incoming = state.serverUpgrades) {
        state.serverUpgrades = { ...incoming };
        let normalized = {};
        if (state.upgradeCatalog.length) {
          state.upgradeCatalog.forEach(def => {
            const next = Number.isFinite(incoming?.[def.key])
              ? incoming[def.key]
              : Number(state.serverUpgrades?.[def.key]) || 0;
            const max = getUpgradeMaxLevel(def.key);
            normalized[def.key] = Math.min(Math.max(0, Math.floor(next)), max);
          });
        } else {
          normalized = { ...state.serverUpgrades, ...incoming };
        }
        const settings = getUpgradeSettings();
        const rows = Math.min(
          settings.maxRows,
          (settings.baseRows || 3) + (normalized.rows || 0)
        );
        const reels = Math.min(
          settings.maxReels,
          (settings.baseReels || 3) + (normalized.reels || 0)
        );
        const maxLineTier = state.machine.lineTier || (state.machine.lines?.[state.machine.lines.length - 1]?.tier ?? 3);
        const lineTier = Math.min(maxLineTier, normalized.lines || 0);
        const effective = { ...normalized };
        Object.entries(state.pendingUpgrades || {}).forEach(([key, val]) => {
          const appended = (effective[key] || 0) + val;
          const max = getUpgradeMaxLevel(key);
          effective[key] = Math.min(max, appended);
        });
        state.upgrades = effective;
        state.currentRows = rows;
        state.currentReels = reels;
        state.currentLineTier = lineTier;
        state.machine.rows = rows;
        state.machine.reels = reels;
        state.machine.currentRows = rows;
        state.machine.currentReels = reels;
        state.machine.currentLineTier = lineTier;
        state.machine.activeSymbols = computeActiveSymbols(normalized);
        ensureGrid(rows, reels);
        renderUpgrades();
        updateMachineMeta();
        updateSkillSpec();
        renderSkillButton();
        renderBonusSummary();
        renderAutoSpinButton();
        startIdleTicker();
      }

      const syncMachineDefinition = (machine = {}) => {
        if (!machine || typeof machine !== 'object') return;
        state.machine.id = machine.id || state.machine.id;
        state.machine.name = machine.name || state.machine.name;
        state.machine.lineTier = Number(machine.lineTier) || state.machine.lineTier;
        state.machine.rows = Number(machine.rows) || state.machine.rows;
        state.machine.reels = Number(machine.reels) || state.machine.reels;
        state.machine.baseSymbolCount = Number(machine.baseSymbolCount) || state.machine.baseSymbolCount;
        if (Array.isArray(machine.lines)) state.machine.lines = machine.lines;
        if (machine.payouts) state.machine.payouts = machine.payouts;
        if (machine.assets) state.machine.assets = { ...state.machine.assets, ...machine.assets };
        if (Array.isArray(machine.activeSymbols)) state.machine.activeSymbols = machine.activeSymbols.slice();
        if (Array.isArray(machine.symbols)) {
          state.machine.symbols = machine.symbols.map(entry => ({ ...entry }));
        }
        const baseRows = Number(machine.baseRows ?? machine.upgrades?.baseRows ?? state.machine.upgradeSettings?.baseRows ?? state.machine.rows);
        const maxRows = Number(machine.maxRows ?? machine.upgrades?.maxRows ?? state.machine.upgradeSettings?.maxRows ?? state.machine.rows);
        const baseReels = Number(machine.baseReels ?? machine.upgrades?.baseReels ?? state.machine.upgradeSettings?.baseReels ?? state.machine.reels);
        const maxReels = Number(machine.maxReels ?? machine.upgrades?.maxReels ?? state.machine.upgradeSettings?.maxReels ?? state.machine.reels);
        const upgradeCosts = machine.upgrades?.costs
          || machine.upgradeSettings?.costs
          || machine.upgradeCosts
          || state.machine.upgradeSettings?.costs
          || {};
        state.machine.upgradeSettings = {
          baseRows,
          maxRows,
          baseReels,
          maxReels,
          costs: upgradeCosts
        };
        state.machine.rows = baseRows;
        state.machine.reels = baseReels;
        state.currentRows = baseRows;
        state.currentReels = baseReels;
        setSymbolMap(Array.isArray(machine.symbols) ? machine.symbols : [], 'syncMachineDefinition');
        applyUpgradeState(state.upgrades);
      };

      const loadMachineConfig = async () => {
        debug('machine-config:load', { url: MACHINE_CONFIG_URL });
        if (!MACHINE_CONFIG_URL) {
          ensureGrid(state.machine.rows, state.machine.reels);
          debug('machine-config:skipped', 'no URL provided');
          return;
        }
        try {
          const res = await fetch(MACHINE_CONFIG_URL, { cache: 'no-cache' });
          if (!res.ok) throw new Error(`Config ${res.status}`);
          const data = await res.json();
          state.machine.assets = data.assets || state.machine.assets;
          state.machine.placeholder = data.assets?.placeholder || state.machine.placeholder;
          if (data.payouts) state.machine.payouts = data.payouts;
          if (Number(data.rows)) state.machine.rows = Number(data.rows);
          if (Number(data.reels)) state.machine.reels = Number(data.reels);
          if (Number(data.baseSymbolCount)) state.machine.baseSymbolCount = Number(data.baseSymbolCount);
          state.machine.upgradeSettings = {
            baseRows: data.baseRows ?? state.machine.upgradeSettings?.baseRows ?? state.machine.rows,
            maxRows: data.maxRows ?? state.machine.upgradeSettings?.maxRows ?? state.machine.rows,
            baseReels: data.baseReels ?? state.machine.upgradeSettings?.baseReels ?? state.machine.reels,
            maxReels: data.maxReels ?? state.machine.upgradeSettings?.maxReels ?? state.machine.reels,
            costs: data.upgradeCosts || state.machine.upgradeSettings?.costs || {}
          };
          setSymbolMap(Array.isArray(data.symbols) ? data.symbols : [], 'machineConfig');
          applyUpgradeState(state.upgrades);
          applyMachineTheme();
          debug('machine-config:loaded', { rows: state.machine.rows, reels: state.machine.reels, symbols: state.symbolMap.size });
        } catch (error) {
          console.error('Machine config failed', error);
          log('Assets', 'Unable to load slot assets.');
          debugError('machine-config', error);
          ensureGrid(state.machine.rows, state.machine.reels);
        }
      };

      const setAuthMode = (mode = 'login') => {
        debug('auth:setMode', mode);
        const nextMode = mode === 'register' ? 'register' : 'login';
        state.authMode = nextMode;
        localStorage.setItem(AUTH_MODE_KEY, nextMode);
        if (els.authBody) {
          els.authBody.dataset.mode = nextMode;
        }
        (els.authTabs || []).forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === nextMode);
        });
        if (els.authSubmit) {
          els.authSubmit.textContent = nextMode === 'register' ? 'Create Account' : 'Sign In';
        }
        if (els.authConfirmGroup) {
          els.authConfirmGroup.hidden = nextMode !== 'register';
        }
        if (nextMode !== 'register' && els.authConfirm) {
          els.authConfirm.value = '';
        }
        showAuthAlert('');
      };

      setGameVisibility(false);
      renderAutoSpinButton();
      setAuthMode(state.authMode);
      const handleAuthEnter = (event) => {
        if (event.key === 'Enter' && !state.busy) {
          event.preventDefault();
          if (document.activeElement === els.authEmail || document.activeElement === els.authPassword || document.activeElement === els.authConfirm) {
            loginOrRegister();
          }
        }
      };

      [els.authEmail, els.authPassword, els.authConfirm].forEach(input => {
        if (input) input.addEventListener('keydown', handleAuthEnter);
      });


      const updateHud = () => {
        const totalBalance = (state.balance || 0) + (state.pendingIdleCoins || 0);
        if (els.hudBalance) els.hudBalance.textContent = formatCompactMoney(totalBalance);
        if (els.hudBet) els.hudBet.textContent = formatCompactMoney(state.bet || 0);
        if (els.hudWin) els.hudWin.textContent = formatCompactMoney(state.lastWin || 0);
        if (els.hudVip) {
          const vipMarks = Number(state.drop?.inventory?.vipMarks || 0);
          els.hudVip.textContent = `${formatCompactNumber(vipMarks)} VIP`;
        }
      };
      const clearLineFlash = (reenable = false) => {
        if (state.lineFlashTimer) {
          clearTimeout(state.lineFlashTimer);
          state.lineFlashTimer = null;
        }
        state.gridCells.forEach(cell => cell.classList.remove('line-flash'));
        if (els.lineOverlay) {
          els.lineOverlay.innerHTML = '';
        }
        if (reenable && els.lineFlashBtn) {
          els.lineFlashBtn.disabled = false;
          els.lineFlashBtn.removeAttribute('aria-busy');
        }
      };
      const renderLineOverlay = (patterns = []) => {
        if (!els.lineOverlay || !els.slotGrid) return;
        const overlayRect = els.lineOverlay.getBoundingClientRect();
        const width = Math.max(1, overlayRect.width || els.slotGrid.offsetWidth || 1);
        const height = Math.max(1, overlayRect.height || els.slotGrid.offsetHeight || 1);
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        const rows = state.currentRows || state.machine.rows;
        patterns.forEach((pattern, idx) => {
          const points = [];
          (pattern.pattern || []).forEach((row, col) => {
            const r = Math.max(0, Math.min(rows - 1, row));
            const cell = state.gridCells.get(`${r}:${col}`);
            if (!cell) return;
            const rect = cell.getBoundingClientRect();
            const cx = (rect.left + rect.right) / 2 - overlayRect.left;
            const cy = (rect.top + rect.bottom) / 2 - overlayRect.top;
            points.push(`${cx},${cy}`);
          });
          if (points.length >= 2) {
            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            poly.setAttribute('points', points.join(' '));
            poly.classList.add('line-path');
            poly.style.setProperty('--line-hue', `${(idx * 53) % 360}`);
            poly.style.animationDelay = `${idx * 0.08}s`;
            svg.appendChild(poly);
          }
        });
        els.lineOverlay.innerHTML = '';
        if (svg.childElementCount) {
          els.lineOverlay.appendChild(svg);
        }
      };
      const flashActiveLines = () => {
        if (!state.gameReady) return;
        clearLineFlash();
        const patterns = (state.machine.lines || []).filter(def => (def.tier ?? 0) <= (state.currentLineTier ?? 0));
        if (!patterns.length) {
          showAlert('No active lines yet. Unlock multi-line upgrades to see more patterns.');
          return;
        }
        if (els.lineFlashBtn) {
          els.lineFlashBtn.disabled = true;
          els.lineFlashBtn.setAttribute('aria-busy', 'true');
        }
        const rows = state.currentRows || state.machine.rows;
        state.gridCells.forEach(cell => cell.classList.remove('line-flash'));
        patterns.forEach(pattern => {
          (pattern.pattern || []).forEach((row, col) => {
            const r = Math.max(0, Math.min(rows - 1, row));
            const cell = state.gridCells.get(`${r}:${col}`);
            if (cell) cell.classList.add('line-flash');
          });
        });
        renderLineOverlay(patterns);
        const duration = Math.min(3500, 800 + patterns.length * 140);
        state.lineFlashTimer = setTimeout(() => {
          clearLineFlash(true);
        }, duration);
      };
      function clearSyncedPending(snapshot = {}) {
        let changed = false;
        Object.entries(snapshot || {}).forEach(([key, value]) => {
          if (!value) return;
          const current = state.pendingUpgrades?.[key] || 0;
          const remaining = current - value;
          if (remaining > 0) {
            state.pendingUpgrades[key] = remaining;
          } else {
            delete state.pendingUpgrades[key];
          }
          changed = true;
        });
        if (changed) {
          applyUpgradeState(state.serverUpgrades);
          renderUpgrades();
        }
      }

      function stopIdleTicker() {
        if (state.idleTicker) {
          cancelFrame(state.idleTicker);
          state.idleTicker = null;
        }
        state.idleTickerActive = false;
        state.lastIdleTick = 0;
      }

      function idleStep(timestamp) {
        if (!state.idleTickerActive) return;
        if (!state.lastIdleTick) state.lastIdleTick = timestamp;
        const rate = Math.max(0, state.upgrades.idle || 0);
        const delta = timestamp - state.lastIdleTick;
        if (rate > 0 && delta >= 1000) {
          const seconds = Math.floor(delta / 1000);
          state.pendingIdleCoins += rate * seconds;
          state.lastIdleTick += seconds * 1000;
          updateHud();
        }
        state.idleTicker = requestFrame(idleStep);
      }

      function startIdleTicker() {
        stopIdleTicker();
        if (!state.gameReady || !state.auth.token) return;
        if ((state.upgrades.idle || 0) <= 0) return;
        state.idleTickerActive = true;
        state.lastIdleTick = 0;
        state.idleTicker = requestFrame(idleStep);
      }

      const setBetValue = (value) => {
        syncBetSteps();
        const capped = Math.min(value || 1, state.maxBet || DEFAULT_MAX_BET);
        const idx = getNearestBetIndex(capped);
        const safe = betFromIndex(idx);
        debug('bet:update', { requested: value, applied: safe, max: state.maxBet, idx });
        state.bet = safe;
        if (els.betSlider) {
          els.betSlider.max = Math.max(0, betSteps.length - 1);
          els.betSlider.value = idx;
          els.betSlider.setAttribute('aria-valuenow', safe.toString());
          els.betSlider.setAttribute('aria-valuemax', (state.maxBet || DEFAULT_MAX_BET).toString());
        }
        updateHud();
        if (els.dropPanel && !els.dropPanel.hidden) {
          renderDropPanel();
        }
        renderSkillButton();
        renderBonusSummary();
      };
      setBetValue(state.bet);

      const storeGuestPlayer = (value) => {
        if (value) {
          localStorage.setItem(storageKeys.player, value);
        }
      };
      const resetStoredPlayer = () => localStorage.removeItem(storageKeys.player);

      const updateAuthUI = () => {
        debug('auth:updateUI', { loggedIn: Boolean(state.auth.token) });
        const loggedIn = Boolean(state.auth.token);
        if (els.authOverlay) {
          els.authOverlay.dataset.hidden = loggedIn ? 'true' : 'false';
          els.authOverlay.setAttribute('aria-hidden', loggedIn ? 'true' : 'false');
          if (loggedIn && els.authOverlay.contains(document.activeElement)) {
            document.activeElement.blur?.();
          }
        }
        if (loggedIn && els.accountUser) {
          els.accountUser.textContent = state.auth.username || 'Account';
        }
        if (els.accountToggle) {
          els.accountToggle.disabled = !loggedIn;
        }
        if (els.logoutBtn) {
          els.logoutBtn.disabled = !loggedIn;
        }
        if (!loggedIn) {
          toggleAccountSheet(false);
        }
        if (els.deleteBtn) {
          els.deleteBtn.disabled = !loggedIn;
        }
        if (loggedIn) startIdleTicker();
        else {
          stopIdleTicker();
          state.pendingIdleCoins = 0;
          state.pendingUpgrades = {};
          updateHud();
        }
        if (els.debugCoinBtn) {
          const matchesDebug = loggedIn && (state.auth.username || '').toLowerCase() === DEBUG_EMAIL;
          els.debugCoinBtn.hidden = !matchesDebug;
          els.debugCoinBtn.disabled = !matchesDebug;
        }
        if (!loggedIn && els.authPassword) {
          els.authPassword.value = '';
          if (els.authConfirm) els.authConfirm.value = '';
        }
        if (!loggedIn) {
          if (els.machineOutcome) els.machineOutcome.textContent = 'Sign in to start spinning.';
          if (els.hudWin) els.hudWin.textContent = formatCompactMoney(0);
          updateHud();
        }
      };

      const setAuthState = ({ token, username } = {}) => {
        debug('auth:setState', { tokenPresent: Boolean(token), username });
        state.auth.token = token || null;
        state.auth.username = token ? (username || state.auth.username || null) : null;
        if (!state.auth.token) {
          state.playerId = null;
          state.pendingIdleCoins = 0;
          stopIdleTicker();
          state.drop.inventory = {};
          state.drop.history = [];
          state.drop.lastDrops = [];
          state.drop.lastTimestamp = 0;
          state.daily = {
            streak: 1,
            claimedToday: false,
            ready: false,
            lastClaimMs: 0,
            nextResetAt: 0,
            todayReward: null
          };
          renderDropLog();
          renderInventory();
          renderDaily();
          renderBonusSummary();
          toggleDropPanel(false);
          updateHud();
        }
        if (state.auth.token) {
          localStorage.setItem(storageKeys.token, state.auth.token);
          localStorage.setItem(storageKeys.user, state.auth.username || '');
          resetStoredPlayer();
        } else {
          localStorage.removeItem(storageKeys.token);
          localStorage.removeItem(storageKeys.user);
        }
        updateAuthUI();
      };

      const clearAuth = (message) => {
        debug('auth:clear', { message });
        if (!state.auth.token) return;
        setAuthState({});
        setGameVisibility(false);
        setStatus('Sign in to start', 'error');
        if (message) {
          showAuthAlert(message);
          log('Auth', message);
        }
      };

      const syncAuthFromPayload = (payload = {}) => {
        debug('auth:syncFromPayload', payload);
        if (payload.token && payload.username) {
          setAuthState({ token: payload.token, username: payload.username });
          showAuthAlert('');
        }
      };

      const withAuth = (payload = {}) => {
        if (state.auth.token) {
          return { ...payload, token: state.auth.token };
        }
        return payload;
      };

      const request = async (path, payload = {}, options = {}) => {
        const finalPayload = options.skipAuth ? payload : withAuth(payload);
        debug('request:start', { path, payload: finalPayload, options });
        let res;
        try {
          res = await fetch(`${API_BASE}${path}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(finalPayload)
          });
        } catch (networkError) {
          const err = new Error('Network request failed.');
          err.cause = networkError;
          debugError('request:network', networkError, { path, payload: finalPayload });
          throw err;
        }
        let data = {};
        try {
          data = await res.json();
        } catch {
          data = {};
        }
        debug('request:response', { path, status: res.status, ok: res.ok, body: data });
        if (!res.ok) {
          if (res.status === 401 && !options.skipAuth) {
            clearAuth('Session expired. Please sign in again.');
          }
          const err = new Error(data.error || data.message || 'Request failed');
          err.payload = data;
          err.status = res.status;
          debugError('request:error', err, { path, payload: finalPayload });
          throw err;
        }
        return data;
      };

      const updateStats = (payload = {}) => {
        debug('updateStats', payload);
        if (payload.playerId) {
          state.playerId = payload.playerId;
          els.playerId.textContent = payload.playerId;
          if (state.auth.token) {
            resetStoredPlayer();
          } else {
            storeGuestPlayer(payload.playerId);
          }
        }
        if (typeof payload.balance === 'number') {
          state.balance = payload.balance;
          els.balance.textContent = currency.format(payload.balance);
        }
        if (Number(payload.idleGained) > 0) {
          log('Idle payout collected', `+${currency.format(payload.idleGained)} credits while away.`);
          state.pendingIdleCoins = Math.max(0, (state.pendingIdleCoins || 0) - payload.idleGained);
          state.lastIdleTick = 0;
          startIdleTicker();
        }
        if (typeof payload.spins === 'number') {
          els.spinCount.textContent = payload.spins;
        }
        if (payload.currentRows) state.currentRows = payload.currentRows;
        if (payload.currentReels) state.currentReels = payload.currentReels;
        if (payload.machine) {
          syncMachineDefinition(payload.machine);
        }
        if (payload.dropState) {
          applyDropState(payload.dropState);
        } else if (payload.inventory) {
          applyDropState({ inventory: payload.inventory });
        }
        if (payload.daily) {
          applyDailyState(payload.daily, payload.reward);
        } else if (payload.reward && state.daily) {
          applyDailyState(state.daily, payload.reward);
        }

        state.maxBet = resolveMaxBet(payload.maxBet);
        els.maxBet.textContent = state.maxBet;
        if (payload.upgrades) {
          state.serverUpgrades = { ...payload.upgrades };
        }
        applyUpgradeState(state.serverUpgrades);
        const incomingBet = Number(payload.bet);
        const fallbackBet = Number.isFinite(state.bet)
          ? state.bet
          : Number(els.betSlider?.value);
        const desiredBet = Number.isFinite(incomingBet)
          ? incomingBet
          : (Number.isFinite(fallbackBet) ? fallbackBet : 1);
        setBetValue(desiredBet || 1);
        updateHud();
        renderBonusSummary();
        renderAutoSpinButton();
      };

      const formatWinSummary = (groups = []) => {
        if (!groups?.length) return '';
        return groups
          .slice()
          .sort((a, b) => (b.payout || 0) - (a.payout || 0))
          .map(group => {
            const info = getSymbolEntry(group.symbol);
            return `${info.label || info.key} √ó${group.count}`;
          })
          .join(', ');
      };

      const updateLastSpin = (lastSpin) => {
        debug('updateLastSpin', lastSpin);
        if (!lastSpin) {
          state.lastWin = 0;
          if (els.lastOutcome) els.lastOutcome.textContent = '‚Äî';
          if (els.lastWin) els.lastWin.textContent = '‚Äî';
          if (els.lastMult) els.lastMult.textContent = '‚Äî';
          if (els.lastTime) els.lastTime.textContent = '‚Äî';
          if (els.machineOutcome) els.machineOutcome.textContent = 'Awaiting spin‚Ä¶';
          if (els.hudWin) els.hudWin.textContent = currency.format(0);
          highlightWins([]);
          updateHud();
          return;
        }
        if (activeReelLocks > 0 || anyReelSpinning()) {
          pendingSpinResult = lastSpin;
          pendingWinGroups = lastSpin.winGroups || [];
          return;
        }
        const summary = formatWinSummary(lastSpin.winGroups) || lastSpin.outcome || '‚Äî';
        if (els.lastOutcome) els.lastOutcome.textContent = summary;
        const winAmount = lastSpin.winAmount || 0;
        state.lastWin = winAmount;
        if (els.lastWin) els.lastWin.textContent = currency.format(winAmount);
        if (els.lastMult) {
          const lines = Array.isArray(lastSpin.winGroups) ? lastSpin.winGroups.length : 0;
          els.lastMult.textContent = lines ? `${lines} line${lines === 1 ? '' : 's'}` : '‚Äî';
        }
        if (els.lastTime) els.lastTime.textContent = new Date(lastSpin.timestamp).toLocaleString();
        if (els.machineOutcome) {
          const note = lastSpin.retriggered ? ' (Retriggered)' : '';
          els.machineOutcome.textContent = `${lastSpin.outcome || summary}${note}`;
        }
        if (els.hudWin) els.hudWin.textContent = formatCompactMoney(winAmount);
        if (Array.isArray(lastSpin.drops) && lastSpin.drops.length) {
          recordDrops(lastSpin.drops, Date.parse(lastSpin.timestamp) || Date.now());
          renderInventory();
        }
        pendingWinGroups = lastSpin.winGroups || [];
        if (activeReelLocks === 0 && !anyReelSpinning()) {
          highlightWins(pendingWinGroups);
          pendingWinGroups = [];
        }
        pendingSpinResult = null;
      };

      const hydrateSession = (session, logMessage) => {
        debug('hydrateSession', session);
        syncAuthFromPayload(session);
        if (session.machine) {
          syncMachineDefinition(session.machine);
        }
        if (session.upgrades) {
          applyUpgradeState(session.upgrades);
        }
        updateStats(session);
        updateLastSpin(session.lastSpin);
        setGameVisibility(true);
        setStatus('Connected to AWS Lambda', 'ok');
        if (logMessage) {
          log(logMessage, `${session.username || 'User'} ‚Ä¢ balance ${currency.format(state.balance || session.balance)}`);
        }
      };

      const bootstrap = async () => {
        debug('bootstrap:start');
        if (!state.auth.token) {
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          debug('bootstrap:skipped', 'missing auth token');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const session = await request('/session');
          hydrateSession(session, 'Session synced');
        } catch (error) {
          console.error(error);
          setGameVisibility(false);
          setStatus('Offline ‚Äî check CloudWatch logs', 'error');
          showAlert(error.message || 'Unable to reach AWS.');
          log('Connection failed', error.message);
          debugError('bootstrap', error);
        } finally {
          debug('bootstrap:end');
          setBusy(false);
        }
      };

      const startAutoSpin = () => {
        if (!isAutoSpinUnlocked() || state.busy || !state.gameReady) return;
        state.autoSpin.active = true;
        state.autoSpin.remaining = getAutoSpinCount();
        renderAutoSpinButton();
        spin(true);
      };

      const spin = async (auto = false) => {
        debug('spin:click', { busy: state.busy, authed: !!state.auth.token });
        if (state.busy) return;
        if (!state.auth.token) {
          showAuthAlert('Sign in to spin the slot machine.');
          return;
        }
        if (!auto) {
          state.autoSpin.active = false;
          state.autoSpin.remaining = 0;
          renderAutoSpinButton();
        }
        const bet = clamp(state.bet || 1, 1, state.maxBet || DEFAULT_MAX_BET);
        setBetValue(bet);
        setBusy(true);
        showAlert('');
        if (els.error) els.error.textContent = '';
        startGridSpin();
        let spinData = null;
        const clientIdleCoins = Math.floor(Math.max(0, state.pendingIdleCoins || 0));
        const pendingSnapshot = { ...state.pendingUpgrades };
        try {
          const result = await request('/spin', {
            bet,
            clientIdleCoins,
            pendingUpgrades: pendingSnapshot,
            activeSkills: dropSkillPayload()
          });
          spinData = result.lastSpin || null;
          clearSyncedPending(pendingSnapshot);
          updateStats(result);
          updateLastSpin(spinData);
          const outcomeText = spinData?.outcome || result.outcome || 'Result processed';
          log('Spin processed by Lambda', `${outcomeText} (balance ${currency.format(state.balance || result.balance)})`);
          debug('spin:success', { bet, outcome: outcomeText, balance: result.balance });
        } catch (error) {
          const payload = error.payload || {};
          const msg = payload.message || error.message;
          if (els.error) els.error.textContent = msg;
          if (payload.balance !== undefined || payload.maxBet !== undefined) {
            updateStats({ balance: payload.balance, maxBet: payload.maxBet });
          }
          if (payload.errorCode === 'INSUFFICIENT_CREDITS') {
            log('Spin blocked', 'Insufficient credits');
            state.autoSpin.active = false;
            state.autoSpin.remaining = 0;
          } else {
            log('Spin failed', msg);
            state.autoSpin.active = false;
            state.autoSpin.remaining = 0;
          }
          debugError('spin', error, { payload });
        } finally {
          stopGridSpin(spinData?.grid);
          setBusy(false);
          if (state.autoSpin.active && state.autoSpin.remaining > 0) {
            state.autoSpin.remaining -= 1;
            renderAutoSpinButton();
            setTimeout(() => spin(true), 200);
          } else {
            state.autoSpin.active = false;
            state.autoSpin.remaining = 0;
            renderAutoSpinButton();
          }
        }
      };

      const claimDaily = async () => {
        debug('daily:claim', { busy: state.busy, ready: state.daily?.ready });
        if (!state.auth.token) {
          showAuthAlert('Sign in to claim daily rewards.');
          return;
        }
        if (state.daily?.claimedToday) {
          showAlert('Already claimed today.');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const result = await request('/daily', { action: 'claim' });
          updateStats(result);
          if (result.reward) {
            const drops = Array.isArray(result.reward.drops) ? result.reward.drops : [];
            if (drops.length) {
              recordDrops(drops, Date.now());
              renderInventory();
            }
            const parts = [];
            if (result.reward.vipMarks) parts.push(`+${result.reward.vipMarks} VIP marks`);
            if (result.reward.credits) parts.push(`+${currency.format(result.reward.credits)} credits`);
            drops.filter(drop => drop.type !== 'vipMarks').forEach(drop => {
              const info = normalizeDrop(drop);
              parts.push(`${info.name} √ó${drop.amount || 1}`);
            });
            log('Daily reward claimed', parts.join(' ‚Ä¢ '));
          }
        } catch (error) {
          const payload = error.payload || {};
          if (payload.daily) {
            applyDailyState(payload.daily, payload.reward);
          }
          showAlert(error.message || 'Unable to claim daily reward.');
          debugError('daily:claim', error, { payload });
        } finally {
          setBusy(false);
          renderDaily();
          renderBonusSummary();
        }
      };

      const loginOrRegister = async () => {
        const email = (els.authEmail?.value || '').trim().toLowerCase();
        const password = els.authPassword?.value || '';
        debug('auth:submit', { mode: state.authMode, email, hasPassword: Boolean(password) });
        if (!email || !password) {
          showAuthAlert('Enter your email and password.');
          return;
        }
        if (state.authMode === 'register') {
          const confirm = (els.authConfirm?.value || '').trim();
          if (!confirm) {
            showAuthAlert('Please confirm your password.');
            return;
          }
          if (confirm !== password) {
            showAuthAlert('Passwords do not match.');
            return;
          }
        }
        showAuthAlert('');
        toggleAuthInputs(true);
        try {
          const endpoint = state.authMode === 'register' ? '/auth/register' : '/auth/login';
          const result = await request(endpoint, { username: email, password }, { skipAuth: true });
          hydrateSession(result, state.authMode === 'register' ? 'Account created' : 'Signed in');
          showAuthAlert(state.authMode === 'register' ? 'Account created! Credits synced.' : 'Signed in successfully.');
          debug('auth:success', { endpoint });
        } catch (error) {
          if (error && error.status === 409 && state.authMode === 'register') {
            setAuthMode('login');
            showAuthAlert('Account already exists. Sign in instead.');
          } else {
            showAuthAlert(error.message || 'Unable to process request.');
          }
          log('Auth failed', error.message);
          debugError('auth', error);
        } finally {
          toggleAuthInputs(false);
        }
      };

      const logout = async () => {
        debug('auth:logout-click', { authed: !!state.auth.token });
        if (!state.auth.token) return;
        showAuthAlert('');
        if (els.logoutBtn) els.logoutBtn.disabled = true;
        try {
          await request('/auth/logout', {});
        } catch (error) {
          console.error(error);
          debugError('logout', error);
        } finally {
          if (els.logoutBtn) els.logoutBtn.disabled = false;
          setAuthState({});
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          log('Signed out', '');
          showAuthAlert('Signed out.');
        }
      };

      const deleteAccount = async () => {
        if (!state.auth.token) return;
        const confirmed = window.confirm('Delete your account and all slot progress? This cannot be undone.');
        debug('account:delete-click', { confirmed });
        if (!confirmed) return;
        showAuthAlert('');
        if (els.deleteBtn) els.deleteBtn.disabled = true;
        try {
          await request('/auth/delete', {});
          log('Account deleted', '');
          setAuthState({});
          setGameVisibility(false);
          setStatus('Account deleted', 'error');
          showAuthAlert('Account deleted. You can register again anytime.');
          toggleAccountSheet(false);
        } catch (error) {
          showAuthAlert(error.message || 'Unable to delete account right now.');
          log('Delete failed', error.message);
          debugError('delete-account', error);
        } finally {
          if (els.deleteBtn) els.deleteBtn.disabled = false;
        }
      };

      const grantDebugCoins = async () => {
        if (!state.auth.token) return;
        const email = (state.auth.username || '').toLowerCase();
        if (email !== DEBUG_EMAIL) return;
        debug('debug:grantCoins', email);
        setBusy(true);
        showAlert('');
        try {
          const result = await request('/session', { token: state.auth.token, action: 'debugCoins' });
          updateStats(result);
          log('Debug', '+100k credits granted.');
        } catch (error) {
          showAlert(error.message || 'Unable to grant coins.');
          debugError('debug-coins', error);
        } finally {
          setBusy(false);
        }
      };

      updateAuthUI();
      ensureGrid(state.machine.rows, state.machine.reels);
      updateMachineMeta();
      renderPaytable();
      loadMachineConfig();
      renderDaily();
      renderBonusSummary();
      updateHud();
      window.addEventListener('resize', applyMachineTheme);

      if (els.betSlider) {
        els.betSlider.addEventListener('input', (event) => {
          const idx = Number(event.target.value) || 0;
          const next = betFromIndex(idx);
          setBetValue(next);
        });
      }

      const handleChipAction = (action) => {
        debug('chip:action', { action, busy: state.busy, ready: state.gameReady });
        if (state.busy || !state.gameReady) return;
        const currentIndex = getNearestBetIndex(state.bet);
        if (action === 'increase') {
          setBetValue(betFromIndex(currentIndex + 1));
          return;
        }
        if (action === 'decrease') {
          setBetValue(betFromIndex(currentIndex - 1));
          return;
        }
        if (action === 'max') {
          setBetValue(state.maxBet || DEFAULT_MAX_BET);
        }
      };

      els.chipButtons.forEach(btn => {
        btn.addEventListener('click', () => handleChipAction(btn.dataset.chip));
      });

      els.dropRatesBtn?.addEventListener('click', () => {
        if (state.busy || !state.gameReady) return;
        toggleDropPanel();
      });

      els.dropSkillBtn?.addEventListener('click', () => {
        activateDropSkill();
      });

      els.dropCloseBtn?.addEventListener('click', () => toggleDropPanel(false));
      els.dropPanel?.addEventListener('click', (event) => {
        const target = event.target;
        if (target === els.dropPanel) {
          toggleDropPanel(false);
        }
      });
      els.dailyClaimBtn?.addEventListener('click', () => {
        if (state.busy) return;
        claimDaily();
      });

      els.upgradeGrid?.addEventListener('click', (event) => {
        const button = event.target.closest('[data-upgrade]');
        if (!button || button.dataset.disabled === 'true') return;
        if (state.busy) return;
        purchaseUpgrade(button.dataset.upgrade);
      });

      els.spinBtn.addEventListener('click', spin);
      els.lineFlashBtn?.addEventListener('click', flashActiveLines);
      els.autoSpinBtn?.addEventListener('click', startAutoSpin);

      els.resetBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) {
          showAuthAlert('Sign in to use the slot machine.');
          return;
        }
        bootstrap();
      });

      els.syncBtn.addEventListener('click', () => {
        if (state.busy || !state.auth.token) return;
        bootstrap();
      });

      const purchaseUpgrade = async (type) => {
        if (!state.auth.token) {
          showAuthAlert('Sign in to upgrade your machine.');
          return;
        }
        const def = getUpgradeDef(type);
        if (!def) {
          showAlert('Upgrade unavailable.');
          return;
        }
        const serverLevel = state.serverUpgrades?.[type] || 0;
        const currentLevel = serverLevel;
        const maxLevel = getUpgradeMaxLevel(type);
        if (currentLevel >= maxLevel) {
          showAlert('Upgrade already maxed.');
          return;
        }
        if (def.requires) {
          const requirements = Array.isArray(def.requires) ? def.requires : [def.requires];
          const met = requirements.every(req => {
            const base = state.serverUpgrades?.[req] || 0;
            const pendingReq = state.pendingUpgrades?.[req] || 0;
            return base + pendingReq > 0;
          });
          if (!met) {
            showAlert('Unlock the prerequisite upgrade first.');
            return;
          }
        }
        setBusy(true);
        showAlert('');
        const applyUpgradeResult = (result) => {
          state.pendingUpgrades = {};
          state.serverUpgrades = result.upgrades || state.serverUpgrades;
          updateStats(result);
          log('Upgrade applied', def.label || type);
        };
        try {
          const result = await request('/session', { type });
          applyUpgradeResult(result);
        } catch (error) {
          const payload = error.payload || {};
          if (error.status === 404) {
            try {
              const result = await request('/upgrade', { type });
              applyUpgradeResult(result);
              return;
            } catch (fallbackError) {
              debugError('upgrade-fallback', fallbackError);
            }
          }
          if (!error.status && error.cause) {
            showAlert('Upgrade service unreachable. Please try again.');
          } else if (error.status === 404) {
            showAlert('Upgrade service unavailable. Please refresh and try again.');
          } else if (payload.errorCode === 'INSUFFICIENT_CREDITS') {
            showAlert('Not enough credits to purchase this upgrade.');
          } else if (payload.error) {
            showAlert(payload.error);
          } else {
            showAlert(error.message || 'Upgrade failed.');
          }
          debugError('upgrade', error, { payload });
        } finally {
          setBusy(false);
          renderUpgrades();
          renderSkillButton();
        }
      };

      if (els.authSubmit) {
        els.authSubmit.addEventListener('click', loginOrRegister);
      }
      (els.authTabs || []).forEach(btn => {
        btn.addEventListener('click', () => setAuthMode(btn.dataset.mode));
      });
      if (els.authInfo) {
        els.authInfo.addEventListener('click', () => {
          setAuthMode('register');
          els.authEmail?.focus();
        });
      }
      els.logoutBtn.addEventListener('click', logout);
      els.debugCoinBtn?.addEventListener('click', grantDebugCoins);
      els.deleteBtn?.addEventListener('click', deleteAccount);

      if (state.auth.token) {
        bootstrap();
      } else {
        setStatus('Sign in to start', 'error');
      }
    })();
  </script>
</body>
</html>
