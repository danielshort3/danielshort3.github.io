<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <base href="/">
  <title>Stellar Dogfight | Daniel Short</title>
  <meta name="theme-color" content="#0b1220" />
  <link rel="stylesheet" href="dist/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;500;600&family=Space+Grotesk:wght@500;600;700&display=swap" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b1220;
      --surface: #141f33;
      --surface-2: #1c2b45;
      --surface-3: #233456;
      --stroke: rgba(94, 146, 166, 0.35);
      --text: #e5f1ff;
      --text-muted: #a5b5d1;
      --accent: #44d2c2;
      --accent-2: #f6c65f;
      --tier-common: #ffffff;
      --tier-uncommon: #6ee7b7;
      --tier-rare: #7ca8ff;
      --tier-epic: #b98cff;
      --tier-legendary: #f6c65f;
      --danger: #f06969;
      --success: #6ee7b7;
      --shadow: 0 24px 50px rgba(4, 10, 24, 0.55);
      --radius: 18px;
      --radius-sm: 12px;
      --font-display: "Space Grotesk", "Chakra Petch", sans-serif;
      --font-body: "Chakra Petch", "Space Grotesk", sans-serif;
      --page-pad: clamp(16px, 3vw, 28px);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: var(--font-body);
      color: var(--text);
      background:
        radial-gradient(900px 420px at 15% -10%, rgba(68, 210, 194, 0.18), transparent 60%),
        radial-gradient(900px 520px at 85% -15%, rgba(246, 198, 95, 0.22), transparent 65%),
        linear-gradient(180deg, #0b1220 0%, #0b1728 55%, #0a101d 100%);
      padding: var(--page-pad);
      position: relative;
      overflow-x: hidden;
    }

    body.is-playing {
      padding: 0;
      overflow: hidden;
      background: #05090f;
    }

    body.is-playing::before {
      opacity: 0;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.08) 1px, transparent 0);
      background-size: 36px 36px;
      opacity: 0.25;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    main {
      position: relative;
      z-index: 1;
    }

    .mission-shell {
      width: min(1200px, 100%);
      margin: 0 auto;
      display: grid;
      gap: clamp(18px, 3vw, 26px);
      min-height: calc(100vh - (var(--page-pad) * 2));
    }

    body.is-playing .mission-shell {
      width: 100%;
      max-width: none;
      height: 100vh;
      min-height: 100vh;
      gap: 0;
      grid-template-rows: minmax(0, 1fr);
    }

    body.is-hangar .mission-shell {
      width: 100%;
      max-width: none;
    }

    .mission-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 20px;
      padding: clamp(18px, 3vw, 26px);
      border-radius: var(--radius);
      background: linear-gradient(130deg, rgba(26, 40, 63, 0.92), rgba(17, 28, 46, 0.92));
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
    }

    body.is-playing .mission-header {
      display: none;
    }

    .title-block {
      display: grid;
      gap: 8px;
      max-width: 640px;
    }

    .eyebrow {
      margin: 0;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      font-size: 0.7rem;
      color: var(--accent-2);
      font-weight: 600;
    }

    h1 {
      margin: 0;
      font-family: var(--font-display);
      font-size: clamp(1.6rem, 2.6vw, 2.4rem);
    }

    .title-block p {
      margin: 0;
      color: var(--text-muted);
      line-height: 1.6;
      font-size: 0.98rem;
    }

    .action-stack {
      display: grid;
      gap: 10px;
      min-width: 170px;
    }

    .btn {
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 10px 16px;
      font-family: var(--font-body);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .btn.primary {
      background: linear-gradient(120deg, var(--accent), #3aa3d8);
      color: #041219;
      box-shadow: 0 12px 26px rgba(68, 210, 194, 0.35);
    }

    .btn.primary:hover,
    .btn.primary:focus-visible {
      transform: translateY(-1px) scale(1.02);
    }

    .btn.ghost {
      background: rgba(12, 18, 32, 0.6);
      border-color: color-mix(in srgb, var(--stroke) 70%, transparent);
      color: var(--text);
    }

    .btn.ghost:hover,
    .btn.ghost:focus-visible {
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .mission-grid {
      display: grid;
      grid-template-columns: minmax(240px, 340px) minmax(0, 1fr);
      gap: clamp(16px, 2.4vw, 24px);
    }

    body.is-playing .mission-grid {
      height: 100%;
      grid-template-columns: 1fr;
      grid-template-rows: minmax(0, 1fr);
      gap: 0;
    }

    body.is-hangar .mission-grid {
      grid-template-columns: 1fr;
    }

    body.is-hangar .mission-grid,
    body.is-hangar .mission-sidebar,
    body.is-hangar .tab-shell,
    body.is-hangar .tab-panels {
      min-height: 0;
      height: 100%;
    }

    .mission-shell.is-wide {
      width: 100%;
      max-width: none;
    }

    .mission-grid.is-wide {
      grid-template-columns: minmax(0, 1fr);
    }

    .mission-grid.is-wide .mission-main {
      display: none;
    }

    body.is-playing .mission-grid.is-wide .mission-main {
      display: grid;
    }

    .mission-sidebar,
    .mission-main {
      display: grid;
      gap: clamp(14px, 2vw, 20px);
    }

    body.is-playing .mission-sidebar {
      display: none;
    }

    body.is-playing .mission-main {
      height: 100%;
    }

    body.is-hangar .mission-main {
      display: none;
    }

    .mission-main {
      position: relative;
    }

    .panel {
      background: linear-gradient(160deg, rgba(26, 38, 60, 0.92), rgba(14, 22, 38, 0.94));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }

    .panel-subsection {
      display: grid;
      gap: 10px;
      margin-top: 14px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
    }

    .panel-title {
      margin: 0;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .loadout-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }

    .loadout-item {
      padding: 10px;
      border-radius: var(--radius-sm);
      background: rgba(8, 14, 24, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      gap: 6px;
    }

    .loadout-item span {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-muted);
    }

    .loadout-item strong {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .tab-shell {
      display: grid;
      gap: 12px;
      grid-template-rows: auto minmax(0, 1fr);
    }

    .tab-bar {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 4px;
      scroll-behavior: smooth;
    }

    .armory-nav {
      margin-top: 6px;
    }

    .tab-btn {
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(12, 18, 32, 0.7);
      color: var(--text-muted);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 0.7rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-family: var(--font-body);
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }

    .tab-btn.is-active {
      background: linear-gradient(120deg, var(--accent), #3aa3d8);
      border-color: rgba(68, 210, 194, 0.7);
      color: #041219;
    }

    .tab-btn:focus-visible {
      outline: 2px solid color-mix(in srgb, var(--accent) 80%, transparent);
      outline-offset: 2px;
    }

    .tab-bar::-webkit-scrollbar {
      height: 6px;
    }

    .tab-bar::-webkit-scrollbar-thumb {
      background: rgba(68, 210, 194, 0.35);
      border-radius: 999px;
    }

    .tab-panels {
      min-height: 0;
    }

    .tab-panel {
      display: none;
      height: 100%;
      overflow-y: auto;
    }

    .tab-panel.is-active {
      display: block;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }

    h2 {
      margin: 0;
      font-size: 1.05rem;
      font-family: var(--font-display);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      background: rgba(12, 18, 32, 0.7);
      border: 1px solid var(--stroke);
      color: var(--text-muted);
    }

    .badge-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }

    .meter-row {
      display: grid;
      grid-template-columns: 60px 1fr auto;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .meter-label {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .meter {
      position: relative;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(8, 14, 24, 0.7);
      overflow: hidden;
    }

    .meter-fill {
      position: absolute;
      inset: 0;
      width: 0;
      border-radius: inherit;
      transition: width 0.2s ease;
    }

    .meter-fill.hull {
      background: linear-gradient(90deg, #46c1a3, #6ee7b7);
    }

    .meter-fill.shield {
      background: linear-gradient(90deg, #4f9cf7, #57e0ff);
    }

    .meter-fill.energy {
      background: linear-gradient(90deg, #f6c65f, #f39c3f);
    }

    .meter-value {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.9rem;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-row:last-child {
      border-bottom: none;
    }

    .panel-note {
      margin: 6px 0 12px;
      color: var(--text-muted);
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .chip-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 32px;
    }

    .chip {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(12, 18, 32, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 0.78rem;
      color: var(--text);
    }

    .upgrade-group {
      display: grid;
      gap: 8px;
    }

    .upgrade-group-title {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--text-muted);
    }

    [data-tier] {
      --tier-color: var(--tier-common);
    }

    [data-tier="uncommon"] {
      --tier-color: var(--tier-uncommon);
    }

    [data-tier="rare"] {
      --tier-color: var(--tier-rare);
    }

    [data-tier="epic"] {
      --tier-color: var(--tier-epic);
    }

    [data-tier="legendary"] {
      --tier-color: var(--tier-legendary);
    }

    .chip[data-tier] {
      border-color: color-mix(in srgb, var(--tier-color) 45%, rgba(255, 255, 255, 0.12));
      color: var(--tier-color);
    }

    .tier-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .tier-pill {
      border-color: color-mix(in srgb, var(--tier-color) 55%, transparent);
      color: var(--tier-color);
      background: color-mix(in srgb, var(--tier-color) 12%, transparent);
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-weight: 600;
    }

    .tier-pill-header {
      font-size: 0.68rem;
      padding: 4px 10px;
    }

    .tier-section {
      display: grid;
      gap: 10px;
      padding: 10px;
      border-radius: var(--radius-sm);
      border: 1px dashed rgba(255, 255, 255, 0.1);
      background: rgba(8, 14, 24, 0.4);
    }

    .tier-section[data-tier] {
      border-color: color-mix(in srgb, var(--tier-color) 35%, rgba(255, 255, 255, 0.1));
      border-left: 3px solid color-mix(in srgb, var(--tier-color) 60%, transparent);
    }

    .tier-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .tier-title {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.7rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .tier-section[data-tier] .tier-title {
      color: var(--tier-color);
    }

    .tier-count {
      font-size: 0.72rem;
      color: var(--text-muted);
    }

    .compare-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .stat-diff {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .stat-diff.is-positive {
      border-color: color-mix(in srgb, var(--success) 45%, transparent);
      color: var(--success);
    }

    .stat-diff.is-negative {
      border-color: color-mix(in srgb, var(--danger) 45%, transparent);
      color: var(--danger);
    }

    .stat-diff.is-neutral {
      color: var(--text-muted);
    }

    .card-grid {
      display: grid;
      gap: 10px;
    }

    #tab-armory .card-grid,
    #tab-shipyard .card-grid,
    #tab-hangar .card-grid {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-content: start;
    }

    #tab-armory .card-grid > .tier-section,
    #tab-shipyard .card-grid > .tier-section,
    #tab-hangar .card-grid > .tier-section {
      grid-column: 1 / -1;
    }

    .select-card {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(10, 16, 28, 0.8);
      padding: 10px 12px;
      text-align: left;
      color: var(--text);
      cursor: pointer;
      display: grid;
      gap: 6px;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }

    .select-card:hover,
    .select-card:focus-visible {
      border-color: color-mix(in srgb, var(--tier-color, var(--accent)) 70%, var(--accent) 30%);
      transform: translateY(-1px);
    }

    .select-card.is-active {
      border-color: var(--accent-2);
      background: rgba(22, 34, 54, 0.9);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
    }

    .select-card[data-tier] {
      border-color: color-mix(in srgb, var(--tier-color) 35%, rgba(255, 255, 255, 0.12));
    }

    .select-card.is-active[data-tier] {
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--tier-color) 45%, transparent),
        0 12px 24px rgba(0, 0, 0, 0.25);
    }

    .select-card[disabled] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .select-card.is-static {
      cursor: default;
    }

    .select-card.is-static:hover,
    .select-card.is-static:focus-visible {
      border-color: rgba(255, 255, 255, 0.12);
      transform: none;
    }

    .select-title {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .select-meta {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .select-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .select-pill {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .contract-card {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(12, 18, 32, 0.75);
      padding: 10px 12px;
      display: grid;
      gap: 8px;
    }

    .contract-title {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .contract-meta {
      font-size: 0.78rem;
      color: var(--text-muted);
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
    }

    .contract-progress {
      height: 8px;
      border-radius: 999px;
      background: rgba(8, 14, 24, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .contract-progress span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, #4f9cf7, #57e0ff);
      width: 0%;
      transition: width 0.2s ease;
    }

    .faction-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .faction-card {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(12, 18, 32, 0.75);
      padding: 10px;
      display: grid;
      gap: 6px;
    }

    .faction-card span {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .faction-card strong {
      font-size: 0.95rem;
    }

    .history-list {
      display: grid;
      gap: 8px;
    }

    .history-entry {
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(8, 14, 24, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 0.82rem;
      color: var(--text-muted);
      display: grid;
      gap: 4px;
    }

    .setting-group {
      display: grid;
      gap: 10px;
      padding: 10px;
      border-radius: var(--radius-sm);
      background: rgba(8, 14, 24, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .setting-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      font-size: 0.85rem;
    }

    .setting-row span {
      color: var(--text-muted);
    }

    .option-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .option-btn {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(12, 18, 32, 0.7);
      color: var(--text-muted);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      transition: border-color 0.2s ease, color 0.2s ease, background 0.2s ease;
    }

    .option-btn.is-active {
      background: rgba(68, 210, 194, 0.2);
      border-color: rgba(68, 210, 194, 0.6);
      color: var(--text);
    }

    .keybind-list {
      display: grid;
      gap: 8px;
    }

    .keybind-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.82rem;
    }

    .keybind-btn {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(12, 18, 32, 0.8);
      color: var(--text);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 0.78rem;
      cursor: pointer;
      min-width: 68px;
      text-align: center;
    }

    .hangar-grid {
      display: grid;
      gap: 10px;
    }

    .hangar-card {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(10, 16, 28, 0.8);
      padding: 10px 12px;
      text-align: left;
      color: var(--text);
      cursor: pointer;
      display: grid;
      gap: 6px;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }

    .hangar-card:hover,
    .hangar-card:focus-visible {
      border-color: color-mix(in srgb, var(--tier-color, var(--accent)) 70%, var(--accent) 30%);
      transform: translateY(-1px);
    }

    .hangar-card[disabled] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .hangar-card[data-tier] {
      border-color: color-mix(in srgb, var(--tier-color) 45%, rgba(255, 255, 255, 0.12));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--tier-color) 20%, transparent);
    }

    .hangar-title {
      font-weight: 600;
    }

    .hangar-meta {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .progress-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }

    .stat-tile {
      padding: 10px;
      border-radius: var(--radius-sm);
      background: rgba(10, 16, 28, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      gap: 6px;
    }

    .stat-tile span {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .stat-tile strong {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .arena-frame {
      position: relative;
      border-radius: var(--radius);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: #05090f;
      aspect-ratio: 16 / 9;
      min-height: 320px;
      box-shadow: var(--shadow);
    }

    body.is-playing .arena-frame {
      height: 100%;
      min-height: 100%;
      border-radius: 0;
      border: none;
      box-shadow: none;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
      cursor: crosshair;
    }

    .arena-controls {
      position: absolute;
      right: 16px;
      top: 16px;
      display: flex;
      gap: 8px;
      z-index: 4;
    }

    .btn.btn-mini {
      padding: 8px 12px;
      font-size: 0.75rem;
    }

    .arena-hud {
      position: absolute;
      left: 16px;
      bottom: 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      z-index: 3;
    }

    .arena-vitals {
      position: absolute;
      left: 16px;
      top: 16px;
      display: grid;
      gap: 6px;
      min-width: 220px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(8, 14, 24, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.12);
      z-index: 3;
    }

    .arena-minimap {
      position: absolute;
      right: 16px;
      bottom: 16px;
      width: 160px;
      height: 160px;
      padding: 8px;
      border-radius: 14px;
      background: rgba(8, 14, 24, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
      pointer-events: none;
      z-index: 3;
    }

    .arena-minimap canvas {
      width: 100%;
      height: 100%;
      cursor: default;
    }

    .settings-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(5, 9, 15, 0.8);
      backdrop-filter: blur(6px);
      z-index: 6;
    }

    .settings-overlay[hidden] {
      display: none;
    }

    .settings-shell {
      position: relative;
      width: min(720px, 92vw);
      max-height: min(90vh, 900px);
      overflow: hidden;
    }

    .settings-shell .panel {
      max-height: min(90vh, 900px);
      overflow-y: auto;
    }

    .settings-close {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1;
    }

    .vital-row {
      display: grid;
      grid-template-columns: 52px 1fr auto;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
    }

    .vital-label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      font-size: 0.65rem;
    }

    .vital-value {
      color: var(--text);
      font-size: 0.75rem;
      white-space: nowrap;
    }

    .arena-vitals .meter {
      height: 8px;
    }

    .arena-tips {
      position: absolute;
      right: 16px;
      top: 60px;
      display: grid;
      gap: 8px;
      max-width: 260px;
      z-index: 4;
    }

    .tip-card {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(12, 18, 32, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.16);
      font-size: 0.8rem;
      line-height: 1.4;
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35);
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    .tip-card:hover {
      border-color: rgba(68, 210, 194, 0.6);
      transform: translateY(-1px);
    }

    .tip-card strong {
      display: block;
      font-size: 0.86rem;
      margin-bottom: 4px;
    }

    .hud-pill {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(12, 18, 32, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .hud-pill strong {
      font-size: 0.85rem;
      letter-spacing: normal;
    }

    .arena-overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(6, 10, 18, 0.65);
      backdrop-filter: blur(5px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 4;
    }

    .arena-overlay.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-card {
      background: linear-gradient(160deg, rgba(24, 36, 56, 0.95), rgba(15, 23, 40, 0.96));
      border-radius: var(--radius);
      border: 1px solid rgba(255, 255, 255, 0.16);
      padding: 22px;
      width: min(620px, 90%);
      display: grid;
      gap: 16px;
      box-shadow: var(--shadow);
      animation: floatIn 0.4s ease;
    }

    .overlay-header h3 {
      margin: 0;
      font-family: var(--font-display);
      font-size: 1.4rem;
    }

    .overlay-header p {
      margin: 0;
      color: var(--text-muted);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .overlay-list {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 6px;
      color: var(--text-muted);
      font-size: 0.92rem;
    }

    .overlay-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .overlay-badges {
      justify-content: flex-start;
    }

    .upgrade-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
    }

    .upgrade-choice-grid {
      align-items: stretch;
    }

    .arena-overlay .upgrade-grid {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .arena-overlay .reward-grid {
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
    }

    .upgrade-card {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(12, 18, 32, 0.8);
      padding: 12px 14px;
      text-align: left;
      color: var(--text);
      cursor: pointer;
      display: grid;
      gap: 6px;
      transition: transform 0.2s ease, border-color 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .upgrade-card.is-choice {
      text-align: center;
      padding: 42px 16px 16px;
      min-height: 255px;
      justify-items: center;
      gap: 8px;
    }

    .upgrade-card.is-choice .upgrade-ribbon {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      padding: 5px 10px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--tier-color) 70%, rgba(10, 16, 28, 0.6));
      border: 1px solid color-mix(in srgb, var(--tier-color) 80%, rgba(255, 255, 255, 0.2));
      font-size: 0.62rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: #081019;
      font-weight: 700;
    }

    .upgrade-card.is-choice .upgrade-icon {
      width: 58px;
      height: 58px;
      border-radius: 18px;
      border: 1px solid color-mix(in srgb, var(--tier-color) 60%, rgba(255, 255, 255, 0.2));
      background: color-mix(in srgb, var(--tier-color) 18%, rgba(12, 18, 32, 0.7));
      display: grid;
      place-items: center;
      font-size: 1.6rem;
      margin-top: 6px;
    }

    .upgrade-card.is-choice .upgrade-category {
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .upgrade-card.is-choice .upgrade-title {
      font-size: 1.05rem;
    }

    .upgrade-card.is-choice .upgrade-desc {
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .upgrade-card.is-choice .upgrade-kind {
      margin-top: auto;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 0.62rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .upgrade-card.is-choice[data-kind="skill"] .upgrade-kind {
      border-color: rgba(68, 210, 194, 0.6);
      color: var(--accent);
      background: rgba(68, 210, 194, 0.12);
    }

    .upgrade-card.is-choice[data-kind="stat"] .upgrade-kind {
      border-color: rgba(124, 168, 255, 0.5);
      color: #7ca8ff;
      background: rgba(124, 168, 255, 0.1);
    }

    .upgrade-card.is-choice .upgrade-stack {
      top: 12px;
      right: 16px;
    }

    .upgrade-stack {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(8, 14, 24, 0.7);
      font-size: 0.7rem;
      color: var(--text-muted);
      letter-spacing: 0.08em;
    }

    .category-pill {
      min-width: 28px;
      text-align: center;
      font-size: 0.8rem;
      padding: 4px 6px;
    }

    .upgrade-card.is-static {
      cursor: default;
      pointer-events: none;
    }

    .upgrade-card[data-tier] {
      border-color: color-mix(in srgb, var(--tier-color) 45%, rgba(255, 255, 255, 0.16));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--tier-color) 20%, transparent);
    }

    .upgrade-card[data-kind="skill"] {
      background: linear-gradient(160deg, rgba(18, 26, 44, 0.9), rgba(12, 18, 32, 0.9));
      box-shadow: 0 0 0 1px rgba(68, 210, 194, 0.25);
    }

    .skill-pill {
      border-color: rgba(68, 210, 194, 0.6);
      color: var(--accent);
      background: rgba(68, 210, 194, 0.12);
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-weight: 600;
    }

    .upgrade-card[data-tier="epic"],
    .upgrade-card[data-tier="legendary"] {
      animation: tierPulse 2.2s ease-in-out infinite;
    }

    .upgrade-card[data-tier="legendary"] {
      background: linear-gradient(160deg, rgba(22, 32, 50, 0.9), rgba(18, 26, 44, 0.96));
    }

    .upgrade-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .reward-grid {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      justify-items: center;
    }

    .reward-item {
      position: relative;
      display: grid;
      place-items: center;
      gap: 6px;
      min-height: 108px;
      width: 100%;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid color-mix(in srgb, var(--tier-color) 45%, rgba(255, 255, 255, 0.12));
      background: linear-gradient(160deg, rgba(34, 24, 16, 0.9), rgba(18, 14, 12, 0.95));
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--tier-color) 18%, transparent);
    }

    .reward-icon {
      width: 56px;
      height: 56px;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, var(--tier-color) 60%, rgba(255, 255, 255, 0.2));
      display: grid;
      place-items: center;
      font-size: 1.4rem;
      color: var(--tier-color);
      background: color-mix(in srgb, var(--tier-color) 18%, rgba(10, 16, 28, 0.7));
    }

    .reward-value {
      position: absolute;
      right: 12px;
      bottom: 10px;
      font-size: 0.95rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
    }

    .reward-name {
      display: none;
    }

    .reward-banner {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .reward-line {
      height: 1px;
      background: rgba(255, 255, 255, 0.12);
    }

    .reward-title {
      font-size: 0.72rem;
      letter-spacing: 0.32em;
      text-transform: uppercase;
      color: var(--text);
      font-weight: 600;
    }

    .upgrade-card:hover,
    .upgrade-card:focus-visible {
      transform: translateY(-1px);
      border-color: color-mix(in srgb, var(--tier-color, var(--accent-2)) 70%, var(--accent-2) 30%);
    }

    .upgrade-title {
      font-weight: 600;
      font-size: 1rem;
    }

    .upgrade-desc {
      font-size: 0.86rem;
      color: var(--text-muted);
    }

    .mission-log {
      min-height: 0;
    }

    .log-list {
      display: grid;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .log-entry {
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(8, 14, 24, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .mission-header,
    .mission-sidebar .panel,
    .arena-frame,
    .mission-main .panel {
      animation: riseIn 0.6s ease both;
    }

    .mission-header {
      animation-delay: 0.05s;
    }

    .mission-sidebar .panel:nth-child(1) {
      animation-delay: 0.08s;
    }

    .mission-sidebar .panel:nth-child(2) {
      animation-delay: 0.12s;
    }

    .mission-sidebar .panel:nth-child(3) {
      animation-delay: 0.16s;
    }

    .mission-sidebar .panel:nth-child(4) {
      animation-delay: 0.2s;
    }

    .mission-sidebar .panel:nth-child(5) {
      animation-delay: 0.24s;
    }

    .arena-frame {
      animation-delay: 0.14s;
    }

    .mission-main .panel {
      animation-delay: 0.2s;
    }

    @keyframes floatIn {
      0% {
        transform: translateY(12px) scale(0.98);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes riseIn {
      0% {
        transform: translateY(16px);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes tierPulse {
      0% {
        box-shadow: 0 0 0 1px color-mix(in srgb, var(--tier-color) 20%, transparent),
          0 0 16px color-mix(in srgb, var(--tier-color) 30%, transparent);
      }
      50% {
        box-shadow: 0 0 0 1px color-mix(in srgb, var(--tier-color) 25%, transparent),
          0 0 28px color-mix(in srgb, var(--tier-color) 45%, transparent);
      }
      100% {
        box-shadow: 0 0 0 1px color-mix(in srgb, var(--tier-color) 20%, transparent),
          0 0 16px color-mix(in srgb, var(--tier-color) 30%, transparent);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .mission-header,
      .mission-sidebar .panel,
      .arena-frame,
      .mission-main .panel,
      .overlay-card {
        animation: none;
      }

      .btn,
      .hangar-card,
      .upgrade-card {
        transition: none;
      }

      .upgrade-card[data-tier="epic"],
      .upgrade-card[data-tier="legendary"] {
        animation: none;
      }
    }

    @media (min-width: 980px) {
      body {
        height: 100vh;
        overflow: hidden;
      }

      .mission-shell {
        height: calc(100vh - (var(--page-pad) * 2));
        grid-template-rows: auto minmax(0, 1fr);
      }

      .mission-grid {
        align-items: stretch;
        min-height: 0;
        height: 100%;
      }

      .mission-sidebar,
      .mission-main {
        min-height: 0;
        height: 100%;
      }

      .tab-shell,
      .tab-panels {
        min-height: 0;
        height: 100%;
      }

      .arena-frame {
        height: 100%;
        min-height: 0;
        aspect-ratio: auto;
      }
    }

    @media (max-width: 980px) {
      .mission-grid {
        grid-template-columns: 1fr;
      }

      .action-stack {
        width: 100%;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }

      .mission-header {
        flex-direction: column;
      }
    }

    @media (max-width: 640px) {
      .mission-header {
        padding: 16px;
      }

      .panel {
        padding: 14px;
      }

      .arena-hud {
        left: 10px;
        bottom: 10px;
      }

      .arena-minimap {
        right: 10px;
        bottom: 10px;
        width: 120px;
        height: 120px;
        padding: 6px;
      }
    }
  </style>
</head>
<body>
  <main class="mission-shell">
    <header class="mission-header">
      <div class="title-block">
        <p class="eyebrow">Arcade dogfighter</p>
        <h1>Stellar Dogfight: Vanguard Rift</h1>
        <p>Mouse aim with WASD or arrow thrust. Keyboard-only: aim with arrow keys and thrust with WASD. Hold left click or Space to fire, Shift boosts, Esc or P pauses, and U opens the upgrade dock in Frontier mode.</p>
      </div>
      <div class="action-stack">
        <button class="btn primary" data-action="launch">Launch mission</button>
        <button class="btn ghost" data-action="training">Training</button>
        <button class="btn ghost" data-action="dock">Upgrade dock</button>
        <button class="btn ghost" data-action="pause">Pause</button>
        <button class="btn ghost" data-action="reset">Reset run</button>
      </div>
    </header>

    <section class="mission-grid">
      <div class="mission-sidebar">
        <div class="tab-shell" data-tab-group="sidebar" data-tab-default="systems">
          <div class="tab-bar" role="tablist" aria-label="Ship panels">
            <button class="tab-btn is-active" id="tab-btn-systems" type="button" data-tab-target="systems" role="tab" aria-controls="tab-systems" aria-selected="true" tabindex="0">Systems</button>
            <button class="tab-btn" id="tab-btn-upgrades" type="button" data-tab-target="upgrades" role="tab" aria-controls="tab-upgrades" aria-selected="false" tabindex="-1">Upgrades</button>
            <button class="tab-btn" id="tab-btn-shipyard" type="button" data-tab-target="shipyard" role="tab" aria-controls="tab-shipyard" aria-selected="false" tabindex="-1">Shipyard</button>
            <button class="tab-btn" id="tab-btn-armory" type="button" data-tab-target="armory" role="tab" aria-controls="tab-armory" aria-selected="false" tabindex="-1">Armory</button>
            <button class="tab-btn" id="tab-btn-contracts" type="button" data-tab-target="contracts" role="tab" aria-controls="tab-contracts" aria-selected="false" tabindex="-1">Contracts</button>
            <button class="tab-btn" id="tab-btn-progress" type="button" data-tab-target="progress" role="tab" aria-controls="tab-progress" aria-selected="false" tabindex="-1">Progress</button>
            <button class="tab-btn" id="tab-btn-settings" type="button" data-tab-target="settings" role="tab" aria-controls="tab-settings" aria-selected="false" tabindex="-1">Settings</button>
          </div>
          <div class="tab-panels">
            <section class="panel tab-panel is-active" id="tab-systems" data-tab-panel="systems" role="tabpanel" aria-labelledby="tab-btn-systems">
              <div class="panel-header">
                <h2>Ship Systems</h2>
                <div class="badge-group">
                  <span class="badge" data-stat="status">Hangar</span>
                  <span class="badge" data-stat="mode-label">Arcade</span>
                  <span class="badge" data-stat="sector">Sector 01</span>
                </div>
              </div>
              <div class="meter-row">
                <div class="meter-label">Hull</div>
                <div class="meter">
                  <span class="meter-fill hull" data-meter="hull"></span>
                </div>
                <div class="meter-value" data-stat="hull-text">--</div>
              </div>
              <div class="meter-row">
                <div class="meter-label">Shield</div>
                <div class="meter">
                  <span class="meter-fill shield" data-meter="shield"></span>
                </div>
                <div class="meter-value" data-stat="shield-text">--</div>
              </div>
              <div class="meter-row">
                <div class="meter-label">Energy</div>
                <div class="meter">
                  <span class="meter-fill energy" data-meter="energy"></span>
                </div>
                <div class="meter-value" data-stat="energy-text">--</div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Loadout</h3>
                <div class="loadout-grid">
                  <div class="loadout-item">
                    <span>Ship</span>
                    <strong data-stat="ship-name">-</strong>
                  </div>
                  <div class="loadout-item">
                    <span>Weapon</span>
                    <strong data-stat="weapon-name">-</strong>
                  </div>
                  <div class="loadout-item">
                    <span>Secondary</span>
                    <strong data-stat="secondary-name">-</strong>
                  </div>
                </div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Systems</h3>
                <div class="stat-row"><span>Ability</span><strong data-stat="ability-status">Ready</strong></div>
                <div class="stat-row"><span>Secondary</span><strong data-stat="secondary-status">Ready</strong></div>
                <div class="stat-row"><span>Sector Mod</span><strong data-stat="sector-mod">Clear</strong></div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Flight Stats</h3>
                <div class="stat-row"><span>Damage</span><strong data-stat="damage">-</strong></div>
                <div class="stat-row"><span>Fire Rate</span><strong data-stat="fire-rate">-</strong></div>
                <div class="stat-row"><span>Max Speed</span><strong data-stat="speed">-</strong></div>
                <div class="stat-row"><span>Shield Regen</span><strong data-stat="shield-regen">-</strong></div>
                <div class="stat-row"><span>Energy Regen</span><strong data-stat="energy-regen">-</strong></div>
                <div class="stat-row"><span>Crit Chance</span><strong data-stat="crit">-</strong></div>
              </div>
            </section>

            <section class="panel tab-panel" id="tab-upgrades" data-tab-panel="upgrades" role="tabpanel" aria-labelledby="tab-btn-upgrades" hidden>
              <div class="panel-header">
                <h2>Upgrades</h2>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Field Upgrades</h3>
                <p class="panel-note">Choose one upgrade after each wave. Skill systems are limited to 3 choices and level from Common to Legendary over 5 upgrades.</p>
                <div class="tier-legend" aria-label="Upgrade tiers">
                  <span class="select-pill tier-pill" data-tier="common">Common</span>
                  <span class="select-pill tier-pill" data-tier="uncommon">Uncommon</span>
                  <span class="select-pill tier-pill" data-tier="rare">Rare</span>
                  <span class="select-pill tier-pill" data-tier="epic">Epic</span>
                  <span class="select-pill tier-pill" data-tier="legendary">Legendary</span>
                </div>
                <div class="chip-list" data-role="active-upgrades"></div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Hangar Upgrades</h3>
                <p class="panel-note">Spend tech points between sorties. Costs rise with each level and upgrades apply to the next launch.</p>
                <div class="hangar-grid card-grid" data-role="hangar"></div>
              </div>
            </section>

            <section class="panel tab-panel" id="tab-shipyard" data-tab-panel="shipyard" role="tabpanel" aria-labelledby="tab-btn-shipyard" hidden>
              <div class="panel-header">
                <h2>Shipyard</h2>
                <span class="badge" data-stat="blueprints">Blueprints 0</span>
              </div>
              <p class="panel-note">Unlock ships with credits, rank, and blueprints to expand your fleet.</p>
              <div class="setting-group">
                <div class="setting-row">
                  <span>Tier Filter</span>
                  <div class="option-buttons" data-setting="shipyard-tier">
                    <button class="option-btn is-active" type="button" data-option="all">All</button>
                    <button class="option-btn" type="button" data-option="1">Tier 1</button>
                    <button class="option-btn" type="button" data-option="2">Tier 2</button>
                    <button class="option-btn" type="button" data-option="3">Tier 3</button>
                  </div>
                </div>
              </div>
              <div class="card-grid" data-role="shipyard"></div>
            </section>

            <section class="panel tab-panel" id="tab-armory" data-tab-panel="armory" role="tabpanel" aria-labelledby="tab-btn-armory" hidden>
              <div class="panel-header">
                <h2>Armory</h2>
                <div class="badge-group">
                  <span class="badge" data-stat="banked-credits">Credits 0</span>
                  <span class="badge" data-stat="salvage-keys">Keys 0</span>
                </div>
              </div>
              <p class="panel-note">Swap weapons and secondaries. Cards show tier and stat deltas vs your equipped loadout. Upgrades persist between runs.</p>
              <div class="tier-legend" aria-label="Armory tiers">
                <span class="select-pill tier-pill" data-tier="common">Common</span>
                <span class="select-pill tier-pill" data-tier="uncommon">Uncommon</span>
                <span class="select-pill tier-pill" data-tier="rare">Rare</span>
                <span class="select-pill tier-pill" data-tier="epic">Epic</span>
                <span class="select-pill tier-pill" data-tier="legendary">Legendary</span>
              </div>
              <div class="tab-bar armory-nav" data-armory-nav>
                <button class="tab-btn is-active" type="button" data-armory-target="weapons">Weapons</button>
                <button class="tab-btn" type="button" data-armory-target="upgrades">Weapon Upgrades</button>
                <button class="tab-btn" type="button" data-armory-target="secondaries">Secondaries</button>
                <button class="tab-btn" type="button" data-armory-target="parts">Parts</button>
                <button class="tab-btn" type="button" data-armory-target="salvage">Salvage</button>
              </div>
              <div class="panel-subsection" data-armory-section="weapons">
                <h3 class="panel-title">Primary Weapons</h3>
                <div class="card-grid" data-role="weapons"></div>
              </div>
              <div class="panel-subsection" data-armory-section="upgrades">
                <h3 class="panel-title">Weapon Upgrades</h3>
                <div class="upgrade-grid" data-role="weapon-upgrades"></div>
              </div>
              <div class="panel-subsection" data-armory-section="secondaries">
                <h3 class="panel-title">Secondary Systems</h3>
                <div class="card-grid" data-role="secondaries"></div>
              </div>
              <div class="panel-subsection" data-armory-section="parts">
                <h3 class="panel-title">Parts</h3>
                <div class="setting-group">
                  <div class="setting-row">
                    <span>Parts Mode</span>
                    <div class="option-buttons" data-setting="parts-mode">
                      <button class="option-btn is-active" type="button" data-option="equip">Equip</button>
                      <button class="option-btn" type="button" data-option="dismantle">Dismantle</button>
                    </div>
                  </div>
                </div>
                <p class="panel-note">Dismantle mode sells parts for credits and removes them from inventory.</p>
                <div class="card-grid" data-role="parts-slots"></div>
                <div class="card-grid" data-role="parts-inventory"></div>
              </div>
              <div class="panel-subsection" data-armory-section="salvage">
                <h3 class="panel-title">Salvage Cache</h3>
                <p class="panel-note">Recover salvage keys from enemy drops to open caches with random rewards.</p>
                <div class="card-grid" data-role="salvage"></div>
              </div>
            </section>

            <section class="panel tab-panel" id="tab-contracts" data-tab-panel="contracts" role="tabpanel" aria-labelledby="tab-btn-contracts" hidden>
              <div class="panel-header">
                <h2>Contracts</h2>
                <span class="badge" data-stat="contract-status">Offline</span>
              </div>
              <p class="panel-note">Optional objectives add bonuses and faction reputation.</p>
              <div class="card-grid" data-role="contracts"></div>
              <div class="panel-subsection">
                <h3 class="panel-title">Faction Reputation</h3>
                <div class="faction-grid" data-role="factions"></div>
              </div>
            </section>

            <section class="panel tab-panel" id="tab-progress" data-tab-panel="progress" role="tabpanel" aria-labelledby="tab-btn-progress" hidden>
              <div class="panel-header">
                <h2>Progress</h2>
              </div>
              <div class="progress-grid">
                <div class="stat-tile">
                  <span>Rank</span>
                  <strong data-stat="rank">1</strong>
                </div>
                <div class="stat-tile">
                  <span>XP</span>
                  <strong data-stat="xp">0 / 0</strong>
                </div>
                <div class="stat-tile">
                  <span>Tech Points</span>
                  <strong data-stat="tech-points">0</strong>
                </div>
                <div class="stat-tile">
                  <span>Banked Credits</span>
                  <strong data-stat="banked-credits-total">0</strong>
                </div>
                <div class="stat-tile">
                  <span>Best Wave</span>
                  <strong data-stat="best-wave">1</strong>
                </div>
                <div class="stat-tile">
                  <span>Total Kills</span>
                  <strong data-stat="total-kills">0</strong>
                </div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Run History</h3>
                <div class="history-list" data-role="history"></div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Mission Log</h3>
                <div class="log-list" data-role="log"></div>
              </div>
            </section>

            <section class="panel tab-panel" id="tab-settings" data-tab-panel="settings" role="tabpanel" aria-labelledby="tab-btn-settings" hidden>
              <div class="panel-header">
                <h2>Settings</h2>
                <span class="badge" data-stat="control-mode">Hybrid</span>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Mission Mode</h3>
                <div class="setting-group">
                  <div class="setting-row">
                    <span>Run Type</span>
                    <div class="option-buttons" data-setting="game-mode">
                      <button class="option-btn is-active" type="button" data-option="arcade">Arcade</button>
                      <button class="option-btn" type="button" data-option="frontier">Frontier</button>
                    </div>
                  </div>
                </div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Difficulty</h3>
                <div class="setting-group">
                  <div class="setting-row">
                    <span>AI Difficulty</span>
                    <div class="option-buttons" data-setting="difficulty">
                      <button class="option-btn" type="button" data-option="easy">Easy</button>
                      <button class="option-btn is-active" type="button" data-option="normal">Normal</button>
                      <button class="option-btn" type="button" data-option="hard">Hard</button>
                      <button class="option-btn" type="button" data-option="adaptive">Adaptive</button>
                    </div>
                  </div>
                </div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Controls</h3>
                <div class="setting-group">
                  <div class="setting-row">
                    <span>Input Preset</span>
                    <div class="option-buttons" data-setting="input-mode">
                      <button class="option-btn is-active" type="button" data-option="hybrid">Mouse + Keyboard</button>
                      <button class="option-btn" type="button" data-option="keyboard">Keyboard Only</button>
                    </div>
                  </div>
                  <div class="keybind-list" data-role="keybinds"></div>
                </div>
              </div>
              <div class="panel-subsection">
                <h3 class="panel-title">Visuals</h3>
                <div class="setting-group">
                  <div class="setting-row">
                    <span>Particle Density</span>
                    <div class="option-buttons" data-setting="particles">
                      <button class="option-btn" type="button" data-option="low">Low</button>
                      <button class="option-btn is-active" type="button" data-option="medium">Medium</button>
                      <button class="option-btn" type="button" data-option="high">High</button>
                    </div>
                  </div>
                  <div class="setting-row">
                    <span>Hit Flash</span>
                    <div class="option-buttons" data-setting="hit-flash">
                      <button class="option-btn is-active" type="button" data-option="on">On</button>
                      <button class="option-btn" type="button" data-option="off">Off</button>
                    </div>
                  </div>
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>

      <div class="mission-main">
        <div class="arena-frame">
          <canvas data-role="battlefield"></canvas>
          <div class="arena-overlay" data-role="overlay">
            <div class="overlay-card" data-role="overlay-content"></div>
          </div>
          <div class="arena-tips" data-role="tips" aria-live="polite"></div>
          <div class="arena-controls">
            <button class="btn ghost btn-mini" type="button" data-action="settings">Settings</button>
          </div>
          <div class="arena-hud">
            <div class="hud-pill">Wave <strong data-stat="wave">1</strong></div>
            <div class="hud-pill" data-role="tier-pill">Tier <strong data-stat="tier">1</strong></div>
            <div class="hud-pill">Enemies <strong data-stat="enemy-count">0</strong></div>
            <div class="hud-pill">Score <strong data-stat="score">0</strong></div>
            <div class="hud-pill">Credits <strong data-stat="credits">0</strong></div>
          </div>
          <div class="arena-vitals" aria-label="Ship vitals">
            <div class="vital-row">
              <span class="vital-label">Hull</span>
              <div class="meter">
                <span class="meter-fill hull" data-hud-meter="hull"></span>
              </div>
              <span class="vital-value" data-hud-stat="hull">--</span>
            </div>
            <div class="vital-row">
              <span class="vital-label">Shield</span>
              <div class="meter">
                <span class="meter-fill shield" data-hud-meter="shield"></span>
              </div>
              <span class="vital-value" data-hud-stat="shield">--</span>
            </div>
            <div class="vital-row">
              <span class="vital-label">Energy</span>
              <div class="meter">
                <span class="meter-fill energy" data-hud-meter="energy"></span>
              </div>
              <span class="vital-value" data-hud-stat="energy">--</span>
            </div>
          </div>
          <div class="arena-minimap" aria-hidden="true">
            <canvas data-role="minimap"></canvas>
          </div>
        </div>
        <div class="settings-overlay" data-role="settings-overlay" hidden>
          <div class="settings-shell">
            <button class="btn ghost btn-mini settings-close" type="button" data-action="settings-close">Close</button>
            <div data-role="settings-body"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script src="js/demos/stellar-dogfight-data.js"></script>
  <script>
    (() => {
      "use strict";

      const STORAGE_KEY = "stellarDogfightProgress";
      const UPGRADE_REROLL_COST = 60;
      const UPGRADE_REROLL_SCALE = 1.85;
      const WORLD_WIDTH = 3200;
      const WORLD_HEIGHT = 1800;
      const SKILL_LIMIT = 3;
      const HUD_UPDATE_INTERVAL_MS = 50;
      const dom = {
        canvas: document.querySelector("[data-role='battlefield']"),
        overlay: document.querySelector("[data-role='overlay']"),
        overlayContent: document.querySelector("[data-role='overlay-content']"),
        tips: document.querySelector("[data-role='tips']"),
        log: document.querySelector("[data-role='log']"),
        activeUpgrades: document.querySelector("[data-role='active-upgrades']"),
        hangar: document.querySelector("[data-role='hangar']"),
        shipyard: document.querySelector("[data-role='shipyard']"),
        weapons: document.querySelector("[data-role='weapons']"),
        weaponUpgrades: document.querySelector("[data-role='weapon-upgrades']"),
        secondaries: document.querySelector("[data-role='secondaries']"),
        partsSlots: document.querySelector("[data-role='parts-slots']"),
        partsInventory: document.querySelector("[data-role='parts-inventory']"),
        salvage: document.querySelector("[data-role='salvage']"),
        contracts: document.querySelector("[data-role='contracts']"),
        factions: document.querySelector("[data-role='factions']"),
        history: document.querySelector("[data-role='history']"),
        keybinds: document.querySelector("[data-role='keybinds']"),
        tierPill: document.querySelector("[data-role='tier-pill']"),
        minimap: document.querySelector("[data-role='minimap']"),
        settingsOverlay: document.querySelector("[data-role='settings-overlay']"),
        settingsBody: document.querySelector("[data-role='settings-body']")
      };
      const settingsPanel = document.querySelector("[data-tab-panel='settings']");
      const settingsHome = settingsPanel ? settingsPanel.parentElement : null;
      const settingsAnchor = settingsPanel ? settingsPanel.nextElementSibling : null;
      let settingsOpen = false;
      let settingsReturnTab = "systems";
      let settingsResumeMode = null;

      const ctx = dom.canvas.getContext("2d", { alpha: false });
      const stats = {
        hullText: document.querySelector("[data-stat='hull-text']"),
        shieldText: document.querySelector("[data-stat='shield-text']"),
        energyText: document.querySelector("[data-stat='energy-text']"),
        wave: document.querySelector("[data-stat='wave']"),
        tier: document.querySelector("[data-stat='tier']"),
        enemyCount: document.querySelector("[data-stat='enemy-count']"),
        score: document.querySelector("[data-stat='score']"),
        credits: document.querySelector("[data-stat='credits']"),
        rank: document.querySelector("[data-stat='rank']"),
        xp: document.querySelector("[data-stat='xp']"),
        techPoints: document.querySelector("[data-stat='tech-points']"),
        bestWave: document.querySelector("[data-stat='best-wave']"),
        totalKills: document.querySelector("[data-stat='total-kills']"),
        shipName: document.querySelector("[data-stat='ship-name']"),
        weaponName: document.querySelector("[data-stat='weapon-name']"),
        secondaryName: document.querySelector("[data-stat='secondary-name']"),
        abilityStatus: document.querySelector("[data-stat='ability-status']"),
        secondaryStatus: document.querySelector("[data-stat='secondary-status']"),
        sectorMod: document.querySelector("[data-stat='sector-mod']"),
        status: document.querySelector("[data-stat='status']"),
        modeLabel: document.querySelector("[data-stat='mode-label']"),
        sector: document.querySelector("[data-stat='sector']"),
        blueprints: document.querySelector("[data-stat='blueprints']"),
        bankedCredits: document.querySelector("[data-stat='banked-credits']"),
        bankedCreditsTotal: document.querySelector("[data-stat='banked-credits-total']"),
        salvageKeys: document.querySelector("[data-stat='salvage-keys']"),
        contractStatus: document.querySelector("[data-stat='contract-status']"),
        controlMode: document.querySelector("[data-stat='control-mode']"),
        damage: document.querySelector("[data-stat='damage']"),
        fireRate: document.querySelector("[data-stat='fire-rate']"),
        speed: document.querySelector("[data-stat='speed']"),
        shieldRegen: document.querySelector("[data-stat='shield-regen']"),
        energyRegen: document.querySelector("[data-stat='energy-regen']"),
        crit: document.querySelector("[data-stat='crit']")
      };
      const meters = {
        hull: document.querySelector("[data-meter='hull']"),
        shield: document.querySelector("[data-meter='shield']"),
        energy: document.querySelector("[data-meter='energy']")
      };
      const hudMeters = {
        hull: document.querySelector("[data-hud-meter='hull']"),
        shield: document.querySelector("[data-hud-meter='shield']"),
        energy: document.querySelector("[data-hud-meter='energy']")
      };
      const hudStats = {
        hull: document.querySelector("[data-hud-stat='hull']"),
        shield: document.querySelector("[data-hud-stat='shield']"),
        energy: document.querySelector("[data-hud-stat='energy']")
      };

      const input = {
        keys: new Set(),
        pointer: { x: 0, y: 0, screenX: 0, screenY: 0, active: false, moved: false },
        firing: false,
        boost: false,
        aimAngle: 0,
        aimSource: "mouse",
        aimMode: "hybrid",
        capture: null
      };

      const state = {
        mode: "hangar",
        gameMode: "arcade",
        wave: 1,
        score: 0,
        credits: 0,
        kills: 0,
        lastTime: 0,
        runStart: 0,
        waveStart: 0,
        width: 0,
        height: 0,
        sector: 1,
        sectorMod: null,
        contracts: [],
        training: false,
        resumeMode: "flight",
        runActive: false,
        runBanked: false,
        runLoadout: null,
        lastContractRender: 0,
        onboardingTimer: 0,
        onboardingSave: 0,
        difficulty: "normal",
        enemyAccuracyMod: 1,
        decoy: null,
        mines: [],
        skillSlots: [],
        lastHudUpdate: 0,
        activeUpgradeKey: "",
        lastHullHitAt: 0,
        upgradeStacks: {},
        upgradeOptions: [],
        upgradeRerolls: 0,
        worldWidth: WORLD_WIDTH,
        worldHeight: WORLD_HEIGHT,
        camera: { x: 0, y: 0 },
        frontier: null,
        lossRewards: null
      };

      const BASE_PLAYER = {
        maxHealth: 120,
        maxShield: 90,
        shieldRegen: 6,
        maxEnergy: 120,
        energyRegen: 24,
        energyCost: 16,
        damage: 12,
        fireRate: 4,
        bulletSpeed: 520,
        maxSpeed: 240,
        accel: 620,
        damping: 2.4,
        critChance: 0.06,
        critMultiplier: 1.6,
        projectiles: 1,
        spread: 0.14,
        splashRadius: 0,
        splashDamage: 0.6,
        pierce: 0,
        turnRate: 4.2,
        boostMultiplier: 1.35,
        boostCost: 20,
        damageReduction: 0,
        slowChance: 0,
        slowDuration: 0,
        salvageBonus: 0,
        xpBonus: 0,
        healOnKill: 0,
        energyOnKill: 0,
        barrageEvery: 0,
        barrageProjectiles: 0,
        barragePierce: 0,
        barrageBonusDamage: 1,
        barrageSplashRadius: 0,
        barrageSplashDamage: 0,
        barrageCounter: 0,
        upgradeLuck: 0,
        auraRadius: 0,
        auraDamage: 0,
        auraInterval: 0.45,
        auraTimer: 0,
        mineDropChance: 0,
        mineInterval: 1.2,
        mineTimer: 0,
        mineRadius: 0,
        mineDamage: 0,
        mineDuration: 5,
        helperCount: 0,
        helperDamageRatio: 0,
        helperFireRate: 0,
        helperRange: 0,
        helperOrbitRadius: 26,
        helperOrbitSpeed: 1.4,
        shockwaveInterval: 0,
        shockwaveTimer: 0,
        shockwaveRadius: 0,
        shockwaveDamage: 0,
        shockwaveSlow: 0,
        missileInterval: 0,
        missileTimer: 0,
        missileDamage: 0,
        missileCount: 0,
        missileSpeed: 0,
        aegisCooldown: 0,
        aegisReadyAt: 0,
        aegisShieldRestore: 0,
        aegisPulseRadius: 0,
        aegisPulseDamage: 0,
        aegisPulseSlow: 0,
        arcDamage: 0,
        arcRadius: 0,
        arcChains: 0,
        arcRequiresSlow: false,
        slowTimer: 0,
        slowFactor: 1
      };

      const DIFFICULTY_SETTINGS = {
        easy: { label: "Easy", enemyScale: 0.85, enemyDamage: 0.9, reward: 0.9 },
        normal: { label: "Normal", enemyScale: 1, enemyDamage: 1, reward: 1 },
        hard: { label: "Hard", enemyScale: 1.15, enemyDamage: 1.1, reward: 1.1 },
        adaptive: { label: "Adaptive", enemyScale: 1, enemyDamage: 1, reward: 1 }
      };

      const GAME_DB = window.STELLAR_DOGFIGHT_DB || {};
      const {
        TIER_META,
        TIER_ORDER,
        ABILITIES,
        SHIPS,
        WEAPONS,
        SECONDARIES,
        PART_RARITIES,
        PART_SLOTS,
        PART_TEMPLATES,
        FACTIONS,
        SECTOR_MODIFIERS,
        CONTRACT_DEFS,
        SALVAGE_CACHE,
        ELITE_MODS,
        HANGAR_UPGRADES,
        FRONTIER_STARTERS,
        FRONTIER_UPGRADES,
        FIELD_UPGRADES,
        ENEMY_TYPES,
        ACE_TYPE,
        BOSS_TYPE
      } = GAME_DB;

      let progress = loadProgress();
      syncProgressSelections();
      let player = null;
      let enemies = [];
      let bullets = [];
      let helpers = [];
      let particles = [];
      let pulses = [];
      let lootBursts = [];
      let damageNumbers = [];
      let stars = [];
      let obstacles = [];
      let backgroundGradient = null;
      let minimapCtx = null;

      window.STELLAR_DOGFIGHT_HELPERS = {
        logEvent,
        spawnPulse,
        wrapEntity,
        distanceBetween,
        rand,
        randInt,
        pick,
        pickWeighted,
        formatStat,
        getEnemies: () => enemies,
        generatePart: (rarity) => generatePart(rarity)
      };

      function init() {
        setupTabs();
        setupArmoryNav();
        setupCanvas();
        attachEvents();
        applySettingsFromProgress();
        checkProgressionUnlocks();
        setupWorld();
        player = createPlayer();
        renderHangar();
        renderShipyard();
        renderArmory();
        renderContracts();
        renderSettings();
        renderHistory();
        setOverlay("start");
        updateLayout();
        logEvent("Hangar systems online. Launch when ready.");
        state.lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function setupCanvas() {
        resizeCanvas();
        resizeMinimap();
        window.addEventListener("resize", () => {
          resizeCanvas();
          resizeMinimap();
          if (!input.pointer.active) {
            input.pointer.screenX = state.width * 0.5;
            input.pointer.screenY = state.height * 0.5;
            updatePointerWorld();
          }
        });
      }

      function resizeCanvas() {
        const rect = dom.canvas.getBoundingClientRect();
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        if (!rect.width || !rect.height) return;
        dom.canvas.width = Math.floor(rect.width * dpr);
        dom.canvas.height = Math.floor(rect.height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        state.width = rect.width;
        state.height = rect.height;
        backgroundGradient = ctx.createRadialGradient(
          state.width * 0.5,
          state.height * -0.2,
          120,
          state.width * 0.5,
          state.height * 0.4,
          state.width * 1.1
        );
        backgroundGradient.addColorStop(0, "rgba(68, 210, 194, 0.15)");
        backgroundGradient.addColorStop(0.45, "rgba(16, 28, 46, 0.9)");
        backgroundGradient.addColorStop(1, "rgba(5, 8, 14, 1)");
        updateStarfield();
      }

      function resizeMinimap() {
        if (!dom.minimap) return;
        const rect = dom.minimap.getBoundingClientRect();
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        if (!rect.width || !rect.height) return;
        dom.minimap.width = Math.floor(rect.width * dpr);
        dom.minimap.height = Math.floor(rect.height * dpr);
        if (!minimapCtx) {
          minimapCtx = dom.minimap.getContext("2d");
        }
        minimapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function attachEvents() {
        document.addEventListener("click", (event) => {
          const action = event.target.closest("[data-action]");
          if (!action) return;
          const actionName = action.dataset.action;
          if (actionName === "launch") startMission();
          if (actionName === "training") startTraining();
          if (actionName === "dock") toggleFrontierDock();
          if (actionName === "pause") togglePause();
          if (actionName === "reset") resetMission();
          if (actionName === "settings") openSettings();
          if (actionName === "settings-close") closeSettings();
        });

        if (dom.settingsOverlay) {
          dom.settingsOverlay.addEventListener("click", (event) => {
            if (event.target === dom.settingsOverlay) {
              closeSettings();
            }
          });
        }

        if (dom.tips) {
          dom.tips.addEventListener("click", (event) => {
            const card = event.target.closest("[data-tip-id]");
            if (card) {
              card.remove();
            }
          });
        }

        dom.overlay.addEventListener("click", (event) => {
          const overlayAction = event.target.closest("[data-overlay-action]");
          if (overlayAction) {
            const actionName = overlayAction.dataset.overlayAction;
            if (actionName === "launch") startMission();
            if (actionName === "resume") togglePause();
            if (actionName === "reset") resetMission();
            if (actionName === "reroll") rerollUpgrades();
            if (actionName === "skip") acceptUpgrade(null);
            if (actionName === "dock-close") closeFrontierDock();
            if (actionName === "dock") openFrontierDock();
            if (actionName === "tier-up") openFrontierTierSelect();
            return;
          }

          const upgradeButton = event.target.closest("[data-upgrade-id]");
          if (upgradeButton) {
            acceptUpgrade(upgradeButton.dataset.upgradeId);
            return;
          }

          const frontierUpgrade = event.target.closest("[data-frontier-upgrade]");
          if (frontierUpgrade) {
            purchaseFrontierUpgrade(frontierUpgrade.dataset.frontierUpgrade);
            return;
          }

          const frontierShip = event.target.closest("[data-frontier-ship]");
          if (frontierShip) {
            selectFrontierShip(frontierShip.dataset.frontierShip);
          }
        });

        dom.hangar.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("hangar")) {
            showTip("locked-hangar", "Hangar locked", getFeatureHint("hangar"));
            return;
          }
          const button = event.target.closest("[data-hangar-id]");
          if (!button) return;
          const upgrade = HANGAR_UPGRADES.find((item) => item.id === button.dataset.hangarId);
          if (!upgrade) return;
          const currentLevel = progress.hangar[upgrade.id] || 0;
          const maxLevel = upgrade.maxLevel || 1;
          const cost = getHangarUpgradeCost(upgrade, currentLevel);
          if (progress.techPoints < cost || currentLevel >= maxLevel) return;
          progress.techPoints = Math.max(0, progress.techPoints - cost);
          progress.hangar[upgrade.id] = currentLevel + 1;
          saveProgress();
          renderHangar();
          if (state.mode === "flight" || state.mode === "upgrade" || state.mode === "paused") {
            logEvent("Hangar upgrade installed for next sortie.");
          } else {
            player = createPlayer();
          }
        });

        dom.shipyard.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("shipyard")) {
            showTip("locked-shipyard", "Shipyard locked", getFeatureHint("shipyard"));
            return;
          }
          const button = event.target.closest("[data-ship-id]");
          if (!button) return;
          const ship = SHIPS.find((item) => item.id === button.dataset.shipId);
          if (!ship) return;
          const unlocked = !!progress.shipUnlocks[ship.id];
          if (!unlocked) {
            if (!unlockItem(ship, progress.shipUnlocks)) return;
            logEvent(`Ship unlocked: ${ship.name}.`);
          }
          if (progress.selectedShip !== ship.id) {
            progress.selectedShip = ship.id;
            applyLoadoutChange("Ship selection updated. Applies next sortie.");
          } else {
            saveProgress();
            renderShipyard();
          }
        });

        dom.weapons.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("armory")) {
            showTip("locked-armory", "Armory locked", getFeatureHint("armory"));
            return;
          }
          const button = event.target.closest("[data-weapon-id]");
          if (!button) return;
          const weapon = WEAPONS.find((item) => item.id === button.dataset.weaponId);
          if (!weapon) return;
          const unlocked = !!progress.weaponUnlocks[weapon.id];
          if (!unlocked) {
            if (!unlockItem(weapon, progress.weaponUnlocks)) return;
            logEvent(`Weapon unlocked: ${weapon.name}.`);
          }
          if (progress.selectedWeapon !== weapon.id) {
            progress.selectedWeapon = weapon.id;
            applyLoadoutChange("Weapon selection updated. Applies next sortie.");
          } else {
            saveProgress();
            renderArmory();
          }
        });

        dom.weaponUpgrades.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("weaponUpgrades")) {
            showTip("locked-weapon-upgrades", "Weapon upgrades locked", getFeatureHint("weaponUpgrades"));
            return;
          }
          const button = event.target.closest("[data-weapon-upgrade]");
          if (!button) return;
          const weapon = getWeaponById(progress.selectedWeapon);
          const index = Number(button.dataset.weaponUpgrade);
          const level = progress.weaponLevels[weapon.id] || 0;
          if (!weapon.upgrades || index !== level) return;
          const upgrade = weapon.upgrades[index];
          if (!upgrade || progress.bankedCredits < upgrade.cost) return;
          progress.bankedCredits -= upgrade.cost;
          progress.weaponLevels[weapon.id] = level + 1;
          applyLoadoutChange("Weapon upgrade installed. Applies next sortie.");
          logEvent(`Upgrade installed: ${upgrade.name}.`);
        });

        dom.secondaries.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("armory")) {
            showTip("locked-armory-secondary", "Secondary bay locked", getFeatureHint("armory"));
            return;
          }
          const button = event.target.closest("[data-secondary-id]");
          if (!button) return;
          const secondary = SECONDARIES.find((item) => item.id === button.dataset.secondaryId);
          if (!secondary) return;
          const unlocked = !!progress.secondaryUnlocks[secondary.id];
          if (!unlocked) {
            if (!unlockItem(secondary, progress.secondaryUnlocks)) return;
            logEvent(`Secondary unlocked: ${secondary.name}.`);
          }
          if (progress.selectedSecondary !== secondary.id) {
            progress.selectedSecondary = secondary.id;
            applyLoadoutChange("Secondary selection updated. Applies next sortie.");
          } else {
            saveProgress();
            renderArmory();
          }
        });

        dom.partsSlots.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("parts")) {
            showTip("locked-parts", "Parts bay locked", getFeatureHint("parts"));
            return;
          }
          const button = event.target.closest("[data-part-slot]");
          if (!button) return;
          const slot = button.dataset.partSlot;
          if (!progress.equippedParts[slot]) return;
          progress.equippedParts[slot] = null;
          applyLoadoutChange("Part unequipped. Applies next sortie.");
        });

        dom.partsInventory.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("parts")) {
            showTip("locked-parts-inventory", "Parts bay locked", getFeatureHint("parts"));
            return;
          }
          const button = event.target.closest("[data-part-id]");
          if (!button) return;
          const part = progress.partsInventory.find((item) => item.id === button.dataset.partId);
          if (!part) return;
          const partsMode = progress.settings.partsMode || "equip";
          if (partsMode === "dismantle") {
            dismantlePart(part.id);
            return;
          }
          const slot = part.slot;
          if (!slot) return;
          progress.equippedParts[slot] = part.id;
          applyLoadoutChange("Part equipped. Applies next sortie.");
        });

        dom.salvage.addEventListener("click", (event) => {
          if (!isFeatureUnlocked("salvage")) {
            showTip("locked-salvage", "Salvage cache locked", getFeatureHint("salvage"));
            return;
          }
          const button = event.target.closest("[data-salvage-action='open']");
          if (!button) return;
          openSalvageCache();
        });

        dom.keybinds.addEventListener("click", (event) => {
          const button = event.target.closest("[data-bind]");
          if (!button) return;
          input.capture = button.dataset.bind;
          renderKeybinds();
        });

        document.addEventListener("click", (event) => {
          const optionBtn = event.target.closest(".option-btn");
          if (!optionBtn) return;
          const group = optionBtn.closest("[data-setting]");
          if (!group) return;
          const setting = group.dataset.setting;
          const option = optionBtn.dataset.option;
          if (!option) return;
          if (setting === "difficulty") {
            progress.settings.difficulty = option;
          } else if (setting === "game-mode") {
            progress.settings.gameMode = option;
            if (state.runActive) {
              logEvent("Mode change applies on the next launch.");
            }
          } else if (setting === "shipyard-tier") {
            progress.settings.shipyardTier = option;
          } else if (setting === "parts-mode") {
            progress.settings.partsMode = option;
          } else if (setting === "input-mode") {
            progress.settings.inputMode = option;
          } else if (setting === "particles") {
            progress.settings.particles = option;
          } else if (setting === "hit-flash") {
            progress.settings.hitFlash = option === "on";
          }
          saveProgress();
          applySettingsFromProgress();
          renderSettings();
          renderShipyard();
          renderArmory();
          logEvent(`Settings updated: ${setting.replace("-", " ")}.`);
        });

        dom.canvas.addEventListener("pointermove", (event) => {
          const rect = dom.canvas.getBoundingClientRect();
          input.pointer.screenX = event.clientX - rect.left;
          input.pointer.screenY = event.clientY - rect.top;
          input.pointer.active = true;
          input.pointer.moved = true;
          updatePointerWorld();
        });

        dom.canvas.addEventListener("pointerdown", () => {
          input.firing = true;
        });

        window.addEventListener("pointerup", () => {
          input.firing = false;
        });

        window.addEventListener("keydown", (event) => {
          const key = normalizeKey(event);
          if (!key) return;
          if (key === "escape" && settingsOpen) {
            event.preventDefault();
            closeSettings();
            return;
          }
          if (input.capture) {
            event.preventDefault();
            if (key === "escape") {
              input.capture = null;
              renderKeybinds();
              return;
            }
            if (!isBindableKey(key)) {
              logEvent("Key not supported for binding.");
              return;
            }
            progress.keybinds[input.capture] = key;
            input.capture = null;
            saveProgress();
            renderSettings();
            logEvent("Keybind updated.");
            return;
          }
          if (key === "escape") {
            if (state.mode === "dock" || state.mode === "tier-select") {
              event.preventDefault();
              closeFrontierDock();
              return;
            }
            if (state.mode === "flight" || state.mode === "training" || state.mode === "paused") {
              event.preventDefault();
              togglePause();
            }
            return;
          }
          if (key === " " || key.startsWith("arrow")) {
            event.preventDefault();
          }
          if (key === (progress.keybinds.pause || "p")) {
            if (state.mode === "dock" || state.mode === "tier-select") {
              closeFrontierDock();
            } else {
              togglePause();
            }
            return;
          }
          if (key === "r") {
            resetMission();
            return;
          }
          if (!event.repeat) {
            if (key === progress.keybinds.ability) {
              activateAbility();
            }
            if (key === progress.keybinds.secondary) {
              activateSecondary();
            }
            if (key === progress.keybinds.dock) {
              toggleFrontierDock();
            }
          }
          input.keys.add(key);
        });

        window.addEventListener("keyup", (event) => {
          const key = normalizeKey(event);
          if (!key) return;
          input.keys.delete(key);
        });

        window.addEventListener("blur", () => {
          if (state.mode === "flight") {
            setPaused(true);
          }
        });

        document.addEventListener("visibilitychange", () => {
          if (document.hidden && state.mode === "flight") {
            setPaused(true);
          }
        });
      }

      function setupTabs() {
        const groups = document.querySelectorAll("[data-tab-group]");
        groups.forEach((group) => {
          const buttons = Array.from(group.querySelectorAll("[data-tab-target]"));
          const panels = Array.from(group.querySelectorAll("[data-tab-panel]"));
          if (!buttons.length || !panels.length) return;
          const defaultTarget = group.dataset.tabDefault || buttons[0].dataset.tabTarget;
          const missionGrid = document.querySelector(".mission-grid");
          const missionShell = document.querySelector(".mission-shell");

          const activate = (target, focusButton) => {
            buttons.forEach((button) => {
              const isActive = button.dataset.tabTarget === target;
              button.classList.toggle("is-active", isActive);
              button.setAttribute("aria-selected", isActive ? "true" : "false");
              button.tabIndex = isActive ? 0 : -1;
              if (isActive && focusButton) {
                button.focus();
              }
            });

            panels.forEach((panel) => {
              const isActive = panel.dataset.tabPanel === target;
              panel.classList.toggle("is-active", isActive);
              panel.hidden = !isActive;
            });

            if (group.dataset.tabGroup === "sidebar") {
              const isWide = target !== "systems" && target !== "upgrades";
              if (missionGrid) {
                missionGrid.classList.toggle("is-wide", isWide);
              }
              if (missionShell) {
                missionShell.classList.toggle("is-wide", isWide);
              }
            }
          };

          activate(defaultTarget, false);

          group.addEventListener("click", (event) => {
            const button = event.target.closest("[data-tab-target]");
            if (!button || !group.contains(button)) return;
            activate(button.dataset.tabTarget, true);
          });

          group.addEventListener("keydown", (event) => {
            const currentIndex = buttons.findIndex((button) => button.classList.contains("is-active"));
            if (currentIndex === -1) return;
            let nextIndex = currentIndex;
            if (event.key === "ArrowRight" || event.key === "ArrowDown") {
              nextIndex = (currentIndex + 1) % buttons.length;
            } else if (event.key === "ArrowLeft" || event.key === "ArrowUp") {
              nextIndex = (currentIndex - 1 + buttons.length) % buttons.length;
            } else if (event.key === "Home") {
              nextIndex = 0;
            } else if (event.key === "End") {
              nextIndex = buttons.length - 1;
            } else {
              return;
            }
            event.preventDefault();
            activate(buttons[nextIndex].dataset.tabTarget, true);
          });
        });
      }

      function getActiveTabTarget() {
        const activeButton = document.querySelector("[data-tab-group='sidebar'] [data-tab-target].is-active");
        return activeButton ? activeButton.dataset.tabTarget : "systems";
      }

      function selectTab(target) {
        const button = document.querySelector(`[data-tab-group='sidebar'] [data-tab-target="${target}"]`);
        if (button) {
          button.click();
        }
      }

      function isPlayingMode(mode) {
        return ["flight", "training", "paused", "upgrade", "dock", "tier-select", "gameover"].includes(mode);
      }

      function updateLayout() {
        const playing = isPlayingMode(state.mode);
        document.body.classList.toggle("is-playing", playing);
        document.body.classList.toggle("is-hangar", !playing);
        resizeCanvas();
        resizeMinimap();
      }

      function openSettings() {
        if (settingsOpen) return;
        settingsOpen = true;
        settingsReturnTab = getActiveTabTarget();
        settingsResumeMode = state.mode;
        if (state.mode === "flight" || state.mode === "training") {
          setPaused(true);
        }
        if (settingsPanel && dom.settingsBody) {
          selectTab("settings");
          settingsPanel.hidden = false;
          settingsPanel.classList.add("is-active");
          dom.settingsBody.appendChild(settingsPanel);
        }
        if (dom.settingsOverlay) {
          dom.settingsOverlay.hidden = false;
        }
        updateLayout();
        renderSettings();
      }

      function closeSettings(shouldResume = true) {
        if (!settingsOpen) return;
        settingsOpen = false;
        if (settingsPanel && settingsHome) {
          if (settingsAnchor && settingsAnchor.parentElement === settingsHome) {
            settingsHome.insertBefore(settingsPanel, settingsAnchor);
          } else {
            settingsHome.appendChild(settingsPanel);
          }
        }
        if (settingsReturnTab) {
          selectTab(settingsReturnTab);
        }
        if (dom.settingsOverlay) {
          dom.settingsOverlay.hidden = true;
        }
        if (shouldResume && (settingsResumeMode === "flight" || settingsResumeMode === "training")) {
          setPaused(false);
        }
        updateLayout();
      }

      function setupArmoryNav() {
        const nav = document.querySelector("[data-armory-nav]");
        if (!nav) return;
        const buttons = Array.from(nav.querySelectorAll("[data-armory-target]"));
        const sections = Array.from(document.querySelectorAll("[data-armory-section]"));
        if (!buttons.length || !sections.length) return;

        const activate = (target, shouldSave) => {
          let nextTarget = target;
          if (!buttons.some((button) => button.dataset.armoryTarget === nextTarget)) {
            nextTarget = buttons[0].dataset.armoryTarget;
          }
          buttons.forEach((button) => {
            button.classList.toggle("is-active", button.dataset.armoryTarget === nextTarget);
          });
          sections.forEach((section) => {
            const isActive = section.dataset.armorySection === nextTarget;
            section.hidden = !isActive;
          });
          if (shouldSave) {
            progress.settings.armorySection = nextTarget;
            saveProgress();
          }
        };

        const storedTarget = progress.settings.armorySection || buttons[0].dataset.armoryTarget;
        activate(storedTarget, false);

        nav.addEventListener("click", (event) => {
          const button = event.target.closest("[data-armory-target]");
          if (!button) return;
          activate(button.dataset.armoryTarget, true);
        });
      }

      function loadProgress() {
        const fallback = {
          rank: 1,
          xp: 0,
          techPoints: 0,
          bestWave: 1,
          totalKills: 0,
          bankedCredits: 0,
          blueprints: 0,
          salvageKeys: 0,
          salvagePity: 0,
          salvageHistory: [],
          featureUnlocks: {
            upgrades: false,
            ability: false,
            secondary: false,
            hangar: false,
            armory: false,
            weaponUpgrades: false,
            parts: false,
            shipyard: false,
            contracts: false,
            salvage: false
          },
          onboarding: {
            flightSeconds: 0
          },
          tipsSeen: {},
          selectedShip: "vanguard",
          selectedWeapon: "pulse",
          selectedSecondary: "emp",
          shipUnlocks: { vanguard: true, scout: true },
          weaponUnlocks: { pulse: true, repeater: true },
          secondaryUnlocks: { emp: true },
          weaponLevels: {},
          partsInventory: [],
          equippedParts: {
            barrel: null,
            core: null,
            targeting: null,
            thruster: null
          },
          factions: {
            nova: 0,
            aegis: 0,
            vortex: 0
          },
          settings: {
            difficulty: "normal",
            gameMode: "arcade",
            inputMode: "hybrid",
            particles: "medium",
            hitFlash: true,
            armorySection: "weapons",
            partsMode: "equip",
            shipyardTier: "all"
          },
          keybinds: {
            forward: "w",
            back: "s",
            left: "a",
            right: "d",
            aimUp: "arrowup",
            aimDown: "arrowdown",
            aimLeft: "arrowleft",
            aimRight: "arrowright",
            fire: " ",
            boost: "shift",
            ability: "e",
            secondary: "q",
            dock: "u",
            pause: "p"
          },
          runHistory: [],
          hangar: {
            hull: 0,
            shield: 0,
            "shield-regenerator": 0,
            "damage-dampers": 0,
            "reactive-repair": 0,
            "aegis-relay": 0,
            "weapon-calibration": 0,
            "fire-control": 0,
            targeting: 0,
            "munitions-loader": 0,
            "amplifier-core": 0,
            "barrage-sync": 0,
            thrusters: 0,
            "attitude-control": 0,
            "inertial-dampers": 0,
            "boost-couplers": 0,
            reactor: 0,
            "capacitor-banks": 0,
            "efficiency-tuning": 0,
            "salvage-magnet": 0,
            "tactical-scanner": 0,
            "upgrade-forecast": 0,
            "energy-siphon": 0
          }
        };
        try {
          const stored = JSON.parse(localStorage.getItem(STORAGE_KEY));
          if (!stored) return fallback;
          const merged = {
            ...fallback,
            ...stored,
            hangar: {
              ...fallback.hangar,
              ...(stored.hangar || {})
            },
            shipUnlocks: {
              ...fallback.shipUnlocks,
              ...(stored.shipUnlocks || {})
            },
            weaponUnlocks: {
              ...fallback.weaponUnlocks,
              ...(stored.weaponUnlocks || {})
            },
            secondaryUnlocks: {
              ...fallback.secondaryUnlocks,
              ...(stored.secondaryUnlocks || {})
            },
            weaponLevels: {
              ...fallback.weaponLevels,
              ...(stored.weaponLevels || {})
            },
            equippedParts: {
              ...fallback.equippedParts,
              ...(stored.equippedParts || {})
            },
            factions: {
              ...fallback.factions,
              ...(stored.factions || {})
            },
            settings: {
              ...fallback.settings,
              ...(stored.settings || {})
            },
            keybinds: {
              ...fallback.keybinds,
              ...(stored.keybinds || {})
            },
            runHistory: Array.isArray(stored.runHistory) ? stored.runHistory.slice(0, 8) : fallback.runHistory,
            salvageHistory: Array.isArray(stored.salvageHistory) ? stored.salvageHistory.slice(0, 6) : fallback.salvageHistory,
            featureUnlocks: {
              ...fallback.featureUnlocks,
              ...(stored.featureUnlocks || {})
            },
            onboarding: {
              ...fallback.onboarding,
              ...(stored.onboarding || {})
            },
            tipsSeen: {
              ...fallback.tipsSeen,
              ...(stored.tipsSeen || {})
            }
          };
          const legacyAim = {
            aimUp: "i",
            aimDown: "k",
            aimLeft: "j",
            aimRight: "l"
          };
          const hasLegacyAim = stored.keybinds && Object.keys(legacyAim)
            .every((key) => stored.keybinds[key] === legacyAim[key]);
          if (hasLegacyAim) {
            merged.keybinds = {
              ...merged.keybinds,
              aimUp: "arrowup",
              aimDown: "arrowdown",
              aimLeft: "arrowleft",
              aimRight: "arrowright"
            };
          }
          return merged;
        } catch (error) {
          return fallback;
        }
      }

      function saveProgress() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
        } catch (error) {
          // Storage can be unavailable in some browser modes.
        }
      }

      function syncProgressSelections() {
        const shipIds = SHIPS.map((ship) => ship.id);
        if (!shipIds.includes(progress.selectedShip)) {
          progress.selectedShip = SHIPS[0].id;
        }
        if (!progress.shipUnlocks[progress.selectedShip]) {
          const unlockedShip = SHIPS.find((ship) => progress.shipUnlocks[ship.id]);
          progress.selectedShip = unlockedShip ? unlockedShip.id : SHIPS[0].id;
          progress.shipUnlocks[progress.selectedShip] = true;
        }

        const weaponIds = WEAPONS.map((weapon) => weapon.id);
        if (!weaponIds.includes(progress.selectedWeapon)) {
          progress.selectedWeapon = WEAPONS[0].id;
        }
        if (!progress.weaponUnlocks[progress.selectedWeapon]) {
          const unlockedWeapon = WEAPONS.find((weapon) => progress.weaponUnlocks[weapon.id]);
          progress.selectedWeapon = unlockedWeapon ? unlockedWeapon.id : WEAPONS[0].id;
          progress.weaponUnlocks[progress.selectedWeapon] = true;
        }

        const secondaryIds = SECONDARIES.map((secondary) => secondary.id);
        if (!secondaryIds.includes(progress.selectedSecondary)) {
          progress.selectedSecondary = SECONDARIES[0].id;
        }
        if (!progress.secondaryUnlocks[progress.selectedSecondary]) {
          const unlockedSecondary = SECONDARIES.find((secondary) => progress.secondaryUnlocks[secondary.id]);
          progress.selectedSecondary = unlockedSecondary ? unlockedSecondary.id : SECONDARIES[0].id;
          progress.secondaryUnlocks[progress.selectedSecondary] = true;
        }

        PART_SLOTS.forEach((slot) => {
          const equippedId = progress.equippedParts[slot];
          if (!equippedId) return;
          const hasPart = progress.partsInventory.some((part) => part.id === equippedId);
          if (!hasPart) {
            progress.equippedParts[slot] = null;
          }
        });
      }

      function applySettingsFromProgress() {
        state.difficulty = progress.settings.difficulty || "normal";
        if (!state.runActive || state.mode === "hangar" || state.mode === "gameover") {
          state.gameMode = progress.settings.gameMode || "arcade";
        }
        input.aimMode = progress.settings.inputMode || "hybrid";
        if (input.aimMode === "keyboard") {
          input.aimSource = "keyboard";
        } else {
          input.aimSource = "mouse";
        }
        updateParticleSettings();
      }

      function isFeatureUnlocked(feature) {
        return !!(progress.featureUnlocks && progress.featureUnlocks[feature]);
      }

      function getFeatureHint(feature) {
        const hints = {
          upgrades: "Unlocks after your first wave clear.",
          ability: "Unlocks after a few waves of combat.",
          secondary: "Unlocks after mastering abilities.",
          hangar: "Unlocks at Rank 2.",
          armory: "Unlocks at Rank 3.",
          weaponUpgrades: "Unlocks at Rank 4.",
          parts: "Unlocks after earning parts or Rank 4.",
          shipyard: "Unlocks at Rank 4.",
          contracts: "Unlocks after reaching Wave 3.",
          salvage: "Unlocks after recovering salvage keys."
        };
        return hints[feature] || "Unlocks later in the campaign.";
      }

      function getFeatureTip(feature) {
        const abilityKey = formatKeybind(progress.keybinds.ability);
        const secondaryKey = formatKeybind(progress.keybinds.secondary);
        const tips = {
          upgrades: {
            title: "Field upgrades unlocked",
            message: "After each wave, choose a permanent upgrade for the run."
          },
          ability: {
            title: "Ability systems online",
            message: `Activate your ship ability with ${abilityKey}.`
          },
          secondary: {
            title: "Secondary system unlocked",
            message: `Deploy secondary gear with ${secondaryKey}.`
          },
          hangar: {
            title: "Hangar upgrades online",
            message: "Spend tech points in the Upgrades tab between runs."
          },
          armory: {
            title: "Armory unlocked",
            message: "Swap weapons and secondaries in the Armory tab."
          },
          weaponUpgrades: {
            title: "Weapon upgrades unlocked",
            message: "Spend banked credits to enhance your primary weapon."
          },
          parts: {
            title: "Parts bay unlocked",
            message: "Equip recovered parts in the Armory > Parts section."
          },
          shipyard: {
            title: "Shipyard unlocked",
            message: "Unlock new ships and abilities in the Shipyard tab."
          },
          contracts: {
            title: "Contracts unlocked",
            message: "Pick bonus objectives in the Contracts tab for extra rewards."
          },
          salvage: {
            title: "Salvage cache unlocked",
            message: "Open caches in the Armory using salvage keys."
          }
        };
        return tips[feature] || null;
      }

      function showTip(id, title, message) {
        if (!dom.tips || !title || !message) return;
        progress.tipsSeen = progress.tipsSeen || {};
        if (progress.tipsSeen[id]) return;
        progress.tipsSeen[id] = true;
        saveProgress();
        const card = document.createElement("div");
        card.className = "tip-card";
        card.dataset.tipId = id;
        card.innerHTML = `<strong>${title}</strong><span>${message}</span>`;
        dom.tips.prepend(card);
        while (dom.tips.children.length > 3) {
          dom.tips.removeChild(dom.tips.lastChild);
        }
        setTimeout(() => {
          if (card.parentElement) {
            card.remove();
          }
        }, 9000);
      }

      function unlockFeature(feature) {
        progress.featureUnlocks = progress.featureUnlocks || {};
        if (isFeatureUnlocked(feature)) return false;
        progress.featureUnlocks[feature] = true;
        const tip = getFeatureTip(feature);
        if (tip) {
          showTip(`unlock-${feature}`, tip.title, tip.message);
          logEvent(tip.title);
        }
        saveProgress();
        renderHangar();
        renderShipyard();
        renderArmory();
        renderContracts();
        renderSettings();
        return true;
      }

      function checkProgressionUnlocks() {
        const flightSeconds = progress.onboarding?.flightSeconds || 0;
        const waveProgress = Math.max(progress.bestWave || 1, state.wave || 1);

        if (!isFeatureUnlocked("upgrades") && (flightSeconds >= 45 || waveProgress >= 2)) {
          unlockFeature("upgrades");
        }
        if (isFeatureUnlocked("upgrades") && !isFeatureUnlocked("ability")
          && (flightSeconds >= 90 || waveProgress >= 3 || progress.rank >= 2)) {
          unlockFeature("ability");
        }
        if (isFeatureUnlocked("ability") && !isFeatureUnlocked("secondary")
          && (flightSeconds >= 140 || waveProgress >= 4 || progress.rank >= 3)) {
          unlockFeature("secondary");
        }
        if (!isFeatureUnlocked("hangar") && progress.rank >= 2) {
          unlockFeature("hangar");
        }
        if (isFeatureUnlocked("hangar") && !isFeatureUnlocked("armory") && progress.rank >= 3) {
          unlockFeature("armory");
        }
        if (isFeatureUnlocked("armory") && !isFeatureUnlocked("weaponUpgrades") && progress.rank >= 4) {
          unlockFeature("weaponUpgrades");
        }
        if (isFeatureUnlocked("armory") && !isFeatureUnlocked("parts")
          && (progress.rank >= 4 || (progress.partsInventory || []).length > 0)) {
          unlockFeature("parts");
        }
        if (!isFeatureUnlocked("shipyard") && (progress.rank >= 4 || progress.blueprints >= 1)) {
          unlockFeature("shipyard");
        }
        if (!isFeatureUnlocked("contracts") && (progress.bestWave >= 3 || progress.runHistory.length > 0)) {
          unlockFeature("contracts");
        }
        if (isFeatureUnlocked("armory") && !isFeatureUnlocked("salvage")
          && ((progress.salvageKeys || 0) >= 1 || progress.totalKills >= 12)) {
          unlockFeature("salvage");
        }
      }

      function updateParticleSettings() {
        if (!state.width || !state.height) return;
        updateStarfield();
      }

      function getParticleScale() {
        const setting = progress.settings.particles || "medium";
        if (setting === "low") return 0.6;
        if (setting === "high") return 1.4;
        return 1;
      }

      function getParticleCount(base) {
        return Math.max(1, Math.round(base * getParticleScale()));
      }

      function getShipById(id) {
        return SHIPS.find((ship) => ship.id === id) || SHIPS[0];
      }

      function getWeaponById(id) {
        return WEAPONS.find((weapon) => weapon.id === id) || WEAPONS[0];
      }

      function getSecondaryById(id) {
        return SECONDARIES.find((secondary) => secondary.id === id) || SECONDARIES[0];
      }

      function applyMods(stats, mods) {
        if (!mods) return;
        const add = mods.add || {};
        const mult = mods.mult || {};
        Object.keys(add).forEach((key) => {
          stats[key] = (stats[key] || 0) + add[key];
        });
        Object.keys(mult).forEach((key) => {
          stats[key] = (stats[key] || 0) * mult[key];
        });
      }

      function getEquippedParts() {
        return PART_SLOTS.map((slot) => {
          const id = progress.equippedParts[slot];
          return progress.partsInventory.find((part) => part.id === id) || null;
        }).filter(Boolean);
      }

      function applyPartStats(stats, part) {
        if (!part || !part.stats) return;
        Object.keys(part.stats).forEach((key) => {
          stats[key] = (stats[key] || 0) + part.stats[key];
        });
      }

      function applyWeaponUpgrades(stats, weapon) {
        const level = progress.weaponLevels[weapon.id] || 0;
        const upgrades = weapon.upgrades || [];
        upgrades.slice(0, level).forEach((upgrade) => {
          if (upgrade.apply) upgrade.apply(stats);
        });
      }

      function applyFrontierUpgrades(stats, upgrades) {
        if (!upgrades) return;
        FRONTIER_UPGRADES.forEach((upgrade) => {
          const level = upgrades[upgrade.id] || 0;
          for (let i = 0; i < level; i += 1) {
            if (upgrade.apply) upgrade.apply(stats, i + 1);
          }
        });
      }

      function buildBaseStats(loadout = {}) {
        const stats = { ...BASE_PLAYER };
        const ship = getShipById(loadout.shipId || progress.selectedShip);
        const weapon = getWeaponById(loadout.weaponId || progress.selectedWeapon);
        const secondary = getSecondaryById(loadout.secondaryId || progress.selectedSecondary);
        applyMods(stats, ship.mods);
        Object.assign(stats, weapon.stats);
        applyWeaponUpgrades(stats, weapon);
        HANGAR_UPGRADES.forEach((upgrade) => {
          const level = progress.hangar[upgrade.id] || 0;
          upgrade.apply(stats, level);
        });
        getEquippedParts().forEach((part) => applyPartStats(stats, part));
        stats.ship = ship;
        stats.weapon = weapon;
        stats.secondary = secondary;
        return stats;
      }

      function createPlayer(loadout = {}) {
        const base = buildBaseStats(loadout);
        if (state.gameMode === "frontier" && state.frontier && state.frontier.active) {
          applyFrontierUpgrades(base, state.frontier.upgrades);
        }
        const ability = ABILITIES[base.ship.abilityId];
        const spawn = getSpawnPoint();
        return {
          ...base,
          ability,
          x: spawn.x,
          y: spawn.y,
          vx: 0,
          vy: 0,
          angle: 0,
          health: base.maxHealth,
          shield: base.maxShield,
          energy: base.maxEnergy,
          radius: 14,
          shieldCooldown: 0,
          fireCooldown: 0,
          hitFlash: 0,
          abilityTimer: 0,
          abilityCooldown: 0,
          secondaryCooldown: 0,
          invulnerable: 0
        };
      }

      function createStars(count) {
        const width = state.worldWidth || state.width;
        const height = state.worldHeight || state.height;
        return Array.from({ length: count }, () => ({
          x: Math.random() * width,
          y: Math.random() * height,
          radius: rand(0.6, 1.6),
          speed: rand(6, 26),
          alpha: rand(0.3, 0.9)
        }));
      }

      function updateStarfield() {
        stars = createStars(getStarCount());
      }

      function getStarCount() {
        const base = getParticleCount(160);
        const viewArea = state.width * state.height;
        const worldArea = state.worldWidth * state.worldHeight;
        if (!viewArea || !worldArea) return base;
        const density = clamp(worldArea / viewArea, 1, 4);
        return Math.round(base * density);
      }

      function setupWorld() {
        state.worldWidth = WORLD_WIDTH;
        state.worldHeight = WORLD_HEIGHT;
        obstacles = generateObstacles();
        updateStarfield();
        updateCamera();
        updatePointerWorld();
      }

      function generateObstacles() {
        const width = state.worldWidth;
        const height = state.worldHeight;
        const padding = 160;
        const safeRadius = 200;
        const obstacles = [];
        const rockSeeds = [
          { x: width * 0.28, y: height * 0.3 },
          { x: width * 0.7, y: height * 0.3 },
          { x: width * 0.32, y: height * 0.7 },
          { x: width * 0.68, y: height * 0.66 }
        ];
        rockSeeds.forEach((seed) => {
          const radius = rand(110, 170);
          const x = clamp(seed.x + rand(-130, 130), radius + padding, width - radius - padding);
          const y = clamp(seed.y + rand(-120, 120), radius + padding, height - radius - padding);
          obstacles.push({
            kind: "rock",
            x,
            y,
            radius,
            shade: rand(0.3, 0.7)
          });
        });
        const debrisSeeds = [
          { x: width * 0.5, y: height * 0.18, width: 520, height: 90 },
          { x: width * 0.5, y: height * 0.82, width: 520, height: 90 },
          { x: width * 0.18, y: height * 0.5, width: 90, height: 420 },
          { x: width * 0.82, y: height * 0.5, width: 90, height: 420 }
        ];
        debrisSeeds.forEach((seed) => {
          const x = clamp(seed.x + rand(-90, 90), seed.width / 2 + padding, width - seed.width / 2 - padding);
          const y = clamp(seed.y + rand(-90, 90), seed.height / 2 + padding, height - seed.height / 2 - padding);
          obstacles.push({
            kind: "debris",
            x,
            y,
            width: seed.width,
            height: seed.height,
            shade: rand(0.2, 0.6)
          });
        });
        for (let i = 0; i < 6; i += 1) {
          const radius = rand(60, 100);
          const x = rand(radius + padding, width - radius - padding);
          const y = rand(radius + padding, height - radius - padding);
          obstacles.push({
            kind: "rock",
            x,
            y,
            radius,
            shade: rand(0.25, 0.55)
          });
        }
        return obstacles.filter((obstacle) => !isObstacleNearPoint(obstacle, width * 0.5, height * 0.5, safeRadius));
      }

      function isObstacleNearPoint(obstacle, x, y, buffer) {
        if (!obstacle) return false;
        if (obstacle.kind === "rock") {
          return distanceBetween(obstacle, { x, y }) <= obstacle.radius + buffer;
        }
        const halfWidth = obstacle.width * 0.5;
        const halfHeight = obstacle.height * 0.5;
        const closestX = clamp(x, obstacle.x - halfWidth, obstacle.x + halfWidth);
        const closestY = clamp(y, obstacle.y - halfHeight, obstacle.y + halfHeight);
        return Math.hypot(x - closestX, y - closestY) <= buffer;
      }

      function getSpawnPoint() {
        const center = { x: state.worldWidth * 0.5, y: state.worldHeight * 0.5 };
        if (!isPointInObstacle(center, 140)) return center;
        for (let i = 0; i < 12; i += 1) {
          const angle = rand(0, Math.PI * 2);
          const distance = rand(140, 320);
          const candidate = {
            x: clamp(center.x + Math.cos(angle) * distance, 80, state.worldWidth - 80),
            y: clamp(center.y + Math.sin(angle) * distance, 80, state.worldHeight - 80)
          };
          if (!isPointInObstacle(candidate, 140)) {
            return candidate;
          }
        }
        return center;
      }

      function isPointInObstacle(point, buffer = 0) {
        return obstacles.some((obstacle) => {
          if (obstacle.kind === "rock") {
            return distanceBetween(point, obstacle) <= obstacle.radius + buffer;
          }
          const halfWidth = obstacle.width * 0.5;
          const halfHeight = obstacle.height * 0.5;
          const insideX = point.x >= obstacle.x - halfWidth - buffer && point.x <= obstacle.x + halfWidth + buffer;
          const insideY = point.y >= obstacle.y - halfHeight - buffer && point.y <= obstacle.y + halfHeight + buffer;
          return insideX && insideY;
        });
      }

      function getViewportBounds() {
        const left = state.camera.x;
        const top = state.camera.y;
        return {
          left,
          top,
          right: left + state.width,
          bottom: top + state.height
        };
      }

      function updateCamera() {
        if (!player) return;
        const maxX = Math.max(0, state.worldWidth - state.width);
        const maxY = Math.max(0, state.worldHeight - state.height);
        state.camera.x = clamp(player.x - state.width * 0.5, 0, maxX);
        state.camera.y = clamp(player.y - state.height * 0.5, 0, maxY);
      }

      function screenToWorld(x, y) {
        return {
          x: clamp(x + state.camera.x, 0, state.worldWidth),
          y: clamp(y + state.camera.y, 0, state.worldHeight)
        };
      }

      function updatePointerWorld() {
        if (!input.pointer.active || !player) {
          input.pointer.x = player ? player.x : state.worldWidth * 0.5;
          input.pointer.y = player ? player.y : state.worldHeight * 0.5;
          return;
        }
        const world = screenToWorld(input.pointer.screenX, input.pointer.screenY);
        input.pointer.x = world.x;
        input.pointer.y = world.y;
      }

      function rollSectorModifier() {
        return pick(SECTOR_MODIFIERS);
      }

      function updateSector() {
        const nextSector = Math.max(1, Math.ceil(state.wave / 3));
        if (nextSector !== state.sector) {
          state.sector = nextSector;
          state.sectorMod = rollSectorModifier();
          if (state.sectorMod) {
            logEvent(`Sector ${state.sector.toString().padStart(2, "0")} anomaly: ${state.sectorMod.name}.`);
          }
        }
      }

      function rollContracts() {
        if (state.training || !isFeatureUnlocked("contracts")) return [];
        const pool = shuffle([...CONTRACT_DEFS]);
        const count = 2 + Math.round(Math.random());
        return pool.slice(0, count).map((contract) => ({
          ...contract,
          progress: 0,
          complete: false,
          factionId: pick(FACTIONS).id
        }));
      }

      function getDifficultySettings() {
        const base = DIFFICULTY_SETTINGS[state.difficulty] || DIFFICULTY_SETTINGS.normal;
        if (state.difficulty !== "adaptive" || !player) {
          return base;
        }
        const healthRatio = player.health / player.maxHealth;
        const performance = clamp((healthRatio - 0.5) * 0.4, -0.1, 0.15);
        return {
          ...base,
          enemyScale: base.enemyScale + performance,
          enemyDamage: base.enemyDamage + performance * 0.6,
          reward: base.reward + performance * 0.3
        };
      }

      function startMission() {
        if (state.mode !== "hangar" && state.mode !== "gameover") return;
        applySettingsFromProgress();
        input.keys.clear();
        input.firing = false;
        checkProgressionUnlocks();
        enemies = [];
        bullets = [];
        helpers = [];
        particles = [];
        lootBursts = [];
        damageNumbers = [];
        state.mines = [];
        state.decoy = null;
        state.enemyAccuracyMod = 1;
        state.upgradeStacks = {};
        state.upgradeOptions = [];
        state.upgradeRerolls = 0;
        state.skillSlots = [];
        state.lossRewards = null;
        state.wave = 1;
        state.score = 0;
        state.credits = 0;
        state.kills = 0;
        state.sector = 1;
        state.sectorMod = rollSectorModifier();
        state.training = false;
        state.resumeMode = "flight";
        state.runActive = true;
        state.runBanked = false;
        state.lastContractRender = 0;
        state.contracts = rollContracts();
        state.runStart = performance.now();
        state.waveStart = performance.now();
        setupWorld();
        if (isFrontierMode()) {
          initFrontierRun();
        } else {
          state.frontier = null;
          player = createPlayer();
        }
        updateCamera();
        updatePointerWorld();
        state.runLoadout = { ship: player.ship?.name || "Unknown", weapon: player.weapon?.name || "Unknown" };
        spawnWave(state.wave);
        hideOverlay();
        setMode("flight");
        if (state.sectorMod) {
          logEvent(`Sector 01 anomaly: ${state.sectorMod.name}.`);
        }
        logEvent(isFrontierMode() ? "Frontier patrol launched. Upgrade at the dock." : "Wave 1 launched. Stay mobile.");
        renderContracts();
      }

      function startTraining() {
        if (state.mode !== "hangar" && state.mode !== "gameover") return;
        applySettingsFromProgress();
        state.gameMode = "arcade";
        input.keys.clear();
        input.firing = false;
        checkProgressionUnlocks();
        state.frontier = null;
        enemies = [];
        bullets = [];
        helpers = [];
        particles = [];
        lootBursts = [];
        damageNumbers = [];
        state.mines = [];
        state.decoy = null;
        state.enemyAccuracyMod = 1;
        state.upgradeStacks = {};
        state.upgradeOptions = [];
        state.upgradeRerolls = 0;
        state.skillSlots = [];
        state.lossRewards = null;
        state.wave = 1;
        state.score = 0;
        state.credits = 0;
        state.kills = 0;
        state.sector = 1;
        state.sectorMod = rollSectorModifier();
        state.training = true;
        state.resumeMode = "training";
        state.runActive = true;
        state.runBanked = false;
        state.runLoadout = { ship: player.ship?.name || "Unknown", weapon: player.weapon?.name || "Unknown" };
        state.contracts = [];
        state.runStart = performance.now();
        state.waveStart = performance.now();
        state.lastContractRender = 0;
        setupWorld();
        player = createPlayer();
        updateCamera();
        updatePointerWorld();
        spawnWave(state.wave);
        hideOverlay();
        setMode("training");
        if (state.sectorMod) {
          logEvent(`Training sector: ${state.sectorMod.name}.`);
        }
        logEvent("Training session initiated. No rewards earned.");
        renderContracts();
      }

      function resetMission() {
        if (state.mode !== "hangar") {
          endRun("abort");
        }
        setMode("hangar");
        enemies = [];
        bullets = [];
        helpers = [];
        particles = [];
        lootBursts = [];
        damageNumbers = [];
        state.mines = [];
        state.decoy = null;
        state.enemyAccuracyMod = 1;
        state.upgradeStacks = {};
        state.upgradeOptions = [];
        state.upgradeRerolls = 0;
        state.skillSlots = [];
        state.lossRewards = null;
        state.wave = 1;
        state.score = 0;
        state.credits = 0;
        state.kills = 0;
        state.contracts = [];
        state.sector = 1;
        state.sectorMod = null;
        state.training = false;
        state.runActive = false;
        state.runBanked = false;
        state.runLoadout = null;
        state.lastContractRender = 0;
        state.frontier = null;
        input.keys.clear();
        input.firing = false;
        setupWorld();
        player = createPlayer();
        setOverlay("start");
        renderContracts();
        renderShipyard();
        renderArmory();
        renderHistory();
        logEvent("Run reset. Hangar ready.");
      }

      function setMode(mode) {
        state.mode = mode;
        if (mode === "hangar" && settingsOpen) {
          closeSettings(false);
        }
        const labels = {
          hangar: "Hangar",
          flight: "In Flight",
          upgrade: "Upgrade Bay",
          dock: "Docked",
          "tier-select": "Tier Uplink",
          paused: "Paused",
          gameover: "Wrecked",
          training: "Training"
        };
        stats.status.textContent = labels[mode] || "Hangar";
        updateLayout();
      }

      function togglePause() {
        if (state.mode === "dock" || state.mode === "tier-select") {
          closeFrontierDock();
        } else if (state.mode === "flight" || state.mode === "training") {
          setPaused(true);
        } else if (state.mode === "paused") {
          setPaused(false);
        }
      }

      function setPaused(shouldPause) {
        if (shouldPause) {
          state.resumeMode = state.mode === "paused" ? state.resumeMode : state.mode;
          setMode("paused");
          setOverlay("paused");
        } else {
          setMode(state.resumeMode === "training" ? "training" : "flight");
          hideOverlay();
        }
      }

      function isFrontierMode() {
        return state.gameMode === "frontier";
      }

      function getFrontierStarterId() {
        const starters = (FRONTIER_STARTERS || []).filter((id) => progress.shipUnlocks[id]);
        if (progress.selectedShip && starters.includes(progress.selectedShip)) {
          return progress.selectedShip;
        }
        if (starters.length) return starters[0];
        return (FRONTIER_STARTERS && FRONTIER_STARTERS[0]) || progress.selectedShip;
      }

      function initFrontierRun() {
        const starterId = getFrontierStarterId();
        const starterShip = getShipById(starterId);
        const weaponId = starterShip.signatureWeapon || progress.selectedWeapon;
        state.frontier = {
          active: true,
          tier: starterShip.tier || 1,
          shipId: starterShip.id,
          weaponId,
          upgrades: {},
          spawnTimer: 0
        };
        player = createPlayer({ shipId: starterShip.id, weaponId });
      }

      function getFrontierUpgradeCost(upgrade, level, tier) {
        const tierScale = 1 + Math.max(0, tier - 1) * 0.35;
        const levelScale = 1 + level * 0.6;
        return Math.round((upgrade.baseCost || 100) * tierScale * levelScale);
      }

      function getFrontierTierCost(tier) {
        return Math.round(280 * Math.pow(Math.max(1, tier), 1.35));
      }

      function getHangarUpgradeCost(upgrade, level) {
        const baseCost = Number.isFinite(upgrade.baseCost) ? upgrade.baseCost : 1;
        const scale = Number.isFinite(upgrade.costScale) ? upgrade.costScale : 1.2;
        return Math.max(1, Math.ceil(baseCost * Math.pow(scale, level)));
      }

      function getFrontierNextShips() {
        if (!state.frontier || !state.frontier.shipId) return [];
        const ship = getShipById(state.frontier.shipId);
        const nextIds = ship.nextIds || [];
        return nextIds.map((id) => getShipById(id)).filter(Boolean);
      }

      function purchaseFrontierUpgrade(id) {
        if (!isFrontierMode() || !state.frontier || !player) return;
        const upgrade = FRONTIER_UPGRADES.find((item) => item.id === id);
        if (!upgrade) return;
        const level = state.frontier.upgrades[upgrade.id] || 0;
        const maxLevel = upgrade.maxLevel || 1;
        if (level >= maxLevel) return;
        const cost = getFrontierUpgradeCost(upgrade, level, state.frontier.tier);
        if (state.credits < cost) return;
        const healthRatio = player.maxHealth ? player.health / player.maxHealth : 1;
        const shieldRatio = player.maxShield ? player.shield / player.maxShield : 1;
        const energyRatio = player.maxEnergy ? player.energy / player.maxEnergy : 1;
        state.credits -= cost;
        state.frontier.upgrades[upgrade.id] = level + 1;
        if (upgrade.apply) {
          upgrade.apply(player, level + 1);
        }
        player.health = Math.min(player.maxHealth, player.maxHealth * healthRatio);
        player.shield = Math.min(player.maxShield, player.maxShield * shieldRatio);
        player.energy = Math.min(player.maxEnergy, player.maxEnergy * energyRatio);
        logEvent(`Frontier upgrade installed: ${upgrade.name}.`);
        renderActiveUpgrades();
        setOverlay("dock");
      }

      function toggleFrontierDock() {
        if (!isFrontierMode()) {
          logEvent("Frontier dock available in Frontier mode.");
          return;
        }
        if (state.mode === "dock" || state.mode === "tier-select") {
          closeFrontierDock();
        } else if (state.mode === "flight") {
          openFrontierDock();
        }
      }

      function openFrontierDock() {
        if (!isFrontierMode() || !state.frontier || state.mode !== "flight") return;
        setMode("dock");
        setOverlay("dock");
      }

      function closeFrontierDock() {
        if (state.mode !== "dock" && state.mode !== "tier-select") return;
        setMode("flight");
        hideOverlay();
      }

      function openFrontierTierSelect() {
        if (!isFrontierMode() || !state.frontier) return;
        const nextShips = getFrontierNextShips();
        if (!nextShips.length) return;
        const cost = getFrontierTierCost(state.frontier.tier);
        if (state.credits < cost) {
          logEvent("Not enough credits to upgrade tiers.");
          return;
        }
        setMode("tier-select");
        setOverlay("tier-select");
      }

      function selectFrontierShip(id) {
        if (!isFrontierMode() || !state.frontier) return;
        const nextShips = getFrontierNextShips().map((ship) => ship.id);
        if (!nextShips.includes(id)) return;
        const cost = getFrontierTierCost(state.frontier.tier);
        if (state.credits < cost) return;
        const ship = getShipById(id);
        state.credits -= cost;
        state.frontier.tier = ship.tier || state.frontier.tier + 1;
        state.frontier.shipId = ship.id;
        state.frontier.weaponId = ship.signatureWeapon || progress.selectedWeapon;
        state.frontier.upgrades = {};
        state.frontier.spawnTimer = 0;
        player = createPlayer({ shipId: ship.id, weaponId: state.frontier.weaponId });
        state.runLoadout = { ship: ship.name, weapon: player.weapon?.name || "Unknown" };
        logEvent(`Tier ${state.frontier.tier} frame acquired: ${ship.name}.`);
        closeFrontierDock();
        renderActiveUpgrades();
      }

      function spawnWave(wave) {
        const isHardWave = wave % 5 === 0;
        const isBossWave = wave % 10 === 0;
        const baseCount = Math.min(4 + Math.floor(wave * 1.05), 18);
        const difficulty = getDifficultySettings();
        const frontierTier = isFrontierMode() && state.frontier ? state.frontier.tier : 1;
        const waveRamp = 1
          + wave * 0.07
          + Math.max(0, wave - 12) * 0.015
          + Math.max(0, wave - 20) * 0.02;
        let enemyScale = waveRamp * difficulty.enemyScale * (1 + (frontierTier - 1) * 0.18);
        if (isBossWave) {
          enemyScale *= 1.2;
        } else if (isHardWave) {
          enemyScale *= 1.12;
        }
        const hardBonus = isHardWave && !isBossWave ? 2 : 0;
        const bossBonus = isBossWave ? 3 : 0;
        const spawnCount = baseCount
          + (wave % 3 === 0 ? 1 : 0)
          + hardBonus
          + bossBonus
          + (isFrontierMode() ? Math.max(0, Math.floor((frontierTier - 1) * 1.2)) : 0);
        const availableTypes = ENEMY_TYPES.filter((type) => {
          if (type.minWave && wave < type.minWave) return false;
          if (type.maxWave && wave > type.maxWave) return false;
          return true;
        });
        const selectionPool = availableTypes.length ? availableTypes : ENEMY_TYPES;
        const weights = selectionPool.map((type) => type.weight || 1);
        for (let i = 0; i < spawnCount; i += 1) {
          const type = pickWeighted(selectionPool, weights);
          enemies.push(createEnemy(type, enemyScale, difficulty));
        }
        if (isHardWave && !isBossWave) {
          enemies.push(createEnemy(ACE_TYPE, enemyScale + 0.25, difficulty, true));
          logEvent("Hard wave incoming. Enemy ace spotted.");
        }
        if (isBossWave) {
          enemies.push(createEnemy(BOSS_TYPE, enemyScale + 0.5, difficulty, true));
          logEvent("Boss wave: capital dreadnought detected.");
        }
      }

      function createEnemy(type, scale, difficulty, forceElite) {
        const position = randomWorldPosition();
        const baseHealth = type.health * scale;
        const baseShield = type.shield * scale;
        const baseSpeed = type.speed + scale * 12;
        const baseAccel = type.accel + scale * 16;
        const baseFireRate = type.fireRate + scale * 0.04;
        const baseBulletSpeed = type.bulletSpeed + scale * 10;
        const baseDamage = (type.damage + scale * 1.2) * (difficulty ? difficulty.enemyDamage : 1);
        const baseTurnRate = type.turnRate || 2.6;
        const preferredRange = Number.isFinite(type.preferredRange)
          ? type.preferredRange + rand(-18, 18)
          : rand(180, 260);
        const strafeBias = Number.isFinite(type.strafeBias)
          ? type.strafeBias
          : (Math.random() > 0.5 ? 1 : -1);
        const burstCount = type.burstCount || 0;
        const burstInterval = type.burstInterval || 0.12;
        const burstCooldown = type.burstCooldown || 1.2;
        const shieldPulseCooldown = type.shieldPulseCooldown || 0;
        const ramCooldown = type.ramCooldown || 0;
        const enemy = {
          id: type.id,
          name: type.name,
          x: position.x,
          y: position.y,
          vx: 0,
          vy: 0,
          angle: rand(0, Math.PI * 2),
          radius: type.radius,
          maxHealth: baseHealth,
          health: baseHealth,
          maxShield: baseShield,
          shield: baseShield,
          baseSpeed,
          baseAccel,
          baseFireRate,
          baseBulletSpeed,
          baseDamage,
          baseTurnRate,
          fireCooldown: rand(0.2, 0.6),
          color: type.color,
          credits: type.credits,
          score: type.score,
          hitFlash: 0,
          slowTimer: 0,
          slowFactor: 1,
          preferredRange,
          strafeBias,
          pattern: type.pattern || (type.spreadCount ? "spread" : "single"),
          spreadCount: type.spreadCount || 0,
          spreadAngle: Number.isFinite(type.spreadAngle) ? type.spreadAngle : null,
          bulletRadius: type.bulletRadius || 3,
          bulletLife: type.bulletLife || 1.6,
          bulletTint: type.bulletTint || null,
          bulletSlowPlayer: !!type.bulletSlowPlayer,
          bulletSlowDuration: type.bulletSlowDuration || 1.4,
          burstCount,
          burstInterval,
          burstCooldown,
          burstRemaining: 0,
          burstTimer: 0,
          shieldPulseCooldown,
          shieldPulseTimer: shieldPulseCooldown ? rand(0.3, shieldPulseCooldown) : 0,
          shieldPulseRadius: type.shieldPulseRadius || 0,
          shieldPulseAmount: type.shieldPulseAmount || 0,
          shieldPulseColor: type.shieldPulseColor || "#7ca8ff",
          shieldPulseSelf: !!type.shieldPulseSelf,
          ramDamage: type.ramDamage || 0,
          ramCooldown,
          ramTimer: ramCooldown ? rand(0.3, ramCooldown) : 0,
          ramRange: type.ramRange || 0,
          ramKnockback: type.ramKnockback || 0
        };
        const eliteChance = forceElite ? 1 : (scale > 1.1 && Math.random() < 0.18);
        if (eliteChance && type.id !== "dreadnought") {
          applyEliteMod(enemy);
        }
        return enemy;
      }

      function applyEliteMod(enemy) {
        const mod = pick(ELITE_MODS);
        enemy.elite = mod;
        if (mod.mods.maxShield) {
          enemy.maxShield *= 1 + mod.mods.maxShield;
          enemy.shield = enemy.maxShield;
        }
        if (mod.mods.speed) {
          enemy.baseSpeed *= mod.mods.speed;
        }
        if (mod.mods.accel) {
          enemy.baseAccel *= mod.mods.accel;
        }
        if (mod.mods.damage) {
          enemy.baseDamage *= mod.mods.damage;
        }
        if (mod.mods.fireRate) {
          enemy.baseFireRate *= mod.mods.fireRate;
        }
        enemy.color = mod.color || enemy.color;
      }

      function randomWorldPosition() {
        const padding = 60;
        const minDistance = player ? 240 : 0;
        for (let i = 0; i < 12; i += 1) {
          const position = {
            x: rand(padding, state.worldWidth - padding),
            y: rand(padding, state.worldHeight - padding)
          };
          if (isPointInObstacle(position, 50)) continue;
          if (player && distanceBetween(position, player) < minDistance) continue;
          return position;
        }
        return {
          x: clamp(state.worldWidth * 0.5 + rand(-120, 120), padding, state.worldWidth - padding),
          y: clamp(state.worldHeight * 0.5 + rand(-120, 120), padding, state.worldHeight - padding)
        };
      }

      function loop(timestamp) {
        const delta = Math.min(0.033, (timestamp - state.lastTime) / 1000 || 0);
        state.lastTime = timestamp;
        update(delta);
        render();
        updateHud();
        requestAnimationFrame(loop);
      }

      function update(delta) {
        updateStars(delta);
        updateParticles(delta);
        updatePulses(delta);
        updateLootBursts(delta);
        updateDamageNumbers(delta);
        trackOnboarding(delta);
        updateCamera();
        updatePointerWorld();
        if (state.mode !== "flight" && state.mode !== "training") {
          return;
        }
        updatePlayer(delta);
        updateCamera();
        updatePointerWorld();
        updateDecoy(delta);
        updateEnemies(delta);
        updateSkillSystems(delta);
        updateHelpers(delta);
        updateBullets(delta);
        updateMines(delta);
        updateContracts(delta);
        handleCollisions();
        if (isFrontierMode()) {
          updateFrontierSpawner(delta);
        } else {
          checkWaveStatus();
        }
      }

      function trackOnboarding(delta) {
        if (state.mode !== "flight" && state.mode !== "training") return;
        state.onboardingTimer += delta;
        if (state.onboardingTimer < 1) return;
        const elapsed = Math.floor(state.onboardingTimer);
        state.onboardingTimer -= elapsed;
        progress.onboarding = progress.onboarding || { flightSeconds: 0 };
        progress.onboarding.flightSeconds = (progress.onboarding.flightSeconds || 0) + elapsed;
        state.onboardingSave += elapsed;
        checkProgressionUnlocks();
        if (state.onboardingSave >= 12) {
          state.onboardingSave = 0;
          saveProgress();
        }
      }

      function updateStars(delta) {
        const width = state.worldWidth || state.width;
        const height = state.worldHeight || state.height;
        stars.forEach((star) => {
          star.x += star.speed * delta * 0.03;
          star.y += star.speed * delta * 0.18;
          if (star.x < 0) star.x += width;
          if (star.x > width) star.x -= width;
          if (star.y < 0) star.y += height;
          if (star.y > height) star.y -= height;
        });
      }

      function updateParticles(delta) {
        for (let i = particles.length - 1; i >= 0; i -= 1) {
          const particle = particles[i];
          particle.x += particle.vx * delta;
          particle.y += particle.vy * delta;
          particle.life -= delta;
          if (particle.life <= 0) {
            particles.splice(i, 1);
          }
        }
      }

      function updatePulses(delta) {
        for (let i = pulses.length - 1; i >= 0; i -= 1) {
          const pulse = pulses[i];
          pulse.life -= delta;
          pulse.radius = Math.min(pulse.maxRadius, pulse.radius + pulse.speed * delta);
          if (pulse.life <= 0) {
            pulses.splice(i, 1);
          }
        }
      }

      function updateLootBursts(delta) {
        for (let i = lootBursts.length - 1; i >= 0; i -= 1) {
          const burst = lootBursts[i];
          burst.life -= delta;
          burst.y += burst.vy * delta;
          if (burst.life <= 0) {
            lootBursts.splice(i, 1);
          }
        }
      }

      function updateDamageNumbers(delta) {
        for (let i = damageNumbers.length - 1; i >= 0; i -= 1) {
          const burst = damageNumbers[i];
          burst.life -= delta;
          burst.x += burst.vx * delta;
          burst.y += burst.vy * delta;
          if (burst.life <= 0) {
            damageNumbers.splice(i, 1);
          }
        }
      }

      function updatePlayer(delta) {
        if (!player) return;
        if (player.slowTimer > 0) {
          player.slowTimer = Math.max(0, player.slowTimer - delta);
        }
        player.slowFactor = player.slowTimer > 0 ? 0.7 : 1;
        const keyboardAim = getKeyboardAimVector();
        if (keyboardAim.active) {
          input.aimAngle = Math.atan2(keyboardAim.y, keyboardAim.x);
          input.aimSource = "keyboard";
        } else if (input.aimMode !== "keyboard" && input.pointer.active) {
          input.aimAngle = Math.atan2(input.pointer.y - player.y, input.pointer.x - player.x);
          input.aimSource = "mouse";
        }
        const turnRate = (player.turnRate || 0) * (player.slowFactor || 1);
        player.angle = rotateTowards(player.angle, input.aimAngle, turnRate * delta);
        input.pointer.moved = false;

        if (player.abilityCooldown > 0) {
          player.abilityCooldown = Math.max(0, player.abilityCooldown - delta);
        }
        if (player.abilityTimer > 0) {
          player.abilityTimer = Math.max(0, player.abilityTimer - delta);
          if (player.abilityTimer <= 0 && player.ability && player.ability.onEnd) {
            player.ability.onEnd(player, state);
          }
        }
        if (player.secondaryCooldown > 0) {
          player.secondaryCooldown = Math.max(0, player.secondaryCooldown - delta);
        }
        if (player.invulnerable > 0) {
          player.invulnerable = Math.max(0, player.invulnerable - delta);
        }

        const allowArrowThrust = input.aimMode !== "keyboard";
        const thrustForward = isActionActive("forward") || (allowArrowThrust && hasKey("arrowup"));
        const thrustBack = isActionActive("back") || (allowArrowThrust && hasKey("arrowdown"));
        const strafeLeft = isActionActive("left") || (allowArrowThrust && hasKey("arrowleft"));
        const strafeRight = isActionActive("right") || (allowArrowThrust && hasKey("arrowright"));
        const boosting = isActionActive("boost") && player.energy > player.boostCost * delta;

        if (boosting) {
          player.energy = Math.max(0, player.energy - player.boostCost * delta);
        }

        const playerMod = state.sectorMod ? state.sectorMod.player : {};
        const slowFactor = player.slowFactor || 1;
        const accel = player.accel * (boosting ? player.boostMultiplier : 1) * (playerMod.speed || 1) * slowFactor;
        let ax = 0;
        let ay = 0;
        player.thrusting = false;

        if (thrustForward) {
          ax += Math.cos(player.angle) * accel;
          ay += Math.sin(player.angle) * accel;
          player.thrusting = true;
        }
        if (thrustBack) {
          ax -= Math.cos(player.angle) * accel * 0.6;
          ay -= Math.sin(player.angle) * accel * 0.6;
          player.thrusting = true;
        }
        if (strafeLeft) {
          ax += Math.cos(player.angle - Math.PI / 2) * accel * 0.7;
          ay += Math.sin(player.angle - Math.PI / 2) * accel * 0.7;
          player.thrusting = true;
        }
        if (strafeRight) {
          ax += Math.cos(player.angle + Math.PI / 2) * accel * 0.7;
          ay += Math.sin(player.angle + Math.PI / 2) * accel * 0.7;
          player.thrusting = true;
        }

        player.vx += ax * delta;
        player.vy += ay * delta;

        const damping = Math.max(0, 1 - player.damping * delta);
        player.vx *= damping;
        player.vy *= damping;

        const speedLimit = player.maxSpeed * (boosting ? player.boostMultiplier : 1) * (playerMod.speed || 1) * slowFactor;
        const speed = Math.hypot(player.vx, player.vy);
        if (speed > speedLimit) {
          const ratio = speedLimit / speed;
          player.vx *= ratio;
          player.vy *= ratio;
        }

        player.x += player.vx * delta;
        player.y += player.vy * delta;
        wrapEntity(player);
        resolveObstacleCollisions(player);
        wrapEntity(player);

        player.fireCooldown = Math.max(0, player.fireCooldown - delta);
        player.shieldCooldown = Math.max(0, player.shieldCooldown - delta);

        const energyRegen = player.energyRegen * (playerMod.energyRegen || 1);
        const shieldRegen = player.shieldRegen * (playerMod.shieldRegen || 1);
        player.energy = Math.min(player.maxEnergy, player.energy + energyRegen * delta);
        if (player.shieldCooldown <= 0) {
          player.shield = Math.min(player.maxShield, player.shield + shieldRegen * delta);
        }

        if (player.hitFlash > 0) {
          player.hitFlash = Math.max(0, player.hitFlash - delta);
        }

        const firing = input.firing || isActionActive("fire");
        const energyCost = player.energyCost * (playerMod.energyCost || 1);
        if (firing && player.fireCooldown <= 0 && player.energy >= energyCost) {
          firePlayer();
        }
      }

      function updateSkillSystems(delta) {
        if (!player) return;
        updateAura(delta);
        updateMineDeployment(delta);
        updateShockwave(delta);
        updateMissiles(delta);
      }

      function updateAura(delta) {
        if (player.auraRadius <= 0 || player.auraDamage <= 0) return;
        player.auraTimer = (player.auraTimer || 0) - delta;
        if (player.auraTimer > 0) return;
        const interval = player.auraInterval || 0.45;
        player.auraTimer = interval;
        const damage = player.auraDamage * interval;
        for (let i = enemies.length - 1; i >= 0; i -= 1) {
          const enemy = enemies[i];
          if (distanceBetween(player, enemy) <= player.auraRadius + enemy.radius) {
            applyDamage(enemy, damage, { owner: "player" });
            if (enemy.health <= 0) {
              destroyEnemy(enemy, i);
            }
          }
        }
      }

      function updateMineDeployment(delta) {
        if (player.mineDropChance <= 0 || player.mineRadius <= 0 || player.mineDamage <= 0) return;
        player.mineTimer = (player.mineTimer || 0) - delta;
        if (player.mineTimer > 0) return;
        player.mineTimer = player.mineInterval || 1.2;
        if (Math.random() < player.mineDropChance) {
          state.mines.push({
            x: player.x + rand(-10, 10),
            y: player.y + rand(-10, 10),
            radius: player.mineRadius,
            damage: player.mineDamage,
            timer: player.mineDuration || 5
          });
        }
      }

      function updateShockwave(delta) {
        if (player.shockwaveInterval <= 0 || player.shockwaveRadius <= 0 || player.shockwaveDamage <= 0) return;
        player.shockwaveTimer = (player.shockwaveTimer || 0) - delta;
        if (player.shockwaveTimer > 0) return;
        player.shockwaveTimer = player.shockwaveInterval;
        spawnPulse(player.x, player.y, "#7ca8ff", player.shockwaveRadius);
        for (let i = enemies.length - 1; i >= 0; i -= 1) {
          const enemy = enemies[i];
          if (distanceBetween(player, enemy) <= player.shockwaveRadius + enemy.radius) {
            applyDamage(enemy, player.shockwaveDamage, { owner: "player" });
            if (player.shockwaveSlow > 0) {
              enemy.slowTimer = Math.max(enemy.slowTimer || 0, player.shockwaveSlow);
            }
            if (enemy.health <= 0) {
              destroyEnemy(enemy, i);
            }
          }
        }
      }

      function updateMissiles(delta) {
        if (player.missileInterval <= 0 || player.missileDamage <= 0 || player.missileCount <= 0) return;
        player.missileTimer = (player.missileTimer || 0) - delta;
        if (player.missileTimer > 0) return;
        const target = getNearestEnemy(player.x, player.y, 520);
        if (!target) return;
        player.missileTimer = player.missileInterval;
        const count = Math.max(1, player.missileCount);
        for (let i = 0; i < count; i += 1) {
          const angle = Math.atan2(target.y - player.y, target.x - player.x) + rand(-0.2, 0.2);
          const speed = player.missileSpeed || 520;
          bullets.push({
            owner: "player",
            x: player.x + Math.cos(angle) * (player.radius + 6),
            y: player.y + Math.sin(angle) * (player.radius + 6),
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 3,
            life: 1.6,
            damage: player.missileDamage,
            tint: "#f6c65f"
          });
        }
      }

      function updateHelpers(delta) {
        if (!player || player.helperCount <= 0) {
          helpers = [];
          return;
        }
        const count = Math.min(5, Math.max(1, player.helperCount));
        const orbitRadius = player.helperOrbitRadius || 26;
        const orbitSpeed = player.helperOrbitSpeed || 1.4;
        while (helpers.length < count) {
          helpers.push({
            angle: Math.random() * Math.PI * 2,
            fireCooldown: rand(0.1, 0.6)
          });
        }
        if (helpers.length > count) {
          helpers = helpers.slice(0, count);
        }
        const baseAngle = player.angle;
        helpers.forEach((helper, index) => {
          helper.angle += orbitSpeed * delta;
          const offset = helper.angle + (index * Math.PI * 2) / count;
          helper.x = player.x + Math.cos(offset) * orbitRadius;
          helper.y = player.y + Math.sin(offset) * orbitRadius;
          helper.fireCooldown = Math.max(0, helper.fireCooldown - delta);
        });
        const target = getNearestEnemy(player.x, player.y, player.helperRange || 360);
        if (!target) return;
        const rate = Math.max(0.4, player.helperFireRate || 1.2);
        helpers.forEach((helper) => {
          if (helper.fireCooldown > 0) return;
          fireHelper(helper, target);
          helper.fireCooldown = 1 / rate;
        });
      }

      function fireHelper(helper, target) {
        if (!helper || !target) return;
        const angle = Math.atan2(target.y - helper.y, target.x - helper.x) + rand(-0.1, 0.1);
        const speed = player.bulletSpeed * 0.9;
        const damage = player.damage * (player.helperDamageRatio || 0.3);
        bullets.push({
          owner: "player",
          x: helper.x + Math.cos(angle) * 6,
          y: helper.y + Math.sin(angle) * 6,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: 2.6,
          life: 1.4,
          damage,
          tint: "#6ee7b7"
        });
      }

      function getNearestEnemy(x, y, range) {
        let best = null;
        let bestDist = range || Infinity;
        for (let i = 0; i < enemies.length; i += 1) {
          const enemy = enemies[i];
          const distance = Math.hypot(enemy.x - x, enemy.y - y);
          if (distance < bestDist) {
            best = enemy;
            bestDist = distance;
          }
        }
        return best;
      }

      function activateAbility() {
        if (!player || !player.ability) return;
        if (state.mode !== "flight" && state.mode !== "training") return;
        if (!isFeatureUnlocked("ability")) {
          showTip("locked-ability", "Ability systems locked", getFeatureHint("ability"));
          return;
        }
        if (player.abilityCooldown > 0 || player.abilityTimer > 0) return;
        player.abilityTimer = player.ability.duration || 0;
        player.abilityCooldown = player.ability.cooldown || 0;
        if (player.ability.onStart) {
          player.ability.onStart(player, state);
        }
      }

      function activateSecondary() {
        if (!player || !player.secondary) return;
        if (state.mode !== "flight" && state.mode !== "training") return;
        if (!isFeatureUnlocked("secondary")) {
          showTip("locked-secondary", "Secondary system locked", getFeatureHint("secondary"));
          return;
        }
        if (player.secondaryCooldown > 0) return;
        player.secondaryCooldown = player.secondary.cooldown || 0;
        if (player.secondary.activate) {
          player.secondary.activate(player, state);
        }
      }

      function updateEnemies(delta) {
        enemies.forEach((enemy) => {
          enemy.fireCooldown = Math.max(0, enemy.fireCooldown - delta);
          if (enemy.hitFlash > 0) {
            enemy.hitFlash = Math.max(0, enemy.hitFlash - delta);
          }
          if (enemy.slowTimer > 0) {
            enemy.slowTimer = Math.max(0, enemy.slowTimer - delta);
            enemy.slowFactor = enemy.slowTimer > 0 ? 0.6 : 1;
          }
          if (enemy.shieldPulseCooldown > 0) {
            enemy.shieldPulseTimer = Math.max(0, enemy.shieldPulseTimer - delta);
          }
          if (enemy.ramCooldown > 0) {
            enemy.ramTimer = Math.max(0, enemy.ramTimer - delta);
          }
          if (enemy.burstRemaining > 0) {
            enemy.burstTimer = Math.max(0, enemy.burstTimer - delta);
          }

          const target = state.decoy && state.decoy.timer > 0 ? state.decoy : player;
          const dx = target.x - enemy.x;
          const dy = target.y - enemy.y;
          const distance = Math.hypot(dx, dy) || 1;
          const bulletSpeed = enemy.baseBulletSpeed * (state.sectorMod?.enemy?.bulletSpeed || 1);
          const leadTime = Math.min(0.8, distance / bulletSpeed);
          const targetX = target.x + (target.vx || 0) * leadTime;
          const targetY = target.y + (target.vy || 0) * leadTime;
          const aimAngle = Math.atan2(targetY - enemy.y, targetX - enemy.x);
          const turnRate = (enemy.baseTurnRate || 0) * enemy.slowFactor;
          enemy.angle = rotateTowards(enemy.angle, aimAngle, turnRate * delta);

          const accel = enemy.baseAccel * (state.sectorMod?.enemy?.accel || 1) * enemy.slowFactor;
          let ax = 0;
          let ay = 0;
          const toTargetX = dx / distance;
          const toTargetY = dy / distance;
          const currentSpeed = Math.hypot(enemy.vx, enemy.vy);

          if (distance > enemy.preferredRange) {
            ax += toTargetX * accel;
            ay += toTargetY * accel;
          } else {
            const strafeAngle = aimAngle + Math.PI / 2 * enemy.strafeBias;
            ax += Math.cos(strafeAngle) * accel * 0.85;
            ay += Math.sin(strafeAngle) * accel * 0.85;
          }

          const avoidance = getObstacleAvoidance(enemy, toTargetX, toTargetY);
          ax += avoidance.x * accel * 0.65;
          ay += avoidance.y * accel * 0.65;
          const edgeAvoidance = getBoundaryAvoidance(enemy, toTargetX, toTargetY);
          ax += edgeAvoidance.x * accel * 0.85;
          ay += edgeAvoidance.y * accel * 0.85;
          if (distance > enemy.preferredRange * 0.7 && currentSpeed < 34) {
            ax += toTargetX * accel * 0.45;
            ay += toTargetY * accel * 0.45;
          }

          enemy.vx += ax * delta;
          enemy.vy += ay * delta;

          const damping = Math.max(0, 1 - 2 * delta);
          enemy.vx *= damping;
          enemy.vy *= damping;

          const maxSpeed = enemy.baseSpeed * (state.sectorMod?.enemy?.speed || 1) * enemy.slowFactor;
          const speed = Math.hypot(enemy.vx, enemy.vy);
          if (speed > maxSpeed) {
            const ratio = maxSpeed / speed;
            enemy.vx *= ratio;
            enemy.vy *= ratio;
          }

          enemy.x += enemy.vx * delta;
          enemy.y += enemy.vy * delta;
          wrapEntity(enemy);
          resolveObstacleCollisions(enemy);
          wrapEntity(enemy);

          if (enemy.shieldPulseCooldown > 0 && enemy.shieldPulseTimer <= 0) {
            const radius = enemy.shieldPulseRadius || 0;
            const amount = enemy.shieldPulseAmount || 0;
            if (amount > 0) {
              enemies.forEach((ally) => {
                if (radius <= 0) {
                  if (!enemy.shieldPulseSelf || ally !== enemy) return;
                } else if (distanceBetween(enemy, ally) > radius) {
                  return;
                }
                ally.shield = Math.min(ally.maxShield, ally.shield + amount);
              });
            }
            spawnPulse(enemy.x, enemy.y, enemy.shieldPulseColor || "#7ca8ff", radius || 120);
            enemy.shieldPulseTimer = enemy.shieldPulseCooldown;
          }

          if (enemy.ramDamage > 0 && player && enemy.ramTimer <= 0) {
            const playerDistance = distanceBetween(enemy, player);
            const ramRange = enemy.ramRange || (enemy.radius + player.radius + 8);
            if (playerDistance <= ramRange) {
              applyDamage(player, enemy.ramDamage, { owner: "enemy" });
              enemy.ramTimer = enemy.ramCooldown || 0;
              enemy.hitFlash = 0.2;
              spawnPulse(enemy.x, enemy.y, "#f06969", 90);
              if (enemy.ramKnockback) {
                const pushAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                player.vx += Math.cos(pushAngle) * enemy.ramKnockback;
                player.vy += Math.sin(pushAngle) * enemy.ramKnockback;
              }
            }
          }

          const fireRate = enemy.baseFireRate * (state.sectorMod?.enemy?.fireRate || 1);
          const inRange = distance < 520;
          if (enemy.burstRemaining > 0) {
            if (enemy.burstTimer <= 0 && inRange) {
              fireEnemy(enemy, enemy.angle);
              enemy.burstRemaining -= 1;
              enemy.burstTimer = enemy.burstInterval || 0.12;
            }
          } else if (enemy.fireCooldown <= 0 && inRange) {
            if (enemy.burstCount > 1) {
              fireEnemy(enemy, enemy.angle);
              enemy.burstRemaining = enemy.burstCount - 1;
              enemy.burstTimer = enemy.burstInterval || 0.12;
              enemy.fireCooldown = enemy.burstCooldown || (1 / fireRate);
            } else {
              fireEnemy(enemy, enemy.angle);
              enemy.fireCooldown = 1 / fireRate;
            }
          }
        });
      }

      function updateBullets(delta) {
        for (let i = bullets.length - 1; i >= 0; i -= 1) {
          const bullet = bullets[i];
          bullet.x += bullet.vx * delta;
          bullet.y += bullet.vy * delta;
          bullet.life -= delta;
          if (isPointInObstacle(bullet, bullet.radius + 2)) {
            bullets.splice(i, 1);
            continue;
          }
          if (bullet.life <= 0 || isOutOfBounds(bullet)) {
            bullets.splice(i, 1);
          }
        }
      }

      function updateDecoy(delta) {
        if (!state.decoy) return;
        state.decoy.timer -= delta;
        if (state.decoy.timer <= 0) {
          state.decoy = null;
        }
      }

      function updateMines(delta) {
        if (!state.mines.length) return;
        for (let i = state.mines.length - 1; i >= 0; i -= 1) {
          const mine = state.mines[i];
          mine.timer -= delta;
          if (mine.timer <= 0) {
            state.mines.splice(i, 1);
            continue;
          }
          for (let j = enemies.length - 1; j >= 0; j -= 1) {
            const enemy = enemies[j];
            if (distanceBetween(mine, enemy) <= mine.radius + enemy.radius) {
              applyDamage(enemy, mine.damage || 40, { owner: "player" });
              spawnExplosion(mine.x, mine.y, "#f6c65f");
              state.mines.splice(i, 1);
              if (enemy.health <= 0) {
                destroyEnemy(enemy, j);
              }
              break;
            }
          }
        }
      }

      function handleCollisions() {
        for (let i = bullets.length - 1; i >= 0; i -= 1) {
          const bullet = bullets[i];
          if (bullet.owner === "player") {
            for (let j = enemies.length - 1; j >= 0; j -= 1) {
              const enemy = enemies[j];
              if (distanceBetween(bullet, enemy) <= bullet.radius + enemy.radius) {
                applyDamage(enemy, bullet.damage, bullet);
                if (bullet.splashRadius && bullet.splashRadius > 0) {
                  applySplashDamage(enemy, bullet);
                }
                triggerArcChain(enemy, bullet);
                if (enemy.health <= 0) {
                  destroyEnemy(enemy, j);
                }
                if (bullet.pierce && bullet.pierce > 0) {
                  bullet.pierce -= 1;
                } else {
                  bullets.splice(i, 1);
                }
                break;
              }
            }
          } else if (bullet.owner === "enemy") {
            if (player.invulnerable <= 0 && distanceBetween(bullet, player) <= bullet.radius + player.radius) {
              applyDamage(player, bullet.damage, bullet);
              bullets.splice(i, 1);
              if (player.health <= 0) {
                triggerGameOver();
              }
            }
          }
        }
      }

      function applySplashDamage(primary, bullet) {
        const radius = bullet.splashRadius || 0;
        if (!radius) return;
        const splashDamage = bullet.damage * (bullet.splashDamage || 0.6);
        for (let j = enemies.length - 1; j >= 0; j -= 1) {
          const enemy = enemies[j];
          if (enemy === primary) continue;
          if (distanceBetween(primary, enemy) <= radius) {
            applyDamage(enemy, splashDamage, bullet);
            if (enemy.health <= 0) {
              destroyEnemy(enemy, j);
            }
          }
        }
      }

      function findArcTarget(primary, radius) {
        let target = null;
        let closest = radius;
        for (let i = 0; i < enemies.length; i += 1) {
          const enemy = enemies[i];
          if (enemy === primary) continue;
          const distance = distanceBetween(primary, enemy);
          if (distance <= closest) {
            closest = distance;
            target = enemy;
          }
        }
        return target;
      }

      function triggerArcChain(primary, bullet) {
        if (!bullet || !bullet.arcDamage || !bullet.arcRadius || !bullet.arcChains) return;
        if (bullet.arcRequiresSlow && (!primary.slowTimer || primary.slowTimer <= 0)) return;
        const target = findArcTarget(primary, bullet.arcRadius);
        if (!target) return;
        bullet.arcChains -= 1;
        const arcDamage = bullet.damage * bullet.arcDamage;
        applyDamage(target, arcDamage, { owner: "player" });
        spawnPulse(target.x, target.y, "#7ca8ff", Math.min(160, bullet.arcRadius));
        const targetIndex = enemies.indexOf(target);
        if (target.health <= 0 && targetIndex >= 0) {
          destroyEnemy(target, targetIndex);
        }
      }

      function updateContracts(delta) {
        if (!state.contracts.length || state.training) return;
        let changed = false;
        const now = performance.now();
        state.contracts.forEach((contract) => {
          if (contract.complete) return;
          if (contract.type === "noDamage") {
            const prev = contract.progress;
            contract.progress = Math.min(contract.target, contract.progress + delta);
            if (Math.floor(contract.progress) !== Math.floor(prev)) {
              changed = true;
            }
            if (contract.progress >= contract.target) {
              completeContract(contract);
            }
          }
        });
        if (changed && now - state.lastContractRender > 250) {
          state.lastContractRender = now;
          renderContracts();
        }
      }

      function resetNoDamageContracts() {
        if (!state.contracts.length) return;
        let updated = false;
        state.contracts.forEach((contract) => {
          if (contract.type === "noDamage" && !contract.complete) {
            contract.progress = 0;
            updated = true;
          }
        });
        if (updated) {
          renderContracts();
        }
      }

      function completeContract(contract) {
        contract.complete = true;
        contract.progress = contract.target;
        state.credits += contract.reward.credits;
        awardXp(contract.reward.xp);
        progress.factions[contract.factionId] = (progress.factions[contract.factionId] || 0) + contract.reward.rep;
        saveProgress();
        renderContracts();
        renderShipyard();
        renderArmory();
        logEvent(`Contract complete: ${contract.title}.`);
      }

      function updateKillContracts(enemy) {
        if (!state.contracts.length) return;
        let updated = false;
        state.contracts.forEach((contract) => {
          if (contract.complete) return;
          if (contract.type === "kills") {
            contract.progress += 1;
            updated = true;
            if (contract.progress >= contract.target) {
              completeContract(contract);
            }
          }
          if (contract.type === "elite" && (enemy.elite || enemy.id === "dreadnought" || enemy.id === "ace")) {
            contract.progress = contract.target;
            updated = true;
            completeContract(contract);
          }
        });
        if (updated) {
          renderContracts();
        }
      }

      function maybeDropLoot(enemy) {
        const isBoss = enemy.id === "dreadnought";
        const isElite = enemy.elite || enemy.id === "ace";
        const drops = [];
        const keyChance = isBoss ? 1 : isElite ? 0.35 : 0.12;
        if (Math.random() < keyChance) {
          progress.salvageKeys += 1;
          logEvent("Salvage key recovered from the wreckage.");
          drops.push({
            label: "Salvage Key +1",
            tier: isBoss ? "epic" : isElite ? "rare" : "uncommon"
          });
        }
        const blueprintChance = isBoss ? 1 : isElite ? 0.35 : 0.08;
        if (Math.random() < blueprintChance) {
          progress.blueprints += 1;
          logEvent("Blueprint recovered from debris.");
          drops.push({
            label: "Blueprint +1",
            tier: isBoss ? "epic" : isElite ? "rare" : "uncommon"
          });
        }

        const partChance = isBoss ? 1 : isElite ? 0.45 : 0.12;
        if (Math.random() < partChance) {
          const part = generatePart(isBoss ? "epic" : isElite ? "rare" : null);
          if (part) {
            progress.partsInventory.unshift(part);
            if (progress.partsInventory.length > 18) {
              progress.partsInventory.pop();
            }
            logEvent(`Recovered part: ${part.name}.`);
            drops.push({
              label: `Part: ${part.name}`,
              tier: part.rarityId || getPartTier(part)
            });
          }
        }
        if (drops.length) {
          spawnLootBursts(enemy.x, enemy.y, drops);
        }
        checkProgressionUnlocks();
      }

      function generatePart(preferred) {
        const rarityPool = ["common", "uncommon", "rare", "epic"];
        const rarityId = preferred || pickWeighted(rarityPool, [0.5, 0.3, 0.15, 0.05]);
        const templateSlot = pick(PART_SLOTS);
        const template = PART_TEMPLATES[templateSlot];
        if (!template) return null;
        const rarity = PART_RARITIES[rarityId];
        const stats = {};
        const desc = [];
        Object.keys(template.stats).forEach((key) => {
          const range = template.stats[key];
          const value = rand(range[0], range[1]) * rarity.mult;
          const rounded = Math.abs(value) < 1 ? parseFloat(value.toFixed(2)) : Math.round(value);
          stats[key] = rounded;
          desc.push(formatStat(key, rounded));
        });
        return {
          id: `part_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`,
          slot: templateSlot,
          rarityId,
          rarity: rarity.label,
          name: `${rarity.label} ${template.name}`,
          stats,
          description: desc.join("  ")
        };
      }

      function checkWaveStatus() {
        if (enemies.length === 0 && (state.mode === "flight" || state.mode === "training")) {
          if (!state.training) {
            progress.bestWave = Math.max(progress.bestWave, state.wave);
            saveProgress();
          }
          state.wave += 1;
          state.waveStart = performance.now();
          updateSector();
          restoreBetweenWaves();
          checkProgressionUnlocks();
          if (state.training) {
            spawnWave(state.wave);
            logEvent(`Training wave ${state.wave} online.`);
            return;
          }
          if (isFeatureUnlocked("upgrades")) {
            state.upgradeRerolls = 0;
            state.upgradeOptions = rollUpgrades();
            setMode("upgrade");
            setOverlay("upgrade");
            logEvent("Wave cleared. Choose a field upgrade.");
          } else {
            spawnWave(state.wave);
          }
        }
      }

      function updateFrontierSpawner(delta) {
        if (!state.frontier || !state.frontier.active) return;
        state.frontier.spawnTimer += delta;
        const tier = state.frontier.tier || 1;
        const interval = Math.max(10, 18 - tier * 1.2);
        const shouldForce = enemies.length === 0 && state.frontier.spawnTimer >= 2.5;
        if (state.frontier.spawnTimer >= interval || shouldForce) {
          state.frontier.spawnTimer = 0;
          state.wave += 1;
          state.waveStart = performance.now();
          updateSector();
          spawnWave(state.wave);
          if (state.wave % 3 === 0) {
            logEvent(`Frontier spike: threat level ${state.wave}.`);
          }
        }
      }

      function restoreBetweenWaves() {
        applyHullHeal(player, player.maxHealth * 0.25);
        applyShieldHeal(player, player.maxShield - player.shield);
        player.energy = player.maxEnergy;
      }

      function getUpgradeWeight(tier, luck) {
        const meta = getTierMeta(tier);
        if (!luck) return meta.weight;
        const tierIndex = Math.max(0, TIER_ORDER.indexOf(tier));
        const normalized = tierIndex / Math.max(1, TIER_ORDER.length - 1);
        const bias = 1 + luck * (normalized * 1.6 - 0.4);
        return Math.max(0.12, meta.weight * bias);
      }

      function getUpgradeRerollCost() {
        const rerolls = Math.max(0, state.upgradeRerolls || 0);
        return Math.round(UPGRADE_REROLL_COST * Math.pow(UPGRADE_REROLL_SCALE, rerolls));
      }

      function getSkillId(upgrade) {
        return upgrade.skillId || upgrade.id;
      }

      function isSkillUpgrade(upgrade) {
        return upgrade && upgrade.kind === "skill";
      }

      function getSkillTier(level) {
        const index = clamp((level || 1) - 1, 0, TIER_ORDER.length - 1);
        return TIER_ORDER[index] || "common";
      }

      function getUpgradeTier(upgrade, level) {
        if (!upgrade) return "common";
        if (isSkillUpgrade(upgrade)) {
          const resolvedLevel = Number.isFinite(level) ? level : 1;
          return getSkillTier(resolvedLevel);
        }
        return upgrade.tier || "common";
      }

      function canSelectSkillUpgrade(upgrade) {
        if (!isSkillUpgrade(upgrade)) return true;
        const skillId = getSkillId(upgrade);
        return state.skillSlots.includes(skillId) || state.skillSlots.length < SKILL_LIMIT;
      }

      function rollUpgrades() {
        const available = FIELD_UPGRADES.filter((upgrade) => {
          const stack = state.upgradeStacks[upgrade.id] || 0;
          if (stack >= (upgrade.maxStacks || 99)) return false;
          return canSelectSkillUpgrade(upgrade);
        });
        const picks = [];
        const pool = [...available];
        const luck = player ? player.upgradeLuck || 0 : 0;
        while (picks.length < Math.min(3, pool.length)) {
          const weights = pool.map((upgrade) => {
            const stack = state.upgradeStacks[upgrade.id] || 0;
            const tier = getUpgradeTier(upgrade, stack + 1);
            return getUpgradeWeight(tier, luck);
          });
          const selected = pickWeighted(pool, weights);
          picks.push(selected);
          pool.splice(pool.indexOf(selected), 1);
        }
        return picks;
      }

      function acceptUpgrade(id) {
        if (state.mode !== "upgrade") return;
        if (!isFeatureUnlocked("upgrades")) return;
        if (id) {
          const upgrade = FIELD_UPGRADES.find((item) => item.id === id);
          if (upgrade) {
            const wasSkill = isSkillUpgrade(upgrade);
            const skillId = wasSkill ? getSkillId(upgrade) : null;
            const isNewSkill = wasSkill && !state.skillSlots.includes(skillId);
            if (isNewSkill && state.skillSlots.length >= SKILL_LIMIT) {
              logEvent("Skill slots are full. Choose a different upgrade.");
              return;
            }
            const previousHealth = player.health;
            const previousShield = player.shield;
            const stack = state.upgradeStacks[upgrade.id] || 0;
            const nextLevel = stack + 1;
            upgrade.apply(player, nextLevel);
            state.upgradeStacks[upgrade.id] = nextLevel;
            if (isNewSkill) {
              state.skillSlots.push(skillId);
              logEvent(`Skill system online: ${upgrade.name}.`);
            } else if (wasSkill) {
              logEvent(`Skill upgraded: ${upgrade.name}.`);
            } else {
              logEvent(`Upgrade acquired: ${upgrade.name}.`);
            }
            const healthGain = player.health - previousHealth;
            const shieldGain = player.shield - previousShield;
            if (healthGain > 0) {
              spawnDamageNumber(player.x, player.y - player.radius - 12, healthGain, { color: "#6ee7b7", prefix: "+" });
            }
            if (shieldGain > 0) {
              spawnDamageNumber(player.x, player.y - player.radius - 22, shieldGain, { color: "#57e0ff", prefix: "+" });
            }
          }
        } else {
          logEvent("Upgrade skipped. Launching next wave.");
        }
        hideOverlay();
        setMode("flight");
        spawnWave(state.wave);
      }

      function rerollUpgrades() {
        const rerollCost = getUpgradeRerollCost();
        if (state.credits < rerollCost) {
          logEvent("Not enough credits to reroll upgrades.");
          return;
        }
        state.credits -= rerollCost;
        state.upgradeRerolls += 1;
        state.upgradeOptions = rollUpgrades();
        setOverlay("upgrade");
      }

      function firePlayer() {
        const playerMod = state.sectorMod ? state.sectorMod.player : {};
        const energyCost = player.energyCost * (playerMod.energyCost || 1);
        player.fireCooldown = 1 / player.fireRate;
        player.energy = Math.max(0, player.energy - energyCost);
        const barrageEvery = player.barrageEvery || 0;
        if (barrageEvery > 0) {
          player.barrageCounter = (player.barrageCounter || 0) + 1;
        }
        const isBarrage = barrageEvery > 0 && player.barrageCounter % barrageEvery === 0;
        const bonusProjectiles = isBarrage ? (player.barrageProjectiles || 0) : 0;
        const count = Math.max(1, player.projectiles + bonusProjectiles);
        const spread = (count > 1 ? player.spread : 0) * (playerMod.spreadMult || 1);
        const baseAngle = player.angle - spread * (count - 1) * 0.5;
        const damageBoost = isBarrage ? (player.barrageBonusDamage || 1) : 1;
        const splashRadius = isBarrage
          ? Math.max(player.splashRadius || 0, player.barrageSplashRadius || 0)
          : (player.splashRadius || 0);
        const splashDamage = isBarrage
          ? Math.max(player.splashDamage || 0.6, player.barrageSplashDamage || 0.6)
          : (player.splashDamage || 0.6);
        const pierce = (player.pierce || 0) + (isBarrage ? (player.barragePierce || 0) : 0);
        const tint = isBarrage ? "#f6c65f" : (player.arcDamage ? "#7ca8ff" : null);
        for (let i = 0; i < count; i += 1) {
          const angle = baseAngle + spread * i;
          const crit = Math.random() < player.critChance;
          const damage = player.damage * damageBoost * (crit ? player.critMultiplier : 1);
          const speed = player.bulletSpeed;
          bullets.push({
            owner: "player",
            x: player.x + Math.cos(angle) * (player.radius + 4),
            y: player.y + Math.sin(angle) * (player.radius + 4),
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 3,
            life: 1.4,
            damage,
            crit,
            slow: player.slowChance > 0 && Math.random() < player.slowChance,
            splashRadius,
            splashDamage,
            pierce,
            arcDamage: player.arcDamage || 0,
            arcRadius: player.arcRadius || 0,
            arcChains: player.arcChains || 0,
            arcRequiresSlow: !!player.arcRequiresSlow,
            isBarrage,
            tint
          });
        }
      }

      function fireEnemy(enemy, angle) {
        const accuracy = state.enemyAccuracyMod || 1;
        const jitter = (1 - accuracy) * 0.6;
        const bulletSpeed = enemy.baseBulletSpeed * (state.sectorMod?.enemy?.bulletSpeed || 1);
        const damage = enemy.baseDamage * (state.sectorMod?.enemy?.damage || 1);
        const pattern = enemy.pattern || "single";
        const spreadCount = enemy.spreadCount || (pattern === "spread" ? 5 : 1);
        const spreadAngle = Number.isFinite(enemy.spreadAngle)
          ? enemy.spreadAngle
          : (pattern === "spread" ? 0.18 : 0);
        const spread = spreadCount > 1 ? spreadAngle : 0;
        const bulletRadius = enemy.bulletRadius || 3;
        const bulletLife = enemy.bulletLife || 1.6;
        const bulletTint = enemy.bulletTint || null;
        const baseAngle = angle - spread * (spreadCount - 1) * 0.5;
        for (let i = 0; i < spreadCount; i += 1) {
          const shotAngle = baseAngle + spread * i + rand(-jitter, jitter);
          bullets.push({
            owner: "enemy",
            x: enemy.x + Math.cos(shotAngle) * (enemy.radius + 4),
            y: enemy.y + Math.sin(shotAngle) * (enemy.radius + 4),
            vx: Math.cos(shotAngle) * bulletSpeed,
            vy: Math.sin(shotAngle) * bulletSpeed,
            radius: bulletRadius,
            life: bulletLife,
            damage,
            slowPlayer: !!enemy.bulletSlowPlayer,
            slowDuration: enemy.bulletSlowDuration || 1.4,
            tint: bulletTint
          });
        }
      }

      function applyDamage(target, amount, bullet) {
        if (target === player && player.invulnerable > 0) {
          return;
        }
        const hadShield = target.shield > 0;
        const mitigation = target.damageReduction || 0;
        let finalDamage = amount * (1 - mitigation);
        let shieldDamage = 0;
        let hullDamage = 0;
        if (target.shield > 0) {
          const absorbed = Math.min(target.shield, finalDamage);
          target.shield -= absorbed;
          finalDamage -= absorbed;
          shieldDamage = absorbed;
          if (progress.settings.hitFlash) {
            target.hitFlash = 0.15;
          }
        }
        if (finalDamage > 0) {
          target.health -= finalDamage;
          hullDamage = finalDamage;
          if (progress.settings.hitFlash) {
            target.hitFlash = 0.2;
          }
          if (target === player) {
            state.lastHullHitAt = performance.now();
            resetNoDamageContracts();
          }
        }
        if (target.health < 0) {
          target.health = 0;
        }
        if (shieldDamage > 0) {
          spawnDamageNumber(target.x, target.y - target.radius - 12, shieldDamage, { color: "#57e0ff", prefix: "-" });
        }
        if (hullDamage > 0) {
          spawnDamageNumber(target.x, target.y - target.radius - 22, hullDamage, { color: "#f06969", prefix: "-" });
        }
        if (target === player) {
          player.shieldCooldown = 1.6;
          if (hadShield && target.shield <= 0) {
            triggerAegisMatrix();
          }
          if (bullet && bullet.slowPlayer) {
            const slowDuration = bullet.slowDuration || 1.4;
            player.slowTimer = Math.max(player.slowTimer || 0, slowDuration);
          }
        }
        if (bullet && bullet.slow && target !== player) {
          target.slowTimer = player.slowDuration;
        }
      }

      function applyHullHeal(target, amount) {
        if (!target || amount <= 0) return;
        const before = target.health;
        target.health = Math.min(target.maxHealth, target.health + amount);
        const delta = target.health - before;
        if (delta > 0) {
          spawnDamageNumber(target.x, target.y - target.radius - 12, delta, { color: "#6ee7b7", prefix: "+" });
        }
      }

      function applyShieldHeal(target, amount) {
        if (!target || amount <= 0) return;
        const before = target.shield;
        target.shield = Math.min(target.maxShield, target.shield + amount);
        const delta = target.shield - before;
        if (delta > 0) {
          spawnDamageNumber(target.x, target.y - target.radius - 18, delta, { color: "#57e0ff", prefix: "+" });
        }
      }

      function triggerAegisMatrix() {
        if (!player || !player.aegisCooldown) return;
        const now = performance.now();
        if (player.aegisReadyAt && now < player.aegisReadyAt) return;
        player.aegisReadyAt = now + player.aegisCooldown * 1000;
        if (player.aegisShieldRestore > 0) {
          const targetShield = player.maxShield * player.aegisShieldRestore;
          applyShieldHeal(player, targetShield - player.shield);
        }
        player.invulnerable = Math.max(player.invulnerable, 1.4);
        if (player.aegisPulseRadius > 0) {
          spawnPulse(player.x, player.y, "#f6c65f", player.aegisPulseRadius);
        }
        if (player.aegisPulseDamage > 0 || player.aegisPulseSlow > 0) {
          for (let i = enemies.length - 1; i >= 0; i -= 1) {
            const enemy = enemies[i];
            if (distanceBetween(player, enemy) <= player.aegisPulseRadius) {
              if (player.aegisPulseDamage > 0) {
                applyDamage(enemy, player.aegisPulseDamage, { owner: "player" });
              }
              if (player.aegisPulseSlow > 0) {
                enemy.slowTimer = Math.max(enemy.slowTimer, player.aegisPulseSlow);
              }
              if (enemy.health <= 0) {
                destroyEnemy(enemy, i);
              }
            }
          }
        }
        logEvent("Aegis Matrix surge activated.");
      }

      function destroyEnemy(enemy, index) {
        enemies.splice(index, 1);
        state.score += enemy.score;
        state.kills += 1;
        spawnExplosion(enemy.x, enemy.y, enemy.color);
        if (!state.training) {
          const difficulty = getDifficultySettings();
          const creditsGain = Math.round(enemy.credits * (1 + player.salvageBonus) * difficulty.reward);
          const xpGain = Math.round((10 + state.wave * 2) * (1 + player.xpBonus) * difficulty.reward);
          state.credits += creditsGain;
          progress.totalKills += 1;
          awardXp(xpGain);
          updateKillContracts(enemy);
          maybeDropLoot(enemy);
          saveProgress();
          renderShipyard();
          renderArmory();
          renderContracts();
        }
        if (player.healOnKill > 0) {
          applyHullHeal(player, player.maxHealth * player.healOnKill);
        }
        if (player.energyOnKill > 0) {
          player.energy = Math.min(player.maxEnergy, player.energy + player.energyOnKill);
        }
      }

      function awardXp(amount) {
        progress.xp += amount;
        let leveled = false;
        while (progress.xp >= xpToNext(progress.rank)) {
          progress.xp -= xpToNext(progress.rank);
          progress.rank += 1;
          progress.techPoints += 1;
          leveled = true;
        }
        if (leveled) {
          logEvent(`Rank up. Pilot rank is now ${progress.rank}.`);
          renderHangar();
        }
        checkProgressionUnlocks();
        saveProgress();
      }

      function getRunSummary() {
        const durationSec = state.runStart ? Math.max(1, (performance.now() - state.runStart) / 1000) : 0;
        const difficulty = DIFFICULTY_SETTINGS[state.difficulty] || DIFFICULTY_SETTINGS.normal;
        const rewardMultiplier = getDifficultySettings().reward;
        return {
          wave: Math.max(1, state.wave),
          kills: state.kills,
          score: Math.round(state.score),
          credits: Math.round(state.credits),
          durationSec,
          difficultyLabel: difficulty.label,
          rewardMultiplier
        };
      }

      function getPerformanceScore(summary) {
        const minutes = summary.durationSec / 60;
        const waveScore = Math.max(0, summary.wave - 1) * 1.1;
        const killScore = summary.kills * 0.08;
        const scoreScore = summary.score / 1200;
        const timeScore = minutes * 0.8;
        return (waveScore + killScore + scoreScore + timeScore) * summary.rewardMultiplier;
      }

      function getPerformanceTier(score) {
        if (score >= 24) return "legendary";
        if (score >= 18) return "epic";
        if (score >= 12) return "rare";
        if (score >= 6) return "uncommon";
        return "common";
      }

      function buildLossRewards() {
        const summary = getRunSummary();
        const performanceScore = getPerformanceScore(summary);
        const performanceTier = getPerformanceTier(performanceScore);
        const tierIndex = Math.max(0, TIER_ORDER.indexOf(performanceTier));
        const minutes = summary.durationSec / 60;
        const creditBase = 40
          + summary.wave * 12
          + summary.kills * 2
          + summary.score / 140
          + minutes * 12;
        const creditBonus = Math.round(creditBase * (1 + tierIndex * 0.18) * summary.rewardMultiplier);
        const blueprintCount = clamp(
          Math.floor(Math.max(0, summary.wave - 1) / 3) + (tierIndex >= 2 ? 1 : 0),
          0,
          tierIndex >= 4 ? 3 : 2
        );
        const salvageCount = clamp(
          Math.floor(summary.kills / 25) + (tierIndex >= 1 ? 1 : 0),
          0,
          tierIndex >= 3 ? 3 : 2
        );
        const partCount = (tierIndex >= 4 && summary.wave >= 8) ? 2 : (tierIndex >= 2 ? 1 : 0);
        const blueprintTier = tierIndex >= 3 ? "rare" : tierIndex >= 1 ? "uncommon" : "common";
        const salvageTier = tierIndex >= 3 ? "rare" : tierIndex >= 1 ? "uncommon" : "common";
        const partTier = tierIndex >= 4 ? "epic" : tierIndex >= 3 ? "epic" : tierIndex >= 2 ? "rare" : "uncommon";
        const rewards = [];
        if (creditBonus > 0) {
          rewards.push({
            type: "credits",
            amount: creditBonus,
            tier: performanceTier,
            title: "Recovery credits",
            desc: `${creditBonus.toLocaleString()} credits secured`
          });
        }
        if (blueprintCount > 0) {
          rewards.push({
            type: "blueprints",
            amount: blueprintCount,
            tier: blueprintTier,
            title: "Blueprint cache",
            desc: `+${blueprintCount} blueprint${blueprintCount === 1 ? "" : "s"}`
          });
        }
        if (salvageCount > 0) {
          rewards.push({
            type: "salvage",
            amount: salvageCount,
            tier: salvageTier,
            title: "Salvage keys",
            desc: `+${salvageCount} key${salvageCount === 1 ? "" : "s"}`
          });
        }
        const parts = [];
        for (let i = 0; i < partCount; i += 1) {
          const part = generatePart(partTier);
          if (part) {
            parts.push(part);
          }
        }
        parts.forEach((part) => {
          rewards.push({
            type: "part",
            amount: 1,
            tier: part.rarityId || getPartTier(part),
            title: part.name,
            desc: part.description,
            part
          });
        });
        return {
          tier: performanceTier,
          score: performanceScore,
          summary,
          rewards
        };
      }

      function applyLossRewards(result) {
        if (!result || !result.rewards) return;
        result.rewards.forEach((reward) => {
          if (reward.type === "credits") {
            progress.bankedCredits += reward.amount;
          }
          if (reward.type === "blueprints") {
            progress.blueprints += reward.amount;
          }
          if (reward.type === "salvage") {
            progress.salvageKeys += reward.amount;
          }
          if (reward.type === "part" && reward.part) {
            progress.partsInventory.unshift(reward.part);
            if (progress.partsInventory.length > 18) {
              progress.partsInventory.pop();
            }
          }
        });
        saveProgress();
        checkProgressionUnlocks();
        renderShipyard();
        renderArmory();
        renderContracts();
        if (result.rewards.length) {
          const summary = result.rewards.map((reward) => {
            if (reward.type === "part") return reward.title;
            if (reward.type === "credits") return `${reward.amount}c`;
            if (reward.type === "blueprints") {
              return `${reward.amount} blueprint${reward.amount === 1 ? "" : "s"}`;
            }
            if (reward.type === "salvage") {
              return `${reward.amount} key${reward.amount === 1 ? "" : "s"}`;
            }
            return `${reward.amount} ${reward.type}`;
          }).join(", ");
          logEvent(`Recovery rewards secured: ${summary}.`);
        }
      }

      function endRun(reason) {
        if (!state.runActive || state.runBanked) return;
        state.runActive = false;
        state.runBanked = true;
        if (state.frontier) {
          state.frontier.active = false;
        }
        if (state.training) return;
        const bankedCredits = Math.round(state.credits);
        progress.bankedCredits += bankedCredits;
        const difficultyLabel = (DIFFICULTY_SETTINGS[state.difficulty] || DIFFICULTY_SETTINGS.normal).label;
        const entry = {
          wave: state.wave,
          score: Math.round(state.score),
          credits: bankedCredits,
          kills: state.kills,
          ship: state.runLoadout?.ship || player?.ship?.name || "Unknown",
          weapon: state.runLoadout?.weapon || player?.weapon?.name || "Unknown",
          difficulty: difficultyLabel,
          mode: isFrontierMode() ? "Frontier" : "Arcade"
        };
        progress.runHistory = [entry, ...progress.runHistory].slice(0, 8);
        saveProgress();
        checkProgressionUnlocks();
        renderHistory();
        renderShipyard();
        renderArmory();
        renderContracts();
        if (bankedCredits > 0) {
          logEvent(`Run banked: ${bankedCredits} credits secured.`);
        }
      }

      function xpToNext(rank) {
        return Math.floor(120 + (rank - 1) * 80);
      }

      function triggerGameOver() {
        setMode("gameover");
        if (!state.training) {
          progress.bestWave = Math.max(progress.bestWave, state.wave);
          saveProgress();
        }
        endRun("wrecked");
        if (!state.training) {
          state.lossRewards = buildLossRewards();
          applyLossRewards(state.lossRewards);
        } else {
          state.lossRewards = null;
        }
        spawnExplosion(player.x, player.y, "#ffffff", 26);
        setOverlay("gameover");
        logEvent("Ship destroyed. Returning to hangar.");
      }

      function renderLootBursts() {
        if (!lootBursts.length) return;
        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "600 12px \"Chakra Petch\", sans-serif";
        lootBursts.forEach((burst) => {
          const alpha = clamp(burst.life / burst.maxLife, 0, 1);
          const color = TIER_COLORS[burst.tier] || "#e5f1ff";
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = "rgba(4, 8, 16, 0.8)";
          ctx.lineWidth = 3;
          ctx.strokeText(burst.label, burst.x, burst.y);
          ctx.fillStyle = color;
          ctx.fillText(burst.label, burst.x, burst.y);
        });
        ctx.restore();
        ctx.globalAlpha = 1;
      }

      function renderDamageNumbers() {
        if (!damageNumbers.length) return;
        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "700 13px \"Chakra Petch\", sans-serif";
        const useStroke = damageNumbers.length < 80;
        damageNumbers.forEach((burst) => {
          const alpha = clamp(burst.life / burst.maxLife, 0, 1);
          ctx.globalAlpha = alpha;
          if (useStroke) {
            ctx.strokeStyle = "rgba(4, 8, 16, 0.85)";
            ctx.lineWidth = 3;
            ctx.strokeText(burst.text, burst.x, burst.y);
          }
          ctx.fillStyle = burst.color;
          ctx.fillText(burst.text, burst.x, burst.y);
        });
        ctx.restore();
        ctx.globalAlpha = 1;
      }

      function renderObstacles() {
        if (!obstacles.length) return;
        const bounds = getViewportBounds();
        obstacles.forEach((obstacle) => {
          if (obstacle.kind === "rock") {
            const radius = obstacle.radius;
            if (obstacle.x + radius < bounds.left - 80 || obstacle.x - radius > bounds.right + 80
              || obstacle.y + radius < bounds.top - 80 || obstacle.y - radius > bounds.bottom + 80) {
              return;
            }
            const gradient = ctx.createRadialGradient(
              obstacle.x - radius * 0.3,
              obstacle.y - radius * 0.3,
              radius * 0.2,
              obstacle.x,
              obstacle.y,
              radius
            );
            const shade = obstacle.shade || 0.5;
            gradient.addColorStop(0, `rgba(140, 170, 195, ${0.4 + shade * 0.2})`);
            gradient.addColorStop(1, `rgba(30, 42, 60, ${0.8 + shade * 0.15})`);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(obstacle.x, obstacle.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
            ctx.lineWidth = 1.5;
            ctx.stroke();
            return;
          }
          const halfWidth = obstacle.width * 0.5;
          const halfHeight = obstacle.height * 0.5;
          if (obstacle.x + halfWidth < bounds.left - 80 || obstacle.x - halfWidth > bounds.right + 80
            || obstacle.y + halfHeight < bounds.top - 80 || obstacle.y - halfHeight > bounds.bottom + 80) {
            return;
          }
          const x = obstacle.x - halfWidth;
          const y = obstacle.y - halfHeight;
          ctx.fillStyle = `rgba(22, 34, 48, ${0.7 + (obstacle.shade || 0.3) * 0.2})`;
          ctx.fillRect(x, y, obstacle.width, obstacle.height);
          ctx.strokeStyle = "rgba(160, 190, 220, 0.12)";
          ctx.lineWidth = 1.5;
          ctx.strokeRect(x, y, obstacle.width, obstacle.height);
        });
      }

      function drawWorldBounds() {
        ctx.save();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.12)";
        ctx.lineWidth = 2;
        ctx.strokeRect(4, 4, state.worldWidth - 8, state.worldHeight - 8);
        ctx.restore();
      }

      function renderMinimap() {
        if (!minimapCtx || !dom.minimap) return;
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const width = dom.minimap.width / dpr;
        const height = dom.minimap.height / dpr;
        minimapCtx.clearRect(0, 0, width, height);
        if (!player || (state.mode !== "flight" && state.mode !== "training")) return;
        minimapCtx.fillStyle = "rgba(6, 10, 18, 0.9)";
        minimapCtx.fillRect(0, 0, width, height);

        const padding = 6;
        const mapWidth = width - padding * 2;
        const mapHeight = height - padding * 2;
        const scaleX = mapWidth / state.worldWidth;
        const scaleY = mapHeight / state.worldHeight;
        const scale = Math.min(scaleX, scaleY);
        const offsetX = (width - state.worldWidth * scale) * 0.5;
        const offsetY = (height - state.worldHeight * scale) * 0.5;

        minimapCtx.strokeStyle = "rgba(255, 255, 255, 0.18)";
        minimapCtx.lineWidth = 1;
        minimapCtx.strokeRect(offsetX, offsetY, state.worldWidth * scale, state.worldHeight * scale);

        minimapCtx.fillStyle = "rgba(140, 170, 195, 0.35)";
        obstacles.forEach((obstacle) => {
          if (obstacle.kind === "rock") {
            minimapCtx.beginPath();
            minimapCtx.arc(
              offsetX + obstacle.x * scale,
              offsetY + obstacle.y * scale,
              Math.max(2, obstacle.radius * scale),
              0,
              Math.PI * 2
            );
            minimapCtx.fill();
            return;
          }
          minimapCtx.fillRect(
            offsetX + (obstacle.x - obstacle.width * 0.5) * scale,
            offsetY + (obstacle.y - obstacle.height * 0.5) * scale,
            obstacle.width * scale,
            obstacle.height * scale
          );
        });

        minimapCtx.fillStyle = "#f06969";
        enemies.forEach((enemy) => {
          const x = offsetX + enemy.x * scale;
          const y = offsetY + enemy.y * scale;
          minimapCtx.fillRect(x - 1, y - 1, 2, 2);
        });

        minimapCtx.strokeStyle = "rgba(255, 255, 255, 0.35)";
        minimapCtx.strokeRect(
          offsetX + state.camera.x * scale,
          offsetY + state.camera.y * scale,
          state.width * scale,
          state.height * scale
        );

        minimapCtx.fillStyle = "#44d2c2";
        minimapCtx.beginPath();
        minimapCtx.arc(
          offsetX + player.x * scale,
          offsetY + player.y * scale,
          3,
          0,
          Math.PI * 2
        );
        minimapCtx.fill();
      }

      function render() {
        ctx.clearRect(0, 0, state.width, state.height);
        ctx.fillStyle = backgroundGradient || "#05090f";
        ctx.fillRect(0, 0, state.width, state.height);

        updateCamera();
        const bounds = getViewportBounds();
        ctx.save();
        ctx.translate(-state.camera.x, -state.camera.y);

        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        stars.forEach((star) => {
          if (star.x < bounds.left - 40 || star.x > bounds.right + 40
            || star.y < bounds.top - 40 || star.y > bounds.bottom + 40) {
            return;
          }
          ctx.globalAlpha = star.alpha;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;

        renderObstacles();

        particles.forEach((particle) => {
          ctx.globalAlpha = Math.max(0, particle.life / particle.maxLife);
          ctx.fillStyle = particle.color;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;

        pulses.forEach((pulse) => {
          ctx.globalAlpha = Math.max(0, pulse.life / pulse.maxLife);
          ctx.strokeStyle = pulse.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
          ctx.stroke();
        });
        ctx.globalAlpha = 1;

        if (player) {
          drawAura();
        }

        if (state.decoy) {
          ctx.strokeStyle = "rgba(246, 198, 95, 0.6)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(state.decoy.x, state.decoy.y, 12, 0, Math.PI * 2);
          ctx.stroke();
        }

        state.mines.forEach((mine) => {
          ctx.fillStyle = "rgba(246, 198, 95, 0.8)";
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, mine.radius * 0.5, 0, Math.PI * 2);
          ctx.fill();
        });

        bullets.forEach((bullet) => {
          let color = bullet.owner === "player" ? (bullet.crit ? "#f6c65f" : "#6ee7b7") : "#f06969";
          if (bullet.tint) {
            color = bullet.tint;
          }
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        enemies.forEach((enemy) => {
          drawShip(enemy.x, enemy.y, enemy.angle, enemy.radius, enemy.color, enemy.hitFlash > 0);
          drawShield(enemy);
          drawEnemyVitals(enemy);
        });

        if (player) {
          drawShip(player.x, player.y, player.angle, player.radius, "#44d2c2", player.hitFlash > 0, player.thrusting);
          drawShield(player);
        }

        renderHelpers();
        renderLootBursts();
        renderDamageNumbers();
        drawWorldBounds();
        drawCrosshair();
        ctx.restore();

        renderMinimap();
      }

      function drawAura() {
        if (!player || player.auraRadius <= 0 || player.auraDamage <= 0) return;
        if (state.mode !== "flight" && state.mode !== "training") return;
        ctx.save();
        ctx.strokeStyle = "rgba(124, 168, 255, 0.4)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.auraRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function renderHelpers() {
        if (!helpers.length || (state.mode !== "flight" && state.mode !== "training")) return;
        helpers.forEach((helper) => {
          ctx.save();
          ctx.translate(helper.x, helper.y);
          ctx.fillStyle = "#6ee7b7";
          ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(6, 0);
          ctx.lineTo(-4, 4);
          ctx.lineTo(-4, -4);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        });
      }

      function drawShip(x, y, angle, size, color, hitFlash, thrusting) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        if (thrusting) {
          ctx.fillStyle = "rgba(246, 198, 95, 0.8)";
          ctx.beginPath();
          ctx.moveTo(-size * 0.8, 0);
          ctx.lineTo(-size * 1.4, size * 0.5);
          ctx.lineTo(-size * 1.6, 0);
          ctx.lineTo(-size * 1.4, -size * 0.5);
          ctx.closePath();
          ctx.fill();
        }

        ctx.fillStyle = hitFlash ? "#ffffff" : color;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size * 0.7, size * 0.7);
        ctx.lineTo(-size * 0.4, 0);
        ctx.lineTo(-size * 0.7, -size * 0.7);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.restore();
      }

      function drawShield(entity) {
        if (entity.maxShield <= 0 || entity.shield <= 0) return;
        const ratio = entity.shield / entity.maxShield;
        ctx.save();
        ctx.globalAlpha = 0.2 + ratio * 0.4;
        ctx.strokeStyle = entity === player ? "#57e0ff" : "#f6c65f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(entity.x, entity.y, entity.radius + 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function drawEnemyVitals(enemy) {
        if (!enemy) return;
        const barWidth = Math.max(26, enemy.radius * 3.2);
        const barHeight = 4;
        const gap = 2;
        const hasShield = enemy.maxShield > 0;
        const totalHeight = barHeight + (hasShield ? barHeight + gap : 0);
        const x = enemy.x - barWidth / 2;
        let y = enemy.y - enemy.radius - 12 - totalHeight;
        y = Math.max(6, y);
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "rgba(5, 8, 14, 0.7)";
        ctx.fillRect(x - 1, y - 1, barWidth + 2, totalHeight + 2);
        if (hasShield) {
          const shieldRatio = clamp(enemy.shield / enemy.maxShield, 0, 1);
          ctx.fillStyle = "#57e0ff";
          ctx.fillRect(x, y, barWidth * shieldRatio, barHeight);
          y += barHeight + gap;
        }
        const hullRatio = clamp(enemy.health / enemy.maxHealth, 0, 1);
        ctx.fillStyle = "#f06969";
        ctx.fillRect(x, y, barWidth * hullRatio, barHeight);
        ctx.restore();
      }

      function drawCrosshair() {
        const target = getAimTarget();
        const aimX = target.x;
        const aimY = target.y;
        ctx.save();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.35)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(aimX, aimY, 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function updateHud() {
        const now = performance.now();
        if (now - state.lastHudUpdate < HUD_UPDATE_INTERVAL_MS) {
          return;
        }
        state.lastHudUpdate = now;
        if (!player) return;
        const hullPct = clamp(player.health / player.maxHealth, 0, 1) * 100;
        const shieldPct = player.maxShield > 0 ? clamp(player.shield / player.maxShield, 0, 1) * 100 : 0;
        const energyPct = clamp(player.energy / player.maxEnergy, 0, 1) * 100;
        meters.hull.style.width = `${hullPct}%`;
        meters.shield.style.width = `${shieldPct}%`;
        meters.energy.style.width = `${energyPct}%`;
        if (hudMeters.hull) hudMeters.hull.style.width = `${hullPct}%`;
        if (hudMeters.shield) hudMeters.shield.style.width = `${shieldPct}%`;
        if (hudMeters.energy) hudMeters.energy.style.width = `${energyPct}%`;

        stats.hullText.textContent = `${Math.round(player.health)} / ${Math.round(player.maxHealth)}`;
        stats.shieldText.textContent = player.maxShield > 0
          ? `${Math.round(player.shield)} / ${Math.round(player.maxShield)}`
          : "0 / 0";
        stats.energyText.textContent = `${Math.round(player.energy)} / ${Math.round(player.maxEnergy)}`;
        if (hudStats.hull) {
          hudStats.hull.textContent = `${Math.round(player.health)}/${Math.round(player.maxHealth)}`;
        }
        if (hudStats.shield) {
          hudStats.shield.textContent = player.maxShield > 0
            ? `${Math.round(player.shield)}/${Math.round(player.maxShield)}`
            : "0/0";
        }
        if (hudStats.energy) {
          hudStats.energy.textContent = `${Math.round(player.energy)}/${Math.round(player.maxEnergy)}`;
        }

        stats.wave.textContent = state.wave;
        stats.enemyCount.textContent = enemies.length;
        stats.score.textContent = Math.round(state.score).toLocaleString();
        stats.credits.textContent = Math.round(state.credits).toLocaleString();
        if (stats.modeLabel) {
          stats.modeLabel.textContent = isFrontierMode() ? "Frontier" : "Arcade";
        }
        if (dom.tierPill && stats.tier) {
          const showTier = isFrontierMode() && state.frontier && state.frontier.active;
          dom.tierPill.hidden = !showTier;
          if (showTier) {
            stats.tier.textContent = state.frontier.tier || 1;
          }
        }

        stats.rank.textContent = progress.rank;
        stats.xp.textContent = `${Math.round(progress.xp)} / ${xpToNext(progress.rank)}`;
        stats.techPoints.textContent = progress.techPoints;
        stats.bestWave.textContent = progress.bestWave;
        stats.totalKills.textContent = progress.totalKills;
        stats.bankedCredits.textContent = `Credits ${Math.round(progress.bankedCredits)}`;
        stats.bankedCreditsTotal.textContent = Math.round(progress.bankedCredits).toLocaleString();
        stats.blueprints.textContent = `Blueprints ${progress.blueprints}`;
        stats.salvageKeys.textContent = `Keys ${progress.salvageKeys || 0}`;

        stats.damage.textContent = Math.round(player.damage);
        stats.fireRate.textContent = `${player.fireRate.toFixed(1)} / sec`;
        stats.speed.textContent = Math.round(player.maxSpeed);
        stats.shieldRegen.textContent = `${player.shieldRegen.toFixed(1)} / sec`;
        stats.energyRegen.textContent = `${player.energyRegen.toFixed(1)} / sec`;
        stats.crit.textContent = `${Math.round(player.critChance * 100)}%`;

        stats.shipName.textContent = player.ship ? player.ship.name : "-";
        stats.weaponName.textContent = player.weapon ? player.weapon.name : "-";
        stats.secondaryName.textContent = isFeatureUnlocked("secondary")
          ? (player.secondary ? player.secondary.name : "-")
          : "Locked";
        stats.sector.textContent = `Sector ${state.sector.toString().padStart(2, "0")}`;
        stats.sectorMod.textContent = state.sectorMod ? state.sectorMod.name : "Clear";
        if (!isFeatureUnlocked("contracts")) {
          stats.contractStatus.textContent = "Locked";
        } else if (!state.contracts.length) {
          stats.contractStatus.textContent = "Offline";
        } else {
          const activeCount = state.contracts.filter((contract) => !contract.complete).length;
          stats.contractStatus.textContent = activeCount ? `${activeCount} Active` : "Complete";
        }
        stats.controlMode.textContent = progress.settings.inputMode === "keyboard" ? "Keyboard" : "Hybrid";

        if (!isFeatureUnlocked("ability")) {
          stats.abilityStatus.textContent = "Locked";
        } else {
          const abilityReady = player.abilityCooldown <= 0 && player.abilityTimer <= 0;
          stats.abilityStatus.textContent = player.abilityTimer > 0
            ? "Active"
            : abilityReady
              ? "Ready"
              : `CD ${Math.ceil(player.abilityCooldown)}s`;
        }

        if (!isFeatureUnlocked("secondary")) {
          stats.secondaryStatus.textContent = "Locked";
        } else {
          const secondaryReady = player.secondaryCooldown <= 0;
          stats.secondaryStatus.textContent = secondaryReady ? "Ready" : `CD ${Math.ceil(player.secondaryCooldown)}s`;
        }

        renderActiveUpgrades();
      }

      function renderActiveUpgrades() {
        const upgradeKey = getActiveUpgradeKey();
        if (upgradeKey === state.activeUpgradeKey) {
          return;
        }
        state.activeUpgradeKey = upgradeKey;
        if (isFrontierMode()) {
          if (!state.frontier || !state.frontier.active) {
            dom.activeUpgrades.innerHTML = "<span class=\"chip\">Frontier upgrades available at the dock</span>";
            return;
          }
          const entries = FRONTIER_UPGRADES.filter((upgrade) => state.frontier.upgrades[upgrade.id]);
          if (!entries.length) {
            dom.activeUpgrades.innerHTML = "<span class=\"chip\">No frontier upgrades yet</span>";
            return;
          }
          dom.activeUpgrades.innerHTML = entries.map((upgrade) => {
            const level = state.frontier.upgrades[upgrade.id] || 0;
            const tier = upgrade.tier || "common";
            return `<span class=\"chip\" data-tier="${tier}">${upgrade.name} Lv ${level}</span>`;
          }).join("");
          return;
        }
        if (!isFeatureUnlocked("upgrades")) {
          dom.activeUpgrades.innerHTML = "<span class=\"chip\">Field upgrades locked</span>";
          return;
        }
        const entries = FIELD_UPGRADES.filter((upgrade) => state.upgradeStacks[upgrade.id]);
        const skillEntries = entries.filter((upgrade) => isSkillUpgrade(upgrade));
        const statEntries = entries.filter((upgrade) => !isSkillUpgrade(upgrade));
        const renderChips = (list) => list.map((upgrade) => {
          const stack = state.upgradeStacks[upgrade.id] || 0;
          const isSkill = isSkillUpgrade(upgrade);
          const label = isSkill ? `${upgrade.name} Lv ${stack}` : (stack > 1 ? `${upgrade.name} x${stack}` : upgrade.name);
          const tier = getUpgradeTier(upgrade, stack);
          return `<span class=\"chip\" data-tier="${tier}">${label}</span>`;
        }).join("");
        const skillHtml = `
          <div class="upgrade-group">
            <span class="upgrade-group-title">Skill systems (${state.skillSlots.length}/${SKILL_LIMIT})</span>
            <div class="chip-list">
              ${skillEntries.length ? renderChips(skillEntries) : "<span class=\"chip\">No skills selected</span>"}
            </div>
          </div>
        `;
        const statHtml = `
          <div class="upgrade-group">
            <span class="upgrade-group-title">Field upgrades</span>
            <div class="chip-list">
              ${statEntries.length ? renderChips(statEntries) : "<span class=\"chip\">No stat upgrades yet</span>"}
            </div>
          </div>
        `;
        dom.activeUpgrades.innerHTML = `${skillHtml}${statHtml}`;
      }

      function getActiveUpgradeKey() {
        if (isFrontierMode()) {
          if (!state.frontier || !state.frontier.upgrades) return "frontier:none";
          const entries = Object.entries(state.frontier.upgrades)
            .filter(([, level]) => level > 0)
            .sort((a, b) => a[0].localeCompare(b[0]))
            .map(([id, level]) => `${id}:${level}`)
            .join("|");
          return `frontier:${entries}`;
        }
        const stacks = Object.entries(state.upgradeStacks || {})
          .filter(([, count]) => count > 0)
          .sort((a, b) => a[0].localeCompare(b[0]))
          .map(([id, count]) => `${id}:${count}`)
          .join("|");
        return `arcade:${state.skillSlots.join(",")}:${stacks}`;
      }

      function renderHangar() {
        if (!isFeatureUnlocked("hangar")) {
          dom.hangar.innerHTML = renderLockedCard("Hangar upgrades locked", getFeatureHint("hangar"));
          return;
        }
        const grouped = {};
        HANGAR_UPGRADES.forEach((upgrade) => {
          const category = upgrade.category || "Utility";
          if (!grouped[category]) grouped[category] = [];
          grouped[category].push(upgrade);
        });
        const categoryOrder = ["Defense", "Offense", "Mobility", "Utility", "Strategy", "Systems", "Control"];
        const sortedCategories = Object.keys(grouped).sort((a, b) => {
          const aIndex = categoryOrder.indexOf(a);
          const bIndex = categoryOrder.indexOf(b);
          if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);
          if (aIndex === -1) return 1;
          if (bIndex === -1) return -1;
          return aIndex - bIndex;
        });
        dom.hangar.innerHTML = sortedCategories.map((category) => {
          const items = grouped[category] || [];
          items.sort((a, b) => {
            const tierA = a.tier || "common";
            const tierB = b.tier || "common";
            const tierIndexA = TIER_ORDER.indexOf(tierA);
            const tierIndexB = TIER_ORDER.indexOf(tierB);
            if (tierIndexA !== tierIndexB) return tierIndexA - tierIndexB;
            return a.name.localeCompare(b.name);
          });
          const categoryIcon = getUpgradeCategoryIcon(category);
          const categoryKey = normalizeCategory(category);
          return `
            <div class="tier-section">
              <div class="tier-header">
                <span class="tier-title">
                  <span class="select-pill category-pill" data-category="${categoryKey}" aria-label="${category}" title="${category}">${categoryIcon}</span>
                  ${category}
                </span>
                <span class="tier-count">${items.length} upgrade${items.length === 1 ? "" : "s"}</span>
              </div>
              <div class="card-grid">
                ${items.map((upgrade) => {
                  const level = progress.hangar[upgrade.id] || 0;
                  const maxLevel = upgrade.maxLevel || 1;
                  const tier = upgrade.tier || "common";
                  const tierLabel = formatTierLabel(tier);
                  const cost = getHangarUpgradeCost(upgrade, level);
                  const canBuy = level < maxLevel && progress.techPoints >= cost;
                  const costLabel = level >= maxLevel ? "Maxed" : `Cost ${cost} tech`;
                  return `
                    <button class="hangar-card" data-tier="${tier}" data-hangar-id="${upgrade.id}" ${canBuy ? "" : "disabled"}>
                      <span class="hangar-title">${upgrade.name}</span>
                      <span class="hangar-meta">${upgrade.desc}</span>
                      <div class="select-pills">
                        <span class="select-pill tier-pill" data-tier="${tier}">${tierLabel}</span>
                        <span class="select-pill">Level ${level}/${maxLevel}</span>
                        <span class="select-pill">${costLabel}</span>
                      </div>
                    </button>
                  `;
                }).join("")}
              </div>
            </div>
          `;
        }).join("");
      }

      function renderShipyard() {
        if (!dom.shipyard) return;
        if (!isFeatureUnlocked("shipyard")) {
          dom.shipyard.innerHTML = renderLockedCard("Shipyard locked", getFeatureHint("shipyard"));
          return;
        }
        const tierGroup = document.querySelector("[data-setting='shipyard-tier']");
        let tierFilter = progress.settings.shipyardTier || "all";
        if (tierGroup && !tierGroup.querySelector(`[data-option="${tierFilter}"]`)) {
          tierFilter = "all";
          progress.settings.shipyardTier = "all";
          saveProgress();
        }
        if (tierGroup) {
          tierGroup.querySelectorAll(".option-btn").forEach((btn) => {
            btn.classList.toggle("is-active", btn.dataset.option === tierFilter);
          });
        }
        const filteredShips = tierFilter === "all"
          ? SHIPS
          : SHIPS.filter((ship) => String(Number(ship.tier) || 1) === tierFilter);
        const renderShipCard = (ship) => {
          const unlocked = !!progress.shipUnlocks[ship.id];
          const selected = progress.selectedShip === ship.id;
          const unlockable = canUnlock(ship, progress.shipUnlocks);
          const disabled = !unlocked && !unlockable ? "disabled" : "";
          const statusLabel = unlocked ? (selected ? "Active" : "Select") : (unlockable ? "Unlock" : "Locked");
          const unlockText = formatUnlockText(ship.unlock);
          const signatureWeapon = ship.signatureWeapon ? getWeaponById(ship.signatureWeapon).name : "";
          const shipTierValue = Number(ship.tier) || 1;
          const tierStyle = getShipTierStyle(shipTierValue);
          const tierPill = ship.tier ? `<span class="select-pill tier-pill" data-tier="${tierStyle}">Tier ${shipTierValue}</span>` : "";
          const tierAttr = ship.tier ? `data-tier="${tierStyle}"` : "";
          return `
            <button class="select-card ${selected ? "is-active" : ""}" ${tierAttr} data-ship-id="${ship.id}" ${disabled}>
              <span class="select-title">${ship.name}</span>
              <span class="select-meta">${ship.desc}</span>
              ${signatureWeapon ? `<span class="select-meta">Signature: ${signatureWeapon}</span>` : ""}
              <span class="select-meta">Passive: ${ship.passive}</span>
              <div class="select-pills">
                ${tierPill}
                <span class="select-pill">${ABILITIES[ship.abilityId].name}</span>
                <span class="select-pill">${statusLabel}</span>
                ${unlockText ? `<span class="select-pill">${unlockText}</span>` : ""}
              </div>
            </button>
          `;
        };
        if (!filteredShips.length) {
          dom.shipyard.innerHTML = "<span class=\"select-meta\">No ships available for this tier yet.</span>";
          return;
        }
        if (tierFilter === "all") {
          const shipsByTier = {};
          filteredShips.forEach((ship) => {
            const shipTierValue = Number(ship.tier) || 1;
            if (!shipsByTier[shipTierValue]) shipsByTier[shipTierValue] = [];
            shipsByTier[shipTierValue].push(ship);
          });
          const tiers = Object.keys(shipsByTier).map(Number).sort((a, b) => a - b);
          dom.shipyard.innerHTML = tiers.map((tier) => {
            const items = shipsByTier[tier] || [];
            return `
              <div class="tier-section">
                <div class="tier-header">
                  <span class="tier-title">Tier ${tier}</span>
                  <span class="tier-count">${items.length} ship${items.length === 1 ? "" : "s"}</span>
                </div>
                <div class="card-grid">
                  ${items.map(renderShipCard).join("")}
                </div>
              </div>
            `;
          }).join("");
          return;
        }
        dom.shipyard.innerHTML = filteredShips.map(renderShipCard).join("");
      }

      function renderArmory() {
        if (!dom.weapons) return;
        if (!isFeatureUnlocked("armory")) {
          dom.weapons.innerHTML = renderLockedCard("Armory locked", getFeatureHint("armory"));
          dom.weaponUpgrades.innerHTML = renderLockedCard("Weapon upgrades locked", getFeatureHint("weaponUpgrades"));
          dom.secondaries.innerHTML = renderLockedCard("Secondary bay locked", getFeatureHint("armory"));
          dom.partsSlots.innerHTML = renderLockedCard("Parts bay locked", getFeatureHint("parts"));
          dom.partsInventory.innerHTML = "";
          renderSalvage();
          return;
        }
        const weapon = getWeaponById(progress.selectedWeapon);
        const weaponGroups = groupByTier(WEAPONS);
        dom.weapons.innerHTML = weaponGroups.map((group) => {
          return renderTierSection(group.tier, group.items, (item) => {
            const unlocked = !!progress.weaponUnlocks[item.id];
            const selected = progress.selectedWeapon === item.id;
            const unlockable = canUnlock(item, progress.weaponUnlocks);
            const disabled = !unlocked && !unlockable ? "disabled" : "";
            const statusLabel = unlocked ? (selected ? "Equipped" : "Select") : (unlockable ? "Unlock" : "Locked");
            const unlockText = formatUnlockText(item.unlock);
            const tier = item.tier || "common";
            const tierLabel = formatTierLabel(tier);
            const comparison = selected ? "" : buildWeaponComparison(weapon, item);
            const compareBlock = comparison ? `<div class="compare-list">${comparison}</div>` : "";
            return `
              <button class="select-card ${selected ? "is-active" : ""}" data-tier="${tier}" data-weapon-id="${item.id}" ${disabled}>
                <span class="select-title">${item.name}</span>
                <span class="select-meta">${item.desc}</span>
                ${compareBlock}
                <div class="select-pills">
                  <span class="select-pill tier-pill" data-tier="${tier}">${tierLabel}</span>
                  ${item.tags.map((tag) => `<span class="select-pill">${tag}</span>`).join("")}
                  <span class="select-pill">${statusLabel}</span>
                  ${unlockText ? `<span class="select-pill">${unlockText}</span>` : ""}
                </div>
              </button>
            `;
          });
        }).join("");

        if (!isFeatureUnlocked("weaponUpgrades")) {
          dom.weaponUpgrades.innerHTML = renderLockedCard("Weapon upgrades locked", getFeatureHint("weaponUpgrades"));
        } else {
          dom.weaponUpgrades.innerHTML = (weapon.upgrades || []).map((upgrade, index) => {
            const level = progress.weaponLevels[weapon.id] || 0;
            const owned = index < level;
            const next = index === level;
            const canBuy = next && progress.bankedCredits >= upgrade.cost;
            const status = owned ? "Installed" : (next ? `Upgrade (${upgrade.cost})` : "Locked");
            const disabled = owned || !canBuy ? "disabled" : "";
            const tier = upgrade.tier || "common";
            const tierLabel = formatTierLabel(tier);
            return `
              <button class="upgrade-card" data-tier="${tier}" data-weapon-upgrade="${index}" ${disabled}>
                <div class="upgrade-meta">
                  <span class="select-pill tier-pill" data-tier="${tier}">${tierLabel}</span>
                  <span class="select-pill">${status}</span>
                </div>
                <span class="upgrade-title">${upgrade.name}</span>
                <span class="upgrade-desc">${upgrade.desc}</span>
              </button>
            `;
          }).join("") || "<span class=\"select-meta\">No upgrades available.</span>";
        }

        if (!isFeatureUnlocked("secondary")) {
          dom.secondaries.innerHTML = renderLockedCard("Secondary systems locked", getFeatureHint("secondary"));
        } else {
          const currentSecondary = getSecondaryById(progress.selectedSecondary);
          const secondaryGroups = groupByTier(SECONDARIES);
          dom.secondaries.innerHTML = secondaryGroups.map((group) => {
            return renderTierSection(group.tier, group.items, (item) => {
              const unlocked = !!progress.secondaryUnlocks[item.id];
              const selected = progress.selectedSecondary === item.id;
              const unlockable = canUnlock(item, progress.secondaryUnlocks);
              const disabled = !unlocked && !unlockable ? "disabled" : "";
              const statusLabel = unlocked ? (selected ? "Equipped" : "Select") : (unlockable ? "Unlock" : "Locked");
              const unlockText = formatUnlockText(item.unlock);
              const tier = item.tier || "common";
              const tierLabel = formatTierLabel(tier);
              const comparison = selected ? "" : buildSecondaryComparison(currentSecondary, item);
              const compareBlock = comparison ? `<div class="compare-list">${comparison}</div>` : "";
              return `
                <button class="select-card ${selected ? "is-active" : ""}" data-tier="${tier}" data-secondary-id="${item.id}" ${disabled}>
                  <span class="select-title">${item.name}</span>
                  <span class="select-meta">${item.desc}</span>
                  ${compareBlock}
                  <div class="select-pills">
                    <span class="select-pill tier-pill" data-tier="${tier}">${tierLabel}</span>
                    <span class="select-pill">Cooldown ${item.cooldown}s</span>
                    <span class="select-pill">${statusLabel}</span>
                    ${unlockText ? `<span class="select-pill">${unlockText}</span>` : ""}
                  </div>
                </button>
              `;
            });
          }).join("");
        }

        renderParts();
        renderSalvage();
      }

      function renderParts() {
        if (!isFeatureUnlocked("parts")) {
          dom.partsSlots.innerHTML = renderLockedCard("Parts bay locked", getFeatureHint("parts"));
          dom.partsInventory.innerHTML = "";
          return;
        }
        const partsModeGroup = document.querySelector("[data-setting='parts-mode']");
        const partsMode = progress.settings.partsMode || "equip";
        if (partsModeGroup) {
          partsModeGroup.querySelectorAll(".option-btn").forEach((btn) => {
            btn.classList.toggle("is-active", btn.dataset.option === partsMode);
          });
        }
        const equipped = progress.equippedParts || {};
        dom.partsSlots.innerHTML = PART_SLOTS.map((slot) => {
          const part = progress.partsInventory.find((item) => item.id === equipped[slot]);
          const tier = part ? getPartTier(part) : "common";
          const tierLabel = part ? formatTierLabel(tier) : "";
          const tierAttr = part ? `data-tier="${tier}"` : "";
          const statusLabel = part ? "Equipped" : "Empty";
          return `
            <button class="select-card ${part ? "is-active" : ""}" ${tierAttr} data-part-slot="${slot}">
              <span class="select-title">${slot.charAt(0).toUpperCase() + slot.slice(1)} Slot</span>
              <span class="select-meta">${part ? `${part.name} (${part.rarity})` : "Empty"}</span>
              <span class="select-meta">${part ? part.description : "Tap to unequip or select a part."}</span>
              <div class="select-pills">
                ${part ? `<span class="select-pill tier-pill" data-tier="${tier}">${tierLabel}</span>` : ""}
                <span class="select-pill">${statusLabel}</span>
              </div>
            </button>
          `;
        }).join("");

        if (!progress.partsInventory.length) {
          dom.partsInventory.innerHTML = "<span class=\"select-meta\">No parts collected yet.</span>";
          return;
        }

        const partsWithTier = progress.partsInventory.map((part) => ({
          ...part,
          tier: getPartTier(part)
        }));
        const partGroups = groupByTier(partsWithTier);
        dom.partsInventory.innerHTML = partGroups.map((group) => {
          return renderTierSection(group.tier, group.items, (part) => {
            const equippedSlot = Object.keys(progress.equippedParts).find((slot) => progress.equippedParts[slot] === part.id);
            const scrapValue = getPartScrapValue(part);
            const status = partsMode === "dismantle"
              ? `Scrap ${scrapValue}c${equippedSlot ? " (equipped)" : ""}`
              : (equippedSlot ? `Equipped (${equippedSlot})` : "Equip");
            const disabled = partsMode === "equip" && equippedSlot ? "disabled" : "";
            const tier = part.tier || "common";
            const tierLabel = formatTierLabel(tier);
            const equippedId = progress.equippedParts[part.slot];
            const equippedPart = progress.partsInventory.find((item) => item.id === equippedId);
            const comparison = equippedSlot ? "" : buildPartComparison(part, equippedPart);
            const compareBlock = comparison ? `<div class="compare-list">${comparison}</div>` : "";
            return `
              <button class="select-card" data-tier="${tier}" data-part-id="${part.id}" ${disabled}>
                <span class="select-title">${part.name}</span>
                <span class="select-meta">${part.description}</span>
                ${compareBlock}
                <div class="select-pills">
                  <span class="select-pill tier-pill" data-tier="${tier}">${tierLabel}</span>
                  <span class="select-pill">${status}</span>
                </div>
              </button>
            `;
          });
        }).join("");
      }

      function dismantlePart(partId) {
        const index = progress.partsInventory.findIndex((part) => part.id === partId);
        if (index === -1) return;
        const part = progress.partsInventory[index];
        const scrapValue = getPartScrapValue(part);
        progress.partsInventory.splice(index, 1);
        Object.keys(progress.equippedParts).forEach((slot) => {
          if (progress.equippedParts[slot] === partId) {
            progress.equippedParts[slot] = null;
          }
        });
        progress.bankedCredits += scrapValue;
        applyLoadoutChange(`Part dismantled: ${part.name}. +${scrapValue} credits.`);
      }

      function renderLockedCard(title, message) {
        return `
          <div class="select-card is-static">
            <span class="select-title">${title}</span>
            <span class="select-meta">${message}</span>
          </div>
        `;
      }

      function renderSalvage() {
        if (!dom.salvage) return;
        if (!isFeatureUnlocked("salvage")) {
          dom.salvage.innerHTML = renderLockedCard("Salvage cache locked", getFeatureHint("salvage"));
          return;
        }
        const keys = progress.salvageKeys || 0;
        const pityThreshold = SALVAGE_CACHE.pityThreshold;
        const pity = Math.min(progress.salvagePity || 0, pityThreshold);
        const pityText = pity >= pityThreshold ? "Rare guarantee ready" : `Rare guarantee ${pity} / ${pityThreshold}`;
        const odds = getSalvageOdds();
        const oddsPills = odds.map((item) => {
          return `<span class="select-pill">${item.label} ${item.percent}%</span>`;
        }).join("");
        const historyHtml = progress.salvageHistory && progress.salvageHistory.length
          ? progress.salvageHistory.map((entry) => `
            <div class="history-entry">
              <strong>${entry.title}</strong>
              <span>${entry.detail}</span>
            </div>
          `).join("")
          : "<span class=\"select-meta\">No caches opened yet.</span>";
        dom.salvage.innerHTML = `
          <div class="select-card is-static">
            <span class="select-title">${SALVAGE_CACHE.name}</span>
            <span class="select-meta">Keys ${keys}  ${pityText}</span>
            <span class="select-meta">Rewards roll on open. No real currency involved.</span>
            <div class="select-pills">
              ${oddsPills}
            </div>
            <button class="btn primary" type="button" data-salvage-action="open" ${keys ? "" : "disabled"}>Open Cache</button>
          </div>
          <div class="select-card is-static">
            <span class="select-title">Recent Hauls</span>
            <div class="history-list">
              ${historyHtml}
            </div>
          </div>
        `;
      }

      function getSalvageOdds() {
        const total = SALVAGE_CACHE.table.reduce((sum, item) => sum + item.weight, 0);
        return SALVAGE_CACHE.table.map((item) => ({
          id: item.id,
          label: item.label,
          percent: Math.round((item.weight / total) * 100)
        }));
      }

      function openSalvageCache() {
        if (!progress.salvageKeys || progress.salvageKeys < 1) return;
        progress.salvageKeys -= 1;
        let rewardDef = rollSalvageReward();
        const rareReady = progress.salvagePity >= SALVAGE_CACHE.pityThreshold;
        if (rareReady && !SALVAGE_CACHE.rareIds.includes(rewardDef.id)) {
          const rareTable = SALVAGE_CACHE.table.filter((item) => SALVAGE_CACHE.rareIds.includes(item.id));
          rewardDef = pickWeighted(rareTable, rareTable.map((item) => item.weight));
        }
        const reward = rewardDef.roll();
        let detail = "";
        if (reward.type === "credits") {
          progress.bankedCredits += reward.amount;
          detail = `${reward.amount.toLocaleString()} credits`;
        }
        if (reward.type === "blueprints") {
          progress.blueprints += reward.amount;
          detail = `${reward.amount} blueprint${reward.amount === 1 ? "" : "s"}`;
        }
        if (reward.type === "part") {
          const part = reward.part;
          if (part) {
            progress.partsInventory.unshift(part);
            if (progress.partsInventory.length > 18) {
              progress.partsInventory.pop();
            }
            detail = part.name;
          } else {
            detail = "Component fragment";
          }
        }
        const isRare = SALVAGE_CACHE.rareIds.includes(rewardDef.id);
        progress.salvagePity = isRare ? 0 : (progress.salvagePity || 0) + 1;
        recordSalvageHistory({ title: rewardDef.label, detail });
        saveProgress();
        checkProgressionUnlocks();
        renderShipyard();
        renderArmory();
        logEvent(`Salvage cache opened: ${detail}.`);
      }

      function rollSalvageReward() {
        const table = SALVAGE_CACHE.table;
        return pickWeighted(table, table.map((item) => item.weight));
      }

      function recordSalvageHistory(entry) {
        progress.salvageHistory = [entry, ...(progress.salvageHistory || [])].slice(0, 6);
      }

      function applyLoadoutChange(message) {
        saveProgress();
        renderShipyard();
        renderArmory();
        if (state.mode === "hangar" || state.mode === "gameover") {
          player = createPlayer();
        } else if (message) {
          logEvent(message);
        }
      }

      function renderContracts() {
        if (!dom.contracts) return;
        if (!isFeatureUnlocked("contracts")) {
          dom.contracts.innerHTML = "<span class=\"select-meta\">Contracts locked. " + getFeatureHint("contracts") + "</span>";
          dom.factions.innerHTML = renderLockedCard("Faction intel locked", getFeatureHint("contracts"));
          return;
        }
        const active = state.contracts || [];
        if (!active.length) {
          dom.contracts.innerHTML = "<span class=\"select-meta\">No active contracts. Launch a mission to receive new objectives.</span>";
        } else {
          dom.contracts.innerHTML = active.map((contract) => {
            const pct = contract.complete ? 100 : (contract.target ? Math.min(100, (contract.progress / contract.target) * 100) : 0);
            const progressText = contract.type === "noDamage"
              ? `${Math.floor(contract.progress)}s / ${contract.target}s`
              : `${contract.progress} / ${contract.target}`;
            const statusText = contract.complete ? "Complete" : progressText;
            const faction = FACTIONS.find((item) => item.id === contract.factionId);
            return `
              <div class="contract-card">
                <div class="contract-title">${contract.title}</div>
                <div class="contract-meta">
                  <span>${contract.desc}</span>
                  <span>${statusText}</span>
                  <span>Reward: ${contract.reward.credits}c, ${contract.reward.xp}xp, +${contract.reward.rep} rep</span>
                  <span>${faction ? faction.name : contract.factionId}</span>
                </div>
                <div class="contract-progress"><span style="width:${pct}%"></span></div>
              </div>
            `;
          }).join("");
        }

        dom.factions.innerHTML = FACTIONS.map((faction) => {
          const rep = progress.factions[faction.id] || 0;
          return `
            <div class="faction-card">
              <span>${faction.desc}</span>
              <strong>${faction.name}</strong>
              <div class="contract-meta">Rep ${rep}</div>
            </div>
          `;
        }).join("");
      }

      function renderSettings() {
        const modeGroup = document.querySelector("[data-setting='game-mode']");
        const difficultyGroup = document.querySelector("[data-setting='difficulty']");
        const inputGroup = document.querySelector("[data-setting='input-mode']");
        const particleGroup = document.querySelector("[data-setting='particles']");
        const hitFlashGroup = document.querySelector("[data-setting='hit-flash']");
        [modeGroup, difficultyGroup, inputGroup, particleGroup, hitFlashGroup].forEach((group) => {
          if (!group) return;
          const setting = group.dataset.setting;
          const value = setting === "game-mode" ? progress.settings.gameMode
            : setting === "difficulty" ? progress.settings.difficulty
            : setting === "input-mode" ? progress.settings.inputMode
            : setting === "particles" ? progress.settings.particles
            : progress.settings.hitFlash ? "on" : "off";
          group.querySelectorAll(".option-btn").forEach((btn) => {
            btn.classList.toggle("is-active", btn.dataset.option === value);
          });
        });

        renderKeybinds();
      }

      function renderKeybinds() {
        const labels = {
          forward: "Move Forward",
          back: "Move Back",
          left: "Strafe Left",
          right: "Strafe Right",
          aimUp: "Aim Up",
          aimDown: "Aim Down",
          aimLeft: "Aim Left",
          aimRight: "Aim Right",
          fire: "Fire",
          boost: "Boost",
          ability: "Ability",
          secondary: "Secondary",
          dock: "Upgrade Dock",
          pause: "Pause"
        };
        dom.keybinds.innerHTML = Object.keys(labels).map((key) => {
          const value = input.capture === key ? "Press key" : formatKeybind(progress.keybinds[key]);
          return `
            <div class="keybind-row">
              <span>${labels[key]}</span>
              <button class="keybind-btn" type="button" data-bind="${key}">${value}</button>
            </div>
          `;
        }).join("");
      }

      function renderHistory() {
        if (!dom.history) return;
        if (!progress.runHistory.length) {
          dom.history.innerHTML = "<span class=\"select-meta\">No runs logged yet.</span>";
          return;
        }
        dom.history.innerHTML = progress.runHistory.map((run) => {
          const difficultyLabel = run.difficulty || "Normal";
          const modeLabel = run.mode ? `  ${run.mode}` : "";
          const score = Number.isFinite(run.score) ? Math.round(run.score).toLocaleString() : run.score;
          const credits = Number.isFinite(run.credits) ? Math.round(run.credits).toLocaleString() : run.credits;
          return `
            <div class="history-entry">
              <strong>${run.ship} / ${run.weapon}</strong>
              <span>Wave ${run.wave}  Score ${score}  ${difficultyLabel}${modeLabel}</span>
              <span>${run.kills} kills  ${credits} credits</span>
            </div>
          `;
        }).join("");
      }

      function formatKeybind(value) {
        if (!value) return "-";
        if (value === " ") return "Space";
        if (value.startsWith("arrow")) {
          return `Arrow ${value.replace("arrow", "").toUpperCase()}`;
        }
        if (value === "shift") return "Shift";
        if (value === "control") return "Ctrl";
        if (value === "alt") return "Alt";
        if (value === "meta") return "Meta";
        return value.length > 1 ? value.toUpperCase() : value.toUpperCase();
      }

      function formatStat(key, value) {
        const labels = {
          damage: "Damage",
          bulletSpeed: "Velocity",
          fireRate: "Fire Rate",
          energyCost: "Energy Cost",
          critChance: "Crit Chance",
          spread: "Spread",
          turnRate: "Turn Rate",
          maxSpeed: "Max Speed",
          accel: "Acceleration"
        };
        const label = labels[key] || key;
        const isPercent = key === "critChance";
        const displayValue = isPercent ? value * 100 : value;
        const formatted = Number.isInteger(displayValue) ? displayValue.toString() : displayValue.toFixed(2);
        const signed = displayValue > 0 ? `+${formatted}` : formatted;
        const suffix = isPercent ? "%" : "";
        return `${signed}${suffix} ${label}`;
      }

      function formatDuration(seconds) {
        const total = Math.max(0, Math.round(seconds));
        const minutes = Math.floor(total / 60);
        const secs = total % 60;
        return `${minutes}:${secs.toString().padStart(2, "0")}`;
      }

      const TIER_COLORS = {
        common: "#ffffff",
        uncommon: "#6ee7b7",
        rare: "#7ca8ff",
        epic: "#b98cff",
        legendary: "#f6c65f"
      };

      const LOWER_BETTER_STATS = new Set(["energyCost", "spread", "cooldown"]);

      function getTierMeta(tier) {
        return TIER_META[tier] || TIER_META.common;
      }

      function formatTierLabel(tier) {
        return getTierMeta(tier).label;
      }

      function normalizeCategory(category) {
        return (category || "upgrade").toLowerCase().replace(/\s+/g, "-");
      }

      function getUpgradeCategoryIcon(category) {
        const key = normalizeCategory(category);
        const icons = {
          offense: "",
          defense: "",
          mobility: "",
          utility: "",
          strategy: "",
          control: "",
          systems: "",
          upgrade: ""
        };
        return icons[key] || icons.upgrade;
      }

      function getRewardIcon(reward) {
        const icons = {
          credits: "",
          blueprints: "",
          salvage: "",
          part: ""
        };
        return icons[reward.type] || "";
      }

      function getRewardLabel(reward) {
        if (!reward) return "";
        if (reward.type === "credits") return "Credits";
        if (reward.type === "blueprints") return "Blueprints";
        if (reward.type === "salvage") return "Salvage keys";
        if (reward.type === "part") return reward.title || "Part";
        return reward.type;
      }

      function formatRewardValue(reward) {
        if (!reward) return "0";
        const amount = Number.isFinite(reward.amount) ? reward.amount : 1;
        return amount.toLocaleString();
      }

      function groupByTier(items) {
        const grouped = {};
        items.forEach((item) => {
          const tier = item.tier || "common";
          if (!grouped[tier]) grouped[tier] = [];
          grouped[tier].push(item);
        });
        return TIER_ORDER.filter((tier) => grouped[tier] && grouped[tier].length)
          .map((tier) => ({ tier, items: grouped[tier] }));
      }

      function formatDelta(value, digits) {
        if (!Number.isFinite(value)) return "0";
        const rounded = Number.isInteger(value) ? value.toString() : value.toFixed(digits);
        const sign = value > 0 ? "+" : "";
        return `${sign}${rounded}`;
      }

      function isBetterStat(key, diff) {
        return LOWER_BETTER_STATS.has(key) ? diff < 0 : diff > 0;
      }

      function getWeaponStatsSnapshot(weapon) {
        const stats = { ...weapon.stats };
        const level = progress.weaponLevels[weapon.id] || 0;
        const upgrades = weapon.upgrades || [];
        upgrades.slice(0, level).forEach((upgrade) => {
          if (upgrade.apply) upgrade.apply(stats);
        });
        return stats;
      }

      function buildWeaponComparison(currentWeapon, candidateWeapon) {
        if (!currentWeapon || !candidateWeapon) return "";
        const currentStats = getWeaponStatsSnapshot(currentWeapon);
        const nextStats = getWeaponStatsSnapshot(candidateWeapon);
        const rules = [
          { key: "damage", label: "Damage", digits: 0 },
          { key: "fireRate", label: "Fire Rate", digits: 1 },
          { key: "energyCost", label: "Energy Cost", digits: 1 },
          { key: "bulletSpeed", label: "Velocity", digits: 0 },
          { key: "projectiles", label: "Projectiles", digits: 0 },
          { key: "spread", label: "Spread", digits: 2 },
          { key: "splashRadius", label: "Splash", digits: 0 },
          { key: "pierce", label: "Pierce", digits: 0 }
        ];
        const chips = [];
        rules.forEach((rule) => {
          const base = currentStats[rule.key] || 0;
          const next = nextStats[rule.key] || 0;
          const diff = next - base;
          if (Math.abs(diff) < 0.01) return;
          const better = isBetterStat(rule.key, diff);
          chips.push(`<span class="stat-diff ${better ? "is-positive" : "is-negative"}">${formatDelta(diff, rule.digits)} ${rule.label}</span>`);
        });
        if (!chips.length) {
          return "<span class=\"stat-diff is-neutral\">Matches equipped stats</span>";
        }
        return chips.slice(0, 4).join("");
      }

      function buildSecondaryComparison(currentSecondary, candidateSecondary) {
        if (!currentSecondary || !candidateSecondary) return "";
        const diff = (candidateSecondary.cooldown || 0) - (currentSecondary.cooldown || 0);
        if (Math.abs(diff) < 0.1) {
          return "<span class=\"stat-diff is-neutral\">Matches equipped cooldown</span>";
        }
        const better = isBetterStat("cooldown", diff);
        return `<span class="stat-diff ${better ? "is-positive" : "is-negative"}">${formatDelta(diff, 0)}s Cooldown</span>`;
      }

      function buildPartComparison(part, equippedPart) {
        if (!part || !part.stats) return "";
        const compareFrom = equippedPart && equippedPart.stats ? equippedPart.stats : {};
        const chips = Object.keys(part.stats).map((key) => {
          const diff = (part.stats[key] || 0) - (compareFrom[key] || 0);
          if (Math.abs(diff) < 0.01) return "";
          const better = isBetterStat(key, diff);
          return `<span class="stat-diff ${better ? "is-positive" : "is-negative"}">${formatStat(key, diff)}</span>`;
        }).filter(Boolean);
        if (!chips.length) {
          return "<span class=\"stat-diff is-neutral\">Matches equipped part</span>";
        }
        return chips.slice(0, 4).join("");
      }

      function getPartTier(part) {
        if (!part) return "common";
        if (part.rarityId) return part.rarityId;
        return (part.rarity || "Common").toLowerCase();
      }

      function getPartScrapValue(part) {
        const tier = getPartTier(part);
        const values = {
          common: 60,
          uncommon: 120,
          rare: 200,
          epic: 320
        };
        return values[tier] || 80;
      }

      function getShipTierStyle(tier) {
        if (tier >= 4) return "epic";
        if (tier === 3) return "rare";
        if (tier === 2) return "uncommon";
        return "common";
      }

      function renderTierSection(tier, items, renderItem) {
        const meta = getTierMeta(tier);
        return `
          <div class="tier-section" data-tier="${tier}">
            <div class="tier-header">
              <span class="tier-title">${meta.label} Tier</span>
              <span class="tier-count">${items.length} ${items.length === 1 ? "option" : "options"}</span>
            </div>
            <div class="card-grid">
              ${items.map(renderItem).join("")}
            </div>
          </div>
        `;
      }

      function formatUnlockText(unlock) {
        if (!unlock) return "";
        const parts = [];
        if (unlock.rank) parts.push(`Rank ${unlock.rank}`);
        if (unlock.credits) parts.push(`${unlock.credits}c`);
        if (unlock.blueprints) parts.push(`${unlock.blueprints} blueprints`);
        if (unlock.faction) parts.push(`${unlock.faction.id.toUpperCase()} ${unlock.faction.rep}`);
        return parts.join("  ");
      }

      function canUnlock(item, unlocks) {
        if (unlocks[item.id]) return true;
        const unlock = item.unlock || {};
        if (unlock.rank && progress.rank < unlock.rank) return false;
        if (unlock.faction) {
          const rep = progress.factions[unlock.faction.id] || 0;
          if (rep < unlock.faction.rep) return false;
        }
        if (unlock.credits && progress.bankedCredits < unlock.credits) return false;
        if (unlock.blueprints && progress.blueprints < unlock.blueprints) return false;
        return true;
      }

      function spendUnlockCost(unlock) {
        if (!unlock) return;
        if (unlock.credits) {
          progress.bankedCredits = Math.max(0, progress.bankedCredits - unlock.credits);
        }
        if (unlock.blueprints) {
          progress.blueprints = Math.max(0, progress.blueprints - unlock.blueprints);
        }
      }

      function unlockItem(item, unlocks) {
        if (unlocks[item.id]) return true;
        if (!canUnlock(item, unlocks)) return false;
        spendUnlockCost(item.unlock);
        unlocks[item.id] = true;
        saveProgress();
        return true;
      }

      function setOverlay(mode) {
        if (mode === "start") {
          const fireKey = formatKeybind(progress.keybinds.fire);
          const boostKey = formatKeybind(progress.keybinds.boost);
          const abilityKey = formatKeybind(progress.keybinds.ability);
          const secondaryKey = formatKeybind(progress.keybinds.secondary);
          const dockKey = formatKeybind(progress.keybinds.dock);
          const modeLabel = isFrontierMode() ? "Frontier patrol" : "Wave sortie";
          const modeCopy = isFrontierMode()
            ? "Push deep into hostile space. Upgrade your ship at the dock to survive longer."
            : "Your fighter follows the cursor. Keep moving to recharge shields and pick upgrades between waves.";
          const modeTip = isFrontierMode()
            ? `<li>Dock: ${dockKey} to upgrade your ship and tier up mid-run.</li>`
            : "<li>Upgrades appear between waves to power up your run.</li>";
          const aimKeys = [
            progress.keybinds.aimUp,
            progress.keybinds.aimLeft,
            progress.keybinds.aimDown,
            progress.keybinds.aimRight
          ].map(formatKeybind).join("/");
          dom.overlayContent.innerHTML = `
            <div class="overlay-header">
              <p class="eyebrow">Hangar ready</p>
              <h3>${modeLabel} briefing</h3>
              <p>${modeCopy}</p>
            </div>
            <ul class="overlay-list">
              <li>Mouse aims the nose. WASD or arrow keys thrust.</li>
              <li>Keyboard-only: aim with ${aimKeys} and thrust with WASD.</li>
              <li>Fire: ${fireKey}. Boost: ${boostKey}. Ability: ${abilityKey}. Secondary: ${secondaryKey}.</li>
              <li>Pause: P or Esc.</li>
              ${modeTip}
              <li>Advanced systems unlock as you progress through waves.</li>
              <li>Training runs do not award credits or XP.</li>
            </ul>
            <div class="overlay-actions">
              <button class="btn primary" data-overlay-action="launch">Launch mission</button>
            </div>
          `;
        }
        if (mode === "paused") {
          dom.overlayContent.innerHTML = `
            <div class="overlay-header">
              <p class="eyebrow">Systems paused</p>
              <h3>Mission on hold</h3>
              <p>Ready when you are. Resume to continue the dogfight or press Esc or P.</p>
            </div>
            <div class="overlay-actions">
              <button class="btn primary" data-overlay-action="resume">Resume mission</button>
              <button class="btn ghost" data-overlay-action="reset">Return to hangar</button>
            </div>
          `;
        }
        if (mode === "upgrade") {
          const availableUpgrades = state.upgradeOptions.filter((upgrade) => {
            const stack = state.upgradeStacks[upgrade.id] || 0;
            const maxStacks = Number.isFinite(upgrade.maxStacks) ? upgrade.maxStacks : 1;
            return stack < maxStacks && canSelectSkillUpgrade(upgrade);
          });
          const hasUpgrades = availableUpgrades.length > 0;
          const creditsLabel = Math.round(state.credits).toLocaleString();
          const skillSlots = `${state.skillSlots.length}/${SKILL_LIMIT}`;
          const upgradeCards = hasUpgrades
            ? availableUpgrades.map((upgrade) => {
              const stack = state.upgradeStacks[upgrade.id] || 0;
              const maxStacks = Number.isFinite(upgrade.maxStacks) ? upgrade.maxStacks : 1;
              const nextLevel = stack + 1;
              const tier = getUpgradeTier(upgrade, nextLevel);
              const tierLabel = formatTierLabel(tier);
              const category = upgrade.category || "Upgrade";
              const categoryIcon = getUpgradeCategoryIcon(category);
              const isSkill = isSkillUpgrade(upgrade);
              const stackLabel = isSkill ? `Lv ${nextLevel}/${maxStacks}` : `${stack}/${maxStacks}`;
              const kindLabel = isSkill ? "Skill" : "Stat";
              return `
                <button class="upgrade-card is-choice" data-tier="${tier}" data-kind="${isSkill ? "skill" : "stat"}" data-upgrade-id="${upgrade.id}">
                  <span class="upgrade-ribbon" data-tier="${tier}">${tierLabel}</span>
                  <span class="upgrade-stack">${stackLabel}</span>
                  <span class="upgrade-icon" aria-hidden="true">${categoryIcon}</span>
                  <span class="upgrade-title">${upgrade.name}</span>
                  <span class="upgrade-desc">${upgrade.desc}</span>
                  <span class="upgrade-kind">${kindLabel}</span>
                </button>
              `;
            }).join("")
            : `
              <div class="upgrade-card is-choice is-static" data-tier="common" aria-disabled="true">
                <span class="upgrade-ribbon" data-tier="common">Complete</span>
                <span class="upgrade-icon" aria-hidden="true">${getUpgradeCategoryIcon("upgrade")}</span>
                <span class="upgrade-title">All upgrades installed</span>
                <span class="upgrade-desc">Your ship is fully tuned. Launch the next wave.</span>
                <span class="upgrade-kind">Ready</span>
              </div>
            `;
          const rerollCost = getUpgradeRerollCost();
          const canReroll = state.credits >= rerollCost;
          const rerollCopy = `Reroll cost scales each time this wave. Current reroll: ${rerollCost} credits.`;
          const upgradeActions = hasUpgrades
            ? `
              <button class="btn ghost" data-overlay-action="reroll" ${canReroll ? "" : "disabled"}>Reroll (${rerollCost} credits)</button>
              <button class="btn ghost" data-overlay-action="skip">Skip upgrade</button>
            `
            : `
              <button class="btn primary" data-overlay-action="skip">Launch next wave</button>
            `;
          dom.overlayContent.innerHTML = `
            <div class="overlay-header">
              <p class="eyebrow">Wave ${state.wave - 1} cleared</p>
              <h3>Choose a field upgrade</h3>
              <p>Upgrades stack for the rest of the run. Skill systems are limited to ${SKILL_LIMIT} selections and climb tiers each level. ${rerollCopy}</p>
            </div>
            <div class="badge-group overlay-badges">
              <span class="badge">Credits ${creditsLabel}</span>
              <span class="badge">Skills ${skillSlots}</span>
            </div>
            <div class="upgrade-grid upgrade-choice-grid">
              ${upgradeCards}
            </div>
            <div class="overlay-actions">
              ${upgradeActions}
            </div>
          `;
        }
        if (mode === "dock") {
          const tier = state.frontier ? state.frontier.tier : 1;
          const upgradesHtml = FRONTIER_UPGRADES.map((upgrade) => {
            const level = state.frontier?.upgrades[upgrade.id] || 0;
            const maxLevel = upgrade.maxLevel || 1;
            const cost = getFrontierUpgradeCost(upgrade, level, tier);
            const canBuy = level < maxLevel && state.credits >= cost;
            const status = level >= maxLevel ? "Maxed" : `Cost ${cost} credits`;
            const tierId = upgrade.tier || "common";
            const tierLabel = formatTierLabel(tierId);
            const levelLabel = `Lv ${level} / ${maxLevel}`;
            const category = upgrade.category || "Upgrade";
            const categoryIcon = getUpgradeCategoryIcon(category);
            const categoryKey = normalizeCategory(category);
            return `
              <button class="upgrade-card" data-tier="${tierId}" data-frontier-upgrade="${upgrade.id}" ${canBuy ? "" : "disabled"}>
                <div class="upgrade-meta">
                  <span class="select-pill tier-pill" data-tier="${tierId}">${tierLabel}</span>
                  <span class="select-pill category-pill" data-category="${categoryKey}" aria-label="${category}" title="${category}">${categoryIcon}</span>
                  <span class="select-pill">${levelLabel}</span>
                </div>
                <span class="upgrade-title">${upgrade.name}</span>
                <span class="upgrade-desc">${upgrade.desc}</span>
                <span class="upgrade-desc">${status}</span>
              </button>
            `;
          }).join("");
          const nextShips = getFrontierNextShips();
          const tierCost = getFrontierTierCost(tier);
          const canTierUp = nextShips.length && state.credits >= tierCost;
          const tierButton = nextShips.length
            ? `<button class="btn primary" data-overlay-action="tier-up" ${canTierUp ? "" : "disabled"}>Tier up (${tierCost} credits)</button>`
            : "<button class=\"btn ghost\" disabled>Max tier reached</button>";
          dom.overlayContent.innerHTML = `
            <div class="overlay-header">
              <p class="eyebrow">Frontier dock</p>
              <h3>Upgrade your ship</h3>
              <p>Spend credits to tune your frame. Tier upgrades reset dock upgrades but unlock stronger hulls.</p>
            </div>
            <div class="upgrade-grid">
              ${upgradesHtml}
            </div>
            <div class="overlay-actions">
              <button class="btn ghost" data-overlay-action="dock-close">Resume patrol</button>
              ${tierButton}
            </div>
          `;
        }
        if (mode === "tier-select") {
          const nextShips = getFrontierNextShips();
          const tierCost = getFrontierTierCost(state.frontier?.tier || 1);
          const shipCards = nextShips.map((ship) => {
            const weaponName = ship.signatureWeapon ? getWeaponById(ship.signatureWeapon).name : "Standard";
            const tierText = ship.tier ? `Tier ${ship.tier}` : "Tier upgrade";
            const abilityName = ABILITIES[ship.abilityId]?.name || "Ability";
            return `
              <button class="select-card" data-frontier-ship="${ship.id}">
                <span class="select-title">${ship.name}</span>
                <span class="select-meta">${ship.desc}</span>
                <div class="select-pills">
                  <span class="select-pill">${tierText}</span>
                  <span class="select-pill">Signature: ${weaponName}</span>
                  <span class="select-pill">${abilityName}</span>
                </div>
              </button>
            `;
          }).join("");
          dom.overlayContent.innerHTML = `
            <div class="overlay-header">
              <p class="eyebrow">Tier upgrade ready</p>
              <h3>Select your next frame</h3>
              <p>Upgrade cost: ${tierCost} credits. Dock upgrades reset after the swap.</p>
            </div>
            <div class="card-grid">
              ${shipCards || "<div class=\"select-meta\">No upgrades available.</div>"}
            </div>
            <div class="overlay-actions">
              <button class="btn ghost" data-overlay-action="dock">Back to dock</button>
            </div>
          `;
        }
        if (mode === "gameover") {
          const headerEyebrow = state.training ? "Training ended" : "Mission failed";
          const headerTitle = state.training ? "Debrief complete" : "Ship lost in the rift";
          const headerCopy = state.training
            ? "No rewards earned. Adjust your loadout and launch again when ready."
            : "Recover your data logs and refit in the hangar before the next sortie.";
          const lossRewards = state.lossRewards;
          const summary = lossRewards ? lossRewards.summary : getRunSummary();
          const performanceTier = lossRewards ? lossRewards.tier : "common";
          const performanceLabel = formatTierLabel(performanceTier);
          const rewardCards = lossRewards && lossRewards.rewards.length
            ? lossRewards.rewards.map((reward) => {
              const tier = reward.tier || "common";
              const icon = getRewardIcon(reward);
              const label = getRewardLabel(reward);
              const value = formatRewardValue(reward);
              return `
                <div class="reward-item" data-tier="${tier}" title="${label} x${value}" aria-label="${label} x${value}">
                  <span class="reward-icon" aria-hidden="true">${icon}</span>
                  <span class="reward-value">x${value}</span>
                </div>
              `;
            }).join("")
            : "<div class=\"select-meta\">No salvage recovered.</div>";
          const rewardSection = state.training ? "" : `
            <div class="panel-subsection">
              <div class="reward-banner">
                <span class="reward-line"></span>
                <span class="reward-title">Rewards</span>
                <span class="reward-line"></span>
              </div>
              <div class="chip-list">
                <span class="chip" data-tier="${performanceTier}">${performanceLabel} performance</span>
                <span class="chip">Survival ${formatDuration(summary.durationSec)}</span>
                <span class="chip">${summary.difficultyLabel} difficulty</span>
              </div>
              <div class="reward-grid">
                ${rewardCards}
              </div>
            </div>
          `;
          dom.overlayContent.innerHTML = `
            <div class="overlay-header">
              <p class="eyebrow">${headerEyebrow}</p>
              <h3>${headerTitle}</h3>
              <p>${headerCopy}</p>
            </div>
            <div class="progress-grid">
              <div class="stat-tile"><span>Wave</span><strong>${summary.wave}</strong></div>
              <div class="stat-tile"><span>Kills</span><strong>${summary.kills}</strong></div>
              <div class="stat-tile"><span>Score</span><strong>${summary.score.toLocaleString()}</strong></div>
              <div class="stat-tile"><span>Survival</span><strong>${formatDuration(summary.durationSec)}</strong></div>
              <div class="stat-tile"><span>Credits</span><strong>${summary.credits.toLocaleString()}</strong></div>
            </div>
            ${rewardSection}
            <div class="overlay-actions">
              <button class="btn primary" data-overlay-action="reset">Return to hangar</button>
            </div>
          `;
        }

        dom.overlay.classList.add("is-visible");
      }

      function hideOverlay() {
        dom.overlay.classList.remove("is-visible");
      }

      function logEvent(message) {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        entry.textContent = message;
        dom.log.prepend(entry);
        while (dom.log.children.length > 6) {
          dom.log.removeChild(dom.log.lastChild);
        }
      }

      function spawnExplosion(x, y, color, size = 18) {
        const count = getParticleCount(14);
        for (let i = 0; i < count; i += 1) {
          const angle = Math.random() * Math.PI * 2;
          const speed = rand(60, 220);
          particles.push({
            x,
            y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: rand(0.4, 0.9),
            maxLife: 0.9,
            size: rand(2, size / 6),
            color
          });
        }
      }

      function spawnPulse(x, y, color, maxRadius = 120) {
        pulses.push({
          x,
          y,
          color,
          radius: 10,
          maxRadius,
          life: 0.6,
          maxLife: 0.6,
          speed: (maxRadius - 10) / 0.6
        });
      }

      function spawnLootBursts(x, y, drops) {
        if (!drops || !drops.length) return;
        const baseX = clamp(x, 24, state.worldWidth - 24);
        const baseY = clamp(y, 24, state.worldHeight - 24);
        drops.forEach((drop, index) => {
          lootBursts.push({
            x: clamp(baseX + rand(-12, 12), 16, state.worldWidth - 16),
            y: clamp(baseY - index * 18, 16, state.worldHeight - 16),
            vy: -28 - index * 4,
            life: 1.4,
            maxLife: 1.4,
            label: drop.label,
            tier: drop.tier || "common"
          });
        });
      }

      function spawnDamageNumber(x, y, amount, options = {}) {
        const value = Math.round(amount);
        if (!Number.isFinite(value) || value === 0) return;
        const prefix = options.prefix || "";
        const safeX = clamp(x, 16, state.worldWidth - 16);
        const safeY = clamp(y, 16, state.worldHeight - 16);
        damageNumbers.push({
          x: safeX,
          y: safeY,
          vx: rand(-10, 10),
          vy: -28,
          life: 0.9,
          maxLife: 0.9,
          text: `${prefix}${Math.abs(value)}`,
          color: options.color || "#f06969"
        });
      }

      function wrapEntity(entity) {
        const radius = entity.radius || 0;
        const minX = radius + 4;
        const minY = radius + 4;
        const maxX = state.worldWidth - radius - 4;
        const maxY = state.worldHeight - radius - 4;
        if (entity.x < minX) {
          entity.x = minX;
          if (entity.vx) entity.vx = Math.max(0, entity.vx) * 0.6;
        }
        if (entity.x > maxX) {
          entity.x = maxX;
          if (entity.vx) entity.vx = Math.min(0, entity.vx) * 0.6;
        }
        if (entity.y < minY) {
          entity.y = minY;
          if (entity.vy) entity.vy = Math.max(0, entity.vy) * 0.6;
        }
        if (entity.y > maxY) {
          entity.y = maxY;
          if (entity.vy) entity.vy = Math.min(0, entity.vy) * 0.6;
        }
      }

      function resolveObstacleCollisions(entity) {
        if (!entity || !obstacles.length) return;
        const applyBounce = (nx, ny) => {
          if (!Number.isFinite(entity.vx) || !Number.isFinite(entity.vy)) return;
          const speed = Math.hypot(entity.vx, entity.vy);
          const bounce = clamp(speed / 240, 0.12, 0.45);
          const dot = entity.vx * nx + entity.vy * ny;
          if (dot < 0) {
            entity.vx -= (1 + bounce) * dot * nx;
            entity.vy -= (1 + bounce) * dot * ny;
          } else if (speed < 10) {
            entity.vx += nx * 28 * bounce;
            entity.vy += ny * 28 * bounce;
          }
        };
        obstacles.forEach((obstacle) => {
          if (obstacle.kind === "rock") {
            const dx = entity.x - obstacle.x;
            const dy = entity.y - obstacle.y;
            const distance = Math.hypot(dx, dy);
            const minDistance = (entity.radius || 0) + obstacle.radius + 2;
            if (distance < minDistance) {
              const push = minDistance - distance;
              let nx = 0;
              let ny = 0;
              if (distance < 0.01) {
                const angle = rand(0, Math.PI * 2);
                nx = Math.cos(angle);
                ny = Math.sin(angle);
              } else {
                nx = dx / distance;
                ny = dy / distance;
              }
              entity.x += nx * push;
              entity.y += ny * push;
              applyBounce(nx, ny);
            }
            return;
          }
          const halfWidth = obstacle.width * 0.5;
          const halfHeight = obstacle.height * 0.5;
          const closestX = clamp(entity.x, obstacle.x - halfWidth, obstacle.x + halfWidth);
          const closestY = clamp(entity.y, obstacle.y - halfHeight, obstacle.y + halfHeight);
          const dx = entity.x - closestX;
          const dy = entity.y - closestY;
          const distance = Math.hypot(dx, dy) || 0;
          const minDistance = (entity.radius || 0) + 2;
          if (distance < minDistance) {
            let push = minDistance - distance;
            let nx = 0;
            let ny = 0;
            if (distance === 0) {
              const offsetX = entity.x - obstacle.x;
              const offsetY = entity.y - obstacle.y;
              const overlapX = halfWidth + minDistance - Math.abs(offsetX);
              const overlapY = halfHeight + minDistance - Math.abs(offsetY);
              if (overlapX < overlapY) {
                nx = offsetX >= 0 ? 1 : -1;
                push = overlapX;
              } else {
                ny = offsetY >= 0 ? 1 : -1;
                push = overlapY;
              }
            } else {
              nx = dx / distance;
              ny = dy / distance;
            }
            entity.x += nx * push;
            entity.y += ny * push;
            applyBounce(nx, ny);
          }
        });
      }

      function getObstacleAvoidance(entity, forwardX, forwardY) {
        if (!entity || !obstacles.length) {
          return { x: 0, y: 0 };
        }
        let steerX = 0;
        let steerY = 0;
        const bias = Number.isFinite(entity.strafeBias) ? entity.strafeBias : 1;
        obstacles.forEach((obstacle) => {
          if (obstacle.kind === "rock") {
            const dx = entity.x - obstacle.x;
            const dy = entity.y - obstacle.y;
            const distance = Math.hypot(dx, dy) || 1;
            const range = obstacle.radius + (entity.radius || 0) + 160;
            if (distance < range) {
              const strength = (range - distance) / range;
              const nx = dx / distance;
              const ny = dy / distance;
              steerX += nx * strength;
              steerY += ny * strength;
              const lateral = strength * 0.3 * bias;
              steerX += -ny * lateral;
              steerY += nx * lateral;
            }
            return;
          }
          const halfWidth = obstacle.width * 0.5;
          const halfHeight = obstacle.height * 0.5;
          const closestX = clamp(entity.x, obstacle.x - halfWidth, obstacle.x + halfWidth);
          const closestY = clamp(entity.y, obstacle.y - halfHeight, obstacle.y + halfHeight);
          const dx = entity.x - closestX;
          const dy = entity.y - closestY;
          const distance = Math.hypot(dx, dy) || 1;
          const range = Math.max(halfWidth, halfHeight) + (entity.radius || 0) + 140;
          if (distance < range) {
            const strength = (range - distance) / range;
            const nx = distance ? dx / distance : (entity.x >= obstacle.x ? 1 : -1);
            const ny = distance ? dy / distance : (entity.y >= obstacle.y ? 1 : -1);
            steerX += nx * strength;
            steerY += ny * strength;
            const lateral = strength * 0.25 * bias;
            steerX += -ny * lateral;
            steerY += nx * lateral;
          }
        });
        if (Number.isFinite(forwardX) && Number.isFinite(forwardY)) {
          const backward = steerX * forwardX + steerY * forwardY;
          if (backward < 0) {
            steerX -= backward * forwardX;
            steerY -= backward * forwardY;
          }
        }
        const length = Math.hypot(steerX, steerY);
        if (!length) {
          return { x: 0, y: 0 };
        }
        const scale = length > 1 ? 1 / length : 1;
        return { x: steerX * scale, y: steerY * scale };
      }

      function getBoundaryAvoidance(entity, forwardX, forwardY) {
        if (!entity) {
          return { x: 0, y: 0 };
        }
        const buffer = 140 + (entity.radius || 0);
        const maxX = state.worldWidth - buffer;
        const maxY = state.worldHeight - buffer;
        let steerX = 0;
        let steerY = 0;
        if (entity.x < buffer) {
          steerX += (buffer - entity.x) / buffer;
        } else if (entity.x > maxX) {
          steerX -= (entity.x - maxX) / buffer;
        }
        if (entity.y < buffer) {
          steerY += (buffer - entity.y) / buffer;
        } else if (entity.y > maxY) {
          steerY -= (entity.y - maxY) / buffer;
        }
        if (Number.isFinite(forwardX) && Number.isFinite(forwardY)) {
          const backward = steerX * forwardX + steerY * forwardY;
          if (backward < 0) {
            steerX -= backward * forwardX;
            steerY -= backward * forwardY;
          }
        }
        const length = Math.hypot(steerX, steerY);
        if (!length) {
          return { x: 0, y: 0 };
        }
        const scale = length > 1 ? 1 / length : 1;
        return { x: steerX * scale, y: steerY * scale };
      }

      function segmentIntersectsCircle(ax, ay, bx, by, cx, cy, radius) {
        const dx = bx - ax;
        const dy = by - ay;
        const fx = ax - cx;
        const fy = ay - cy;
        const a = dx * dx + dy * dy;
        if (a <= 0) return false;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - radius * radius;
        let discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return false;
        discriminant = Math.sqrt(discriminant);
        const t1 = (-b - discriminant) / (2 * a);
        const t2 = (-b + discriminant) / (2 * a);
        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
      }

      function segmentIntersectsAabb(ax, ay, bx, by, minX, minY, maxX, maxY) {
        let t0 = 0;
        let t1 = 1;
        const dx = bx - ax;
        const dy = by - ay;
        const p = [-dx, dx, -dy, dy];
        const q = [ax - minX, maxX - ax, ay - minY, maxY - ay];
        for (let i = 0; i < 4; i += 1) {
          if (p[i] === 0) {
            if (q[i] < 0) return false;
          } else {
            const r = q[i] / p[i];
            if (p[i] < 0) {
              if (r > t1) return false;
              if (r > t0) t0 = r;
            } else {
              if (r < t0) return false;
              if (r < t1) t1 = r;
            }
          }
        }
        return true;
      }

      function findBlockingObstacle(entity, target, buffer) {
        if (!entity || !target || !obstacles.length) return null;
        const ax = entity.x;
        const ay = entity.y;
        const bx = target.x;
        const by = target.y;
        let closest = null;
        let bestDist = Infinity;
        obstacles.forEach((obstacle) => {
          let intersects = false;
          if (obstacle.kind === "rock") {
            intersects = segmentIntersectsCircle(
              ax,
              ay,
              bx,
              by,
              obstacle.x,
              obstacle.y,
              obstacle.radius + buffer
            );
          } else {
            const halfWidth = obstacle.width * 0.5 + buffer;
            const halfHeight = obstacle.height * 0.5 + buffer;
            intersects = segmentIntersectsAabb(
              ax,
              ay,
              bx,
              by,
              obstacle.x - halfWidth,
              obstacle.y - halfHeight,
              obstacle.x + halfWidth,
              obstacle.y + halfHeight
            );
          }
          if (intersects) {
            const dist = distanceBetween(entity, obstacle);
            if (dist < bestDist) {
              bestDist = dist;
              closest = obstacle;
            }
          }
        });
        return closest;
      }

      function getEdgePenalty(point) {
        const margin = 170;
        const edgeDistance = Math.min(
          point.x,
          point.y,
          state.worldWidth - point.x,
          state.worldHeight - point.y
        );
        if (edgeDistance >= margin) return 0;
        return (margin - edgeDistance) / margin;
      }

      function scoreNavPoint(point, target) {
        const edgePenalty = getEdgePenalty(point);
        const obstaclePenalty = isPointInObstacle(point, 40) ? 1 : 0;
        const distance = Math.hypot(point.x - target.x, point.y - target.y);
        return distance + edgePenalty * 520 + obstaclePenalty * 900;
      }

      function clampNavPoint(point, margin) {
        return {
          x: clamp(point.x, margin, state.worldWidth - margin),
          y: clamp(point.y, margin, state.worldHeight - margin)
        };
      }

      function getDetourPoint(entity, target, obstacle, buffer) {
        const dx = target.x - entity.x;
        const dy = target.y - entity.y;
        const length = Math.hypot(dx, dy);
        if (!length) return target;
        const dirX = dx / length;
        const dirY = dy / length;
        const perpX = -dirY;
        const perpY = dirX;
        const clearance = obstacle.kind === "rock"
          ? obstacle.radius
          : Math.max(obstacle.width, obstacle.height) * 0.5;
        const offset = clearance + buffer + 90;
        const margin = 120;
        const left = clampNavPoint({ x: obstacle.x + perpX * offset, y: obstacle.y + perpY * offset }, margin);
        const right = clampNavPoint({ x: obstacle.x - perpX * offset, y: obstacle.y - perpY * offset }, margin);
        const leftScore = scoreNavPoint(left, target);
        const rightScore = scoreNavPoint(right, target);
        if (Math.abs(leftScore - rightScore) < 18) {
          return entity.strafeBias >= 0 ? left : right;
        }
        return leftScore < rightScore ? left : right;
      }

      function getNavigationTarget(entity, target) {
        if (!entity || !target) return target;
        const buffer = (entity.radius || 0) + 28;
        const blocking = findBlockingObstacle(entity, target, buffer);
        if (!blocking) return target;
        return getDetourPoint(entity, target, blocking, buffer);
      }

      function isOutOfBounds(entity) {
        const margin = 60;
        return entity.x < -margin
          || entity.x > state.worldWidth + margin
          || entity.y < -margin
          || entity.y > state.worldHeight + margin;
      }

      function normalizeKey(event) {
        if (!event) return "";
        if (event.code === "Space") return " ";
        const key = event.key;
        if (!key || key === "Unidentified") return "";
        if (key === " " || key === "Spacebar") return " ";
        return key.toLowerCase();
      }

      function isBindableKey(key) {
        if (!key) return false;
        const blocked = ["meta", "alt", "control", "capslock", "tab"];
        return !blocked.includes(key);
      }

      function isActionActive(action) {
        const key = progress.keybinds[action];
        if (!key) return false;
        return input.keys.has(key);
      }

      function hasKey(key) {
        return input.keys.has(key);
      }

      function getKeyboardAimVector() {
        if (input.aimMode !== "keyboard") {
          const aimKeys = [
            progress.keybinds.aimUp,
            progress.keybinds.aimDown,
            progress.keybinds.aimLeft,
            progress.keybinds.aimRight
          ].filter(Boolean);
          const usesArrowAim = aimKeys.some((key) => key.startsWith("arrow"));
          if (usesArrowAim) {
            return { x: 0, y: 0, active: false };
          }
        }
        let x = 0;
        let y = 0;
        const aimUp = progress.keybinds.aimUp;
        const aimDown = progress.keybinds.aimDown;
        const aimLeft = progress.keybinds.aimLeft;
        const aimRight = progress.keybinds.aimRight;
        if (aimUp && hasKey(aimUp)) y -= 1;
        if (aimDown && hasKey(aimDown)) y += 1;
        if (aimLeft && hasKey(aimLeft)) x -= 1;
        if (aimRight && hasKey(aimRight)) x += 1;
        const length = Math.hypot(x, y);
        if (length === 0) {
          return { active: false, x: 0, y: 0 };
        }
        return { active: true, x: x / length, y: y / length };
      }

      function getAimTarget() {
        if (input.aimSource === "keyboard" && player) {
          return {
            x: player.x + Math.cos(player.angle) * 70,
            y: player.y + Math.sin(player.angle) * 70
          };
        }
        if (input.pointer.active && Number.isFinite(input.pointer.x) && Number.isFinite(input.pointer.y)) {
          return { x: input.pointer.x, y: input.pointer.y };
        }
        if (player) {
          return { x: player.x, y: player.y };
        }
        return { x: state.worldWidth * 0.5, y: state.worldHeight * 0.5 };
      }

      function distanceBetween(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }

      function normalizeAngle(angle) {
        return Math.atan2(Math.sin(angle), Math.cos(angle));
      }

      function rotateTowards(current, target, maxDelta) {
        if (!Number.isFinite(maxDelta) || maxDelta <= 0) {
          return normalizeAngle(current);
        }
        const diff = normalizeAngle(target - current);
        if (Math.abs(diff) <= maxDelta) {
          return normalizeAngle(target);
        }
        return normalizeAngle(current + Math.sign(diff) * maxDelta);
      }

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function randInt(min, max) {
        return Math.floor(rand(min, max + 1));
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function pickWeighted(items, weights) {
        const total = weights.reduce((sum, weight) => sum + weight, 0);
        let roll = Math.random() * total;
        for (let i = 0; i < items.length; i += 1) {
          roll -= weights[i];
          if (roll <= 0) {
            return items[i];
          }
        }
        return items[items.length - 1];
      }

      function pick(array) {
        return array[Math.floor(Math.random() * array.length)];
      }

      init();
    })();
  </script>
</body>
</html>
