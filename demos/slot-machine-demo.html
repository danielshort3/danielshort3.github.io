<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <base href="../" />
  <title>Server-Backed Slot Machine Demo</title>
  <meta name="theme-color" content="#0d1117" />
  <link rel="stylesheet" href="dist/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500&display=swap" />
  <style>
    :root {
      --app-vh: 1vh;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      color-scheme: light dark;
      --bg: #020617;
      --panel: color-mix(in srgb, var(--surface, #0f172a) 90%, black 10%);
      --panel-border: color-mix(in srgb, var(--surface-accent, #1e293b) 70%, transparent);
      --text: var(--text-light, #e2e8f0);
      --muted: color-mix(in srgb, var(--text) 65%, transparent);
      --accent: #facc15;
      --accent-2: #6366f1;
      --danger: #f87171;
      --radius: 16px;
    }
    @media (min-width: 769px) {
      .machine-frame__reels {
        padding-right: calc(clamp(64px, 16vw, 82px) + clamp(10px, 2vw, 16px));
      }
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 800px at 12% -10%, rgba(99, 102, 241, .14), transparent 55%),
        radial-gradient(1000px 700px at 88% 0%, rgba(14, 165, 233, .12), transparent 55%),
        linear-gradient(180deg, #010915, var(--bg));
      color: var(--text);
      padding: clamp(20px, 3vw, 36px);
      display: block;
      overflow-y: auto;
      overflow-x: hidden;
    }
    html[data-embedded="true"] body {
      display: block;
      padding: clamp(12px, 3vw, 20px);
    }
    main {
      width: min(1100px, 100%);
      background: color-mix(in srgb, var(--panel) 90%, #0b1224 10%);
      border: 1px solid color-mix(in srgb, var(--panel-border) 70%, transparent);
      border-radius: 22px;
      box-shadow: 0 24px 120px rgba(2, 6, 23, .72);
      padding: clamp(24px, 3vw, 36px);
      display: grid;
      gap: 28px;
      margin: 0 auto;
    }
    header h1 {
      font-family: "Space Grotesk", Inter, sans-serif;
      font-size: clamp(1.75rem, 3vw, 2.5rem);
      margin: 0 0 8px;
    }
    header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: .9rem;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 60%, transparent);
      background: rgba(99, 102, 241, .12);
    }
    .status-pill.ghost {
      background: rgba(255,255,255,.12);
      border-color: rgba(255,255,255,.2);
      color: rgba(255,255,255,.85);
    }
    .status-pill[data-state="error"] {
      color: var(--danger);
      background: rgba(244, 114, 182, .1);
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .grid {
      display: grid;
      gap: 16px;
    }
    .grid-two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .panel {
      border-radius: 18px;
      border: 1px solid color-mix(in srgb, var(--panel-border) 55%, transparent);
      padding: 18px 20px;
      background: color-mix(in srgb, rgba(15, 23, 42, .9) 90%, rgba(6, 11, 22, .92) 10%);
      box-shadow: 0 16px 60px rgba(2, 6, 23, .5);
    }
    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      font-weight: 600;
    }
    .log-panel {
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 160px);
    }
    .log-panel .log {
      flex: 1 1 auto;
    }
    dl {
      margin: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 16px;
      font-size: .95rem;
    }
    dt {
      color: var(--muted);
      font-weight: 500;
    }
    dd {
      margin: 0;
      font-weight: 600;
    }
    .reels {
      display: grid;
      grid-template-columns: repeat(3, minmax(80px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .slot-cell {
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, white 12%, transparent);
      display: grid;
      place-items: center;
      font-size: 2.75rem;
      background: rgba(15, 23, 42, .8);
      box-shadow: inset 0 0 30px rgba(0,0,0,.3);
      transition: transform .45s cubic-bezier(.34, 1.56, .64, 1);
    }
    .slot-cell.spin {
      transform: scale(1.08) rotateX(360deg);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .controls label {
      font-size: .9rem;
      color: var(--muted);
    }
    .controls input[type="number"] {
      width: 120px;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(15, 23, 42, .8);
      color: inherit;
      font-size: 1rem;
    }
    .controls button {
      border: none;
      border-radius: 999px;
      padding: 12px 28px;
      font-size: .95rem;
      font-weight: 600;
      cursor: pointer;
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      box-shadow: 0 10px 30px rgba(250, 204, 21, .35);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .controls button[disabled] {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .controls button:not([disabled]):active {
      transform: translateY(1px);
    }
    .alert {
      padding: 12px 14px;
      border-radius: 10px;
      font-size: .95rem;
      background: rgba(248, 113, 113, .1);
      border: 1px solid rgba(248, 113, 113, .4);
      color: var(--danger);
    }
    .log {
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
      overflow-y: auto;
      height: 100%;
      min-height: 240px;
    }
    .log-entry + .log-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .ghost-btn {
      border: 1px solid rgba(255,255,255,.25);
      color: var(--muted);
      background: transparent;
      border-radius: 10px;
      padding: 8px 14px;
      font-size: .85rem;
      cursor: pointer;
    }
    .ghost-btn:disabled {
      opacity: .5;
      cursor: default;
    }
    .ghost-btn.primary {
      color: #020617;
      background: linear-gradient(120deg, var(--accent), #fde047);
      border-color: transparent;
      font-weight: 600;
      box-shadow: 0 15px 35px rgba(250, 204, 21, .35);
    }
    .ghost-btn.secondary {
      color: var(--text);
      border-color: rgba(255,255,255,.25);
    }
    .ghost-btn.tertiary {
      color: var(--muted);
      border-color: transparent;
      background: rgba(255,255,255,.08);
    }
    .ghost-btn.danger {
      color: var(--danger);
      border-color: rgba(248,113,113,.5);
      background: rgba(248,113,113,.08);
    }
    .auth-overlay {
      position: fixed;
      inset: 0;
      z-index: 40;
      background: radial-gradient(circle at top, rgba(15,23,42,.9), rgba(2,6,23,.98));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(16px, 4vw, 48px);
      transition: opacity .35s ease, visibility .35s ease;
    }
    .auth-overlay[data-hidden="true"] {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .auth-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(20px, 5vw, 36px);
      width: min(960px, 100%);
      border-radius: 26px;
      border: 1px solid rgba(99,102,241,.35);
      background: linear-gradient(135deg, rgba(15,23,42,.95), rgba(30,64,175,.9));
      padding: clamp(24px, 5vw, 48px);
      box-shadow: 0 40px 150px rgba(2, 6, 23, .9);
      position: relative;
      overflow: hidden;
    }
    .auth-card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at top right, rgba(99,102,241,.4), transparent 45%);
      pointer-events: none;
    }
    .auth-copy {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 12px;
    }
    .auth-copy h2 {
      margin: 0;
      font-size: clamp(1.6rem, 3vw, 2.4rem);
      font-weight: 600;
      color: #fff;
    }
    .auth-copy p {
      margin: 0;
      color: color-mix(in srgb, #fff 85%, rgba(255,255,255,.4));
      line-height: 1.6;
    }
    .auth-body {
      position: relative;
      z-index: 1;
      background: rgba(2, 6, 23, .7);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.08);
      padding: clamp(18px, 4vw, 28px);
      display: grid;
      gap: 18px;
    }
    .auth-tabs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      padding: 5px;
    }
    .auth-tab {
      border: none;
      background: transparent;
      color: rgba(255,255,255,.7);
      font-weight: 600;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: background .2s ease, color .2s ease;
    }
    .auth-tab.active {
      background: rgba(255,255,255,.14);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .auth-forms {
      display: grid;
      gap: 15px;
    }
    .auth-forms label {
      display: grid;
      gap: 6px;
      font-size: .9rem;
      color: rgba(255,255,255,.7);
    }
    .auth-forms input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(15, 23, 42, .85);
      color: inherit;
      font-size: 1rem;
      transition: border .2s ease, box-shadow .2s ease;
    }
    .auth-forms input:focus-visible {
      outline: none;
      border-color: rgba(250,204,21,.65);
      box-shadow: 0 0 0 2px rgba(250,204,21,.2);
    }
    .auth-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .muted-text {
      color: rgba(255,255,255,.65);
      margin: 0;
      font-size: .9rem;
    }
    .muted-text.small {
      font-size: .8rem;
    }
    .alert {
      margin-top: 4px;
    }
    .auth-body[data-mode="login"] #auth-confirm-group {
      display: none;
    }
    .auth-body[data-mode="register"] #auth-info {
      display: none;
    }
    .status-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 8px;
      gap: 12px;
      flex-wrap: wrap;
    }
    .status-row .status-pill {
      margin: 0;
      flex: 1 1 auto;
      min-width: 0;
    }
    .status-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      flex: 0 0 auto;
    }
.status-icon {
  width: 34px;
  height: 34px;
  border-radius: 11px;
  border: 1px solid rgba(148,163,184,.28);
  background: rgba(15,23,42,.78);
  display: grid;
  place-items: center;
  color: var(--text);
  cursor: pointer;
  padding: 0;
    }
    .status-icon:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .status-icon svg {
      width: 22px;
      height: 22px;
      display: block;
    }
    .account-sheet {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(560px, calc(100% - 32px));
      max-height: min(640px, calc(100% - 40px));
      overflow: auto;
      z-index: 40;
      box-shadow: 0 20px 80px rgba(2,6,23,.7);
      backdrop-filter: blur(6px);
    }
    .account-sheet[hidden] {
      display: none;
    }
    .account-sheet__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .account-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      align-items: start;
    }
    .account-log {
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 12px;
      padding: 10px;
      background: rgba(255,255,255,.03);
      max-height: 220px;
      overflow: auto;
      display: grid;
      gap: 8px;
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
    }
    .account-log__item {
      border-bottom: 1px solid rgba(255,255,255,.08);
      padding-bottom: 6px;
    }
    .account-log__item:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }
    .slot-machine {
      position: relative;
      background:
        radial-gradient(160% 120% at 50% 0%, rgba(34,211,238,.08), transparent 50%),
        linear-gradient(145deg, rgba(8,13,25,.96), rgba(2,6,18,.97));
      border: 1px solid rgba(148,163,184,.28);
      border-radius: 24px;
      box-shadow: 0 36px 110px rgba(2,6,23,.75);
      padding: clamp(12px, 2vw, 18px);
      overflow: hidden;
    }
    .flyover {
      position: absolute;
      display: grid;
      gap: 6px;
      pointer-events: none;
      z-index: 5;
    }
    .flyover--top {
      top: 10px;
      right: 10px;
      justify-items: end;
    }
    .flyover--level {
      top: 4px;
      left: 12px;
      right: 12px;
      justify-items: center;
    }
    .flyover--xp {
      top: 86px;
      left: 12px;
      justify-items: start;
    }
    .flyover--loot {
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      justify-items: center;
      align-content: end;
    }
    .flyover-item {
      background: rgba(12, 18, 32, .9);
      border: 1px solid rgba(148,163,184,.35);
      border-radius: 12px;
      padding: 8px 10px;
      color: #facc15;
      font-weight: 800;
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      animation: flyout 1.5s ease forwards;
    }
    .flyover-item.win {
      color: #22d3ee;
      border-color: rgba(34,211,238,.5);
    }
    .flyover-item.drop {
      color: #a5b4fc;
      border-color: rgba(165,180,252,.5);
    }
    .flyover-item.level {
      color: #34d399;
      border-color: rgba(52,211,153,.5);
    }
    .flyover-item.xp {
      color: #fbbf24;
      border-color: rgba(251,191,36,.5);
    }
    .flyover-item img {
      width: 28px;
      height: 28px;
      object-fit: contain;
      border-radius: 8px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.1);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    @keyframes flyout {
      0% { opacity: 0; transform: translateY(-6px) scale(.98); }
      10% { opacity: 1; transform: translateY(0) scale(1); }
      80% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-8px) scale(.98); }
    }
    .slot-machine::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 60% 10%, rgba(250,204,21,.06), transparent 45%);
      opacity: .8;
      pointer-events: none;
    }
.slot-topbar {
  position: sticky;
  top: calc(var(--safe-top) + 10px);
  z-index: 24;
  display: grid;
  gap: 8px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(148,163,184,.24);
  background: linear-gradient(180deg, rgba(12,18,36,.96), rgba(6,10,22,.96));
  box-shadow: 0 12px 36px rgba(0,0,0,.32);
  backdrop-filter: blur(6px);
  margin-bottom: 4px;
}
.topbar-row {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  align-items: center;
}
    .slot-machine__body {
      position: relative;
      display: grid;
      grid-template-rows: 1fr auto;
      gap: clamp(12px, 2vw, 18px);
      min-height: calc(100svh - var(--safe-top) - var(--safe-bottom) - 24px);
      isolation: isolate;
      z-index: 1;
      min-width: 0;
    }
.top-actions {
  display: inline-flex;
  justify-content: flex-end;
  gap: 8px;
  flex: 0 0 auto;
  margin-left: auto;
}
    .status-icon--logout {
      background: linear-gradient(135deg, #f87171, #fb923c);
      border-color: rgba(251,146,60,.6);
      box-shadow: 0 14px 36px rgba(251,146,60,.35);
      color: #0b1222;
    }
.currency-row {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap;
  flex: 1 1 auto;
  min-width: 0;
}
    .currency-row--top {
      width: 100%;
      justify-content: space-between;
    }
    .game-header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: linear-gradient(180deg, rgba(12,18,36,.96), rgba(6,10,22,.98));
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.25);
      padding: 10px 12px;
      display: grid;
      gap: 8px;
      margin-bottom: 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
    }
.currency-chip {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 6px;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,.2);
  background: rgba(255,255,255,.04);
  font-weight: 700;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
  min-width: 60px;
  justify-content: flex-start;
  cursor: pointer;
}
    .skill-strip {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(56px, 1fr));
      gap: 8px;
      margin: 8px 0;
      grid-auto-rows: 56px;
    }
    .skill-pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.3);
      padding: 10px 6px;
      background: rgba(255,255,255,.04);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      min-height: 0;
      width: 100%;
      height: 100%;
      aspect-ratio: 1;
      text-align: center;
      flex-direction: column;
      font-size: .82rem;
    }
    .skill-pill[data-state="locked"] {
      opacity: .65;
      cursor: pointer;
    }
    .skill-pill[data-state="active"] {
      border-color: rgba(52,211,153,.6);
      background: rgba(52,211,153,.12);
      color: #34d399;
    }
    .skill-pill[data-state="cooldown"] {
      border-color: rgba(248,180,0,.6);
      background: rgba(248,180,0,.12);
      color: #fbbf24;
    }
    .skill-icon {
      font-size: 1.02rem;
      line-height: 1;
    }
    .skill-timer {
      position: absolute;
      bottom: 6px;
      left: 0;
      right: 0;
      font-size: .72rem;
      color: rgba(255,255,255,.8);
      line-height: 1;
    }
    .currency-chip strong {
      font-size: .9rem;
      white-space: nowrap;
      min-width: 40px;
      text-align: right;
    }
    .machine-chip {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      justify-content: flex-start;
    }
    .machine-level {
      display: grid;
      gap: 2px;
      min-width: 52px;
      align-items: center;
    }
    .machine-level .hud-value {
      font-size: 1rem;
    }
    .machine-perks {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .perks-btn {
      border: 1px solid rgba(148,163,184,.35);
      background: rgba(255,255,255,.06);
      color: var(--text);
      width: 26px;
      height: 26px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      cursor: pointer;
      font-weight: 800;
      line-height: 1;
      padding: 0;
    }
    .perks-btn:focus-visible {
      outline: 2px solid rgba(250,204,21,.7);
      outline-offset: 2px;
    }
    .perks-popover {
      position: fixed;
      top: clamp(80px, 12vh, 140px);
      right: clamp(10px, 4vw, 32px);
      width: min(360px, 80vw);
      background: rgba(6,10,22,.95);
      border: 1px solid rgba(148,163,184,.35);
      border-radius: 12px;
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
      padding: 10px 12px;
      display: none;
      z-index: 25;
    }
    .perks-popover__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .perks-close {
      border: 1px solid rgba(148,163,184,.35);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: grid;
      place-items: center;
      cursor: pointer;
    }
    .perks-popover[data-visible="true"] {
      display: grid;
      gap: 6px;
    }
    .perks-tabs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      background: rgba(255,255,255,.04);
      border-radius: 10px;
      padding: 4px;
    }
    .perks-tab {
      border: none;
      background: transparent;
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      font-weight: 700;
      cursor: pointer;
      letter-spacing: .01em;
    }
    .perks-tab.active {
      background: rgba(255,255,255,.12);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .perks-popover h4 {
      margin: 0;
      font-size: .95rem;
    }
    .perks-popover p {
      margin: 0;
      font-size: .9rem;
      color: var(--muted);
    }
    .perks-panel {
      display: none;
      gap: 6px;
    }
    .perks-panel[data-active="true"] {
      display: grid;
    }
    .perks-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
    }
    .perk-row {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px;
      align-items: start;
    }
    .perk-check {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid rgba(148,163,184,.5);
      display: inline-grid;
      place-items: center;
      font-size: .85rem;
      color: #0b1222;
      background: rgba(255,255,255,.04);
    }
    .perk-check[data-active="true"] {
      background: linear-gradient(135deg, #22d3ee, #facc15);
      border-color: transparent;
      color: #0b1222;
      box-shadow: 0 6px 14px rgba(34,211,238,.35);
    }
    .perk-text {
      color: var(--text);
      font-size: .9rem;
    }
    .perks-drop-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 6px;
    }
    .perk-drop-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 10px;
      padding: 6px 8px;
      background: rgba(255,255,255,.03);
      font-size: .9rem;
    }
    .machine-flyout {
      position: static;
      pointer-events: auto;
      z-index: 10;
    }
    .machine-flyout__toggle {
      width: 46px;
      height: 46px;
      border-radius: 50%;
      border: 1px solid rgba(148,163,184,.45);
      background: linear-gradient(150deg, #22d3ee, #facc15);
      box-shadow: 0 12px 28px rgba(34,211,238,.28);
      display: grid;
      place-items: center;
      cursor: pointer;
      padding: 0;
      transition: transform .16s ease, box-shadow .16s ease, border .16s ease;
      color: #041226;
      font-weight: 800;
      font-size: .9rem;
    }
    .machine-flyout__toggle:focus-visible {
      outline: 2px solid rgba(255,255,255,.85);
      outline-offset: 2px;
    }
    .machine-flyout__toggle:hover {
      box-shadow: 0 14px 32px rgba(34,211,238,.32);
      transform: translateY(-1px);
    }
    .machine-flyout__panel {
      position: fixed;
      top: var(--machine-flyout-top, 120px);
      right: auto;
      left: 50%;
      width: min(480px, calc(100vw - 32px));
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.3);
      background: linear-gradient(180deg, rgba(8,12,24,.96), rgba(2,5,16,.96));
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
      padding: 12px;
      display: grid;
      gap: 10px;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transform: translate(-50%, -6px);
      transition: opacity .16s ease, visibility .16s ease, transform .16s ease;
      max-height: min(70vh, 620px);
      overflow: auto;
      z-index: 1200;
    }
    .machine-flyout[data-open="true"] .machine-flyout__panel {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      transform: translate(-50%, 0);
    }
    .machine-flyout__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .machine-list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      max-height: 360px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .machine-card {
      position: relative;
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,.03);
      display: grid;
      gap: 6px;
      cursor: pointer;
      text-align: left;
      transition: border .18s ease, transform .18s ease, box-shadow .18s ease;
      min-height: 92px;
      grid-template-columns: auto 1fr auto;
      align-items: center;
    }
    .machine-card[disabled] {
      opacity: .55;
      cursor: not-allowed;
      filter: grayscale(0.4);
    }
    .machine-card:hover {
      border-color: rgba(99,102,241,.5);
      transform: translateY(-2px);
      box-shadow: 0 12px 28px rgba(15,23,42,.4);
    }
    .machine-card[data-active="true"] {
      border-color: rgba(34,211,238,.65);
      box-shadow: 0 16px 32px rgba(34,211,238,.25);
      background: linear-gradient(120deg, rgba(34,211,238,.1), rgba(250,204,21,.08));
    }
    .machine-card__name {
      margin: 0;
      font-weight: 700;
      color: var(--text);
    }
    .machine-card__meta {
      margin: 0;
      color: var(--muted);
      font-size: .85rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .machine-card__icon {
      width: 36px;
      height: 36px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(255,255,255,.04);
      padding: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .machine-card__cost {
      margin: 0;
      font-weight: 700;
      color: var(--text);
      text-align: right;
      display: grid;
      gap: 4px;
      justify-items: end;
    }
    .machine-card__status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,.35);
      font-size: .78rem;
      text-transform: uppercase;
      letter-spacing: .04em;
      color: rgba(226,232,240,.9);
      background: rgba(255,255,255,.04);
    }
    .machine-card__status[data-state="active"] {
      border-color: rgba(34,211,238,.6);
      color: #34d399;
      background: rgba(34,211,238,.12);
    }
    .machine-card__status[data-state="price"] {
      border-color: rgba(250,204,21,.5);
      color: #facc15;
      background: rgba(250,204,21,.08);
    }
    .machine-card__status[data-state="level"] {
      border-color: rgba(248,113,113,.45);
      color: #fca5a5;
      background: rgba(248,113,113,.08);
    }
    .machine-card[data-locked="true"]::after {
      content: attr(data-locked-label);
      position: absolute;
      inset: 8px;
      border-radius: 10px;
      background: rgba(0,0,0,.6);
      color: rgba(255,255,255,.9);
      font-weight: 700;
      display: grid;
      place-items: center;
      pointer-events: none;
      border: 1px dashed rgba(255,255,255,.25);
      text-transform: uppercase;
      letter-spacing: .05em;
    }
    .hud--ribbon {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      background: linear-gradient(180deg, rgba(15,23,42,.92), rgba(9,13,26,.92));
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 16px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      padding: 10px 12px;
    }
    .machine-stage {
      position: relative;
      display: grid;
      grid-template-rows: 1fr;
      gap: 10px;
      border-radius: 22px;
      padding: clamp(6px, 1.4vw, 12px);
      background:
        radial-gradient(120% 120% at 18% 8%, rgba(99,102,241,.1), transparent 45%),
        radial-gradient(120% 100% at 80% 0%, rgba(14,165,233,.08), transparent 45%),
        linear-gradient(180deg, rgba(10,16,30,.94), rgba(4,7,16,.96));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 24px 70px rgba(0,0,0,.45);
      overflow: visible;
      min-height: 0;
      min-width: 0;
    }
    .machine-frame {
      position: relative;
      border-radius: 22px;
      border: 1px solid rgba(99,102,241,.28);
      padding: clamp(8px, 1.6vw, 14px);
      background:
        radial-gradient(circle at 22% 0%, rgba(59,130,246,.16), transparent 42%),
        linear-gradient(180deg, rgba(12,18,36,.94), rgba(6,11,22,.98));
      overflow: hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 18px 50px rgba(2,6,23,.7);
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      min-height: 0;
      align-self: start;
      flex: 1 1 auto;
      min-width: 0;
      flex-direction: column;
      gap: 10px;
    }
    .machine-xp {
      position: relative;
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      gap: 10px;
      align-items: center;
      width: 100%;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(2,6,23,.65);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      min-width: 0;
    }
    .xp-track {
      position: relative;
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow: hidden;
      border: 1px solid rgba(148,163,184,.25);
    }
    .xp-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(120deg, #22d3ee, #facc15);
      box-shadow: 0 6px 16px rgba(34,211,238,.25);
    }
    .machine-frame__glow {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 50% 18%, rgba(99,102,241,.22), transparent 48%);
      opacity: .9;
      pointer-events: none;
    }
    .skill-strip--overlay {
      position: absolute;
      top: clamp(18px, 10vh, 42px);
      right: clamp(6px, 2vw, 14px);
      width: clamp(72px, 16vw, 96px);
      grid-template-columns: 1fr;
      grid-auto-rows: 60px;
      gap: 8px;
      padding: 8px 6px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.28);
      background: linear-gradient(180deg, rgba(12,18,32,.85), rgba(4,8,18,.9));
      box-shadow: 0 14px 30px rgba(0,0,0,.38);
      z-index: 6;
    }
    .skill-strip--overlay .skill-pill {
      padding: 8px 6px;
      gap: 2px;
      font-size: .8rem;
    }
    .skill-strip--overlay .skill-icon {
      font-size: .95rem;
    }
    .machine-frame__reels {
      position: relative;
      display: grid;
      align-items: start;
      justify-items: center;
      background: linear-gradient(180deg, rgba(8,13,26,.9), rgba(4,7,16,.95));
      padding: clamp(8px, 1.5vw, 14px);
      padding-right: calc(clamp(8px, 1.5vw, 14px) + clamp(72px, 16vw, 96px));
      border-radius: 20px;
      box-shadow: inset 0 0 32px rgba(0,0,0,.45), 0 12px 30px rgba(0,0,0,.4);
      overflow: hidden;
      width: 100%;
      min-height: 0;
      height: auto;
      min-width: 0;
    }
    .slot-grid {
      --reel-count: 3;
      --row-count: 3;
      --cell-size: clamp(72px, 12vw, 128px);
      display: grid;
      grid-template-columns: repeat(var(--reel-count), minmax(0, 1fr));
      gap: clamp(10px, 1.8vw, 16px);
      perspective: 1200px;
      position: relative;
      padding: clamp(8px, 1.4vw, 12px);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.06);
      background: radial-gradient(circle at 50% 20%, rgba(255,255,255,.04), transparent 62%);
      width: 100%;
      min-width: 100%;
      min-height: 0;
      align-content: start;
      align-items: start;
      justify-content: center;
      justify-items: center;
    }
    .slot-grid:empty::before {
      content: "Reels warming up";
      color: var(--muted);
      font-weight: 700;
      letter-spacing: .06em;
      text-transform: uppercase;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px dashed rgba(148,163,184,.3);
      background: rgba(2,6,23,.6);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .slot-reel {
      position: relative;
      display: grid;
      grid-template-rows: repeat(var(--row-count), 1fr);
      gap: clamp(6px, 1.6vw, 12px);
      padding: clamp(6px, 1.4vw, 12px);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(16,24,40,.92), rgba(11,17,30,.92));
      border: 1px solid rgba(148,163,184,.22);
      box-shadow: inset 0 4px 12px rgba(0,0,0,.25), 0 10px 26px rgba(0,0,0,.28);
    }
    .slot-cell {
      position: relative;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      aspect-ratio: 1 / 1.1;
      display: grid;
      place-items: center;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 18px 35px rgba(0,0,0,.35);
      transition: transform .28s ease, box-shadow .28s ease, border-color .2s ease;
      pointer-events: none;
    }
    .slot-cell[data-state="spinning"] {
      opacity: .95;
    }
    .slot-cell[data-state="win"] {
      box-shadow: 0 0 0 2px rgba(250,204,21,.35), 0 22px 45px rgba(250,204,21,.28);
      transform: translateY(-2px) scale(1.02);
      border-color: rgba(250,204,21,.6);
    }
    .slot-cell__symbol {
      width: 80%;
      max-width: calc(var(--cell-size) * 0.9);
      display: grid;
      place-items: center;
    }
    .slot-cell__symbol img {
      width: 100%;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 12px 24px rgba(0,0,0,.45));
      transition: filter .2s ease, transform .2s ease;
    }
    .slot-cell[data-state="spinning"] .slot-cell__symbol {
      animation: slotReelSpin .35s linear infinite;
      opacity: .95;
    }
    .slot-cell[data-state="spinning"] .slot-cell__symbol img {
      filter: blur(1.4px) brightness(1.05);
    }
    .slot-cell.slot-lock .slot-cell__symbol {
      animation: none;
      transform: translateZ(0) scale(1.05);
      transition: transform .5s cubic-bezier(.19,1,.22,1);
    }
    .slot-cell.slot-lock .slot-cell__symbol img {
      filter: drop-shadow(0 15px 25px rgba(0,0,0,.35));
    }
    @media (hover: hover) {
      .slot-cell:not([data-state="spinning"]):hover {
        transform: translateY(-4px);
        box-shadow: 0 0 0 1px rgba(148,163,184,.3), 0 18px 36px rgba(0,0,0,.35);
      }
      .machine-frame__reels {
        max-width: 100%;
      }
      .slot-cell:not([data-state="spinning"]):hover .slot-cell__symbol img {
        transform: translateY(-2px);
      }
    }
    @media (min-width: 1080px) {
      .machine-frame {
        min-height: 420px;
      }
      .machine-frame__reels {
        min-height: 360px;
        align-items: center;
        justify-content: center;
      }
      .hud {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }
    @keyframes slotReelSpin {
      0% { transform: translateY(-16%); }
      50% { transform: translateY(16%); }
      100% { transform: translateY(-16%); }
    }
    .line-overlay {
      position: absolute;
      inset: clamp(12px, 2vw, 26px);
      pointer-events: none;
    }
    .line-overlay svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      overflow: visible;
    }
    .line-path {
      fill: none;
      stroke: hsl(var(--line-hue, 220), 90%, 65%);
      stroke-width: 3.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.92;
      stroke-dasharray: 12 10;
      animation: drawLine .9s ease forwards;
    }
    @keyframes drawLine {
      from { stroke-dashoffset: 40; opacity: 0; }
      to { stroke-dashoffset: 0; opacity: 0.95; }
    }
    .slot-cell.line-flash {
      box-shadow: 0 0 0 2px rgba(99,102,241,.75), 0 0 32px rgba(99,102,241,.4);
      transform: translateY(-2px);
    }
    @keyframes slotPulse {
      0% { transform: translateY(-4px) scale(.98); opacity: .8; }
      100% { transform: translateY(4px) scale(1.02); opacity: 1; }
    }
    .control-deck {
      display: grid;
      gap: 12px;
      align-content: start;
      background: none;
      border: none;
      padding: 0;
      box-shadow: none;
    }
    .control-deck--ground {
      display: grid;
      gap: 10px;
    }
    .bet-bar {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.2);
      background: linear-gradient(180deg, rgba(11,16,28,.9), rgba(6,9,20,.92));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04), 0 10px 28px rgba(0,0,0,.3);
      min-width: 0;
    }
    .bet-presets {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      align-items: stretch;
    }
    .bet-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
      align-items: stretch;
    }
    .info-pill {
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(255,255,255,.04);
      border-radius: 12px;
      padding: 8px 10px;
      display: grid;
      gap: 2px;
    }
    .info-pill .hud-value {
      margin: 0;
    }
    .action-rail {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.24);
      background: linear-gradient(180deg, rgba(10,16,30,.9), rgba(4,8,18,.94));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04), 0 12px 30px rgba(0,0,0,.32);
    }
    .action-rail--inline {
      padding: 8px 10px;
    }
    .action-rail--spin {
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .layout-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
      gap: 8px;
      align-items: stretch;
    }
    .layout-chip {
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.04);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      gap: 4px;
      text-align: center;
      color: inherit;
      cursor: default;
    }
    .layout-chip strong {
      font-size: 1rem;
    }
    .layout-chip.is-action {
      cursor: pointer;
      border-color: rgba(148,163,184,.35);
      transition: transform .16s ease, box-shadow .16s ease, border .16s ease;
    }
    .layout-chip.is-action:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .layout-chip.is-action:focus-visible {
      outline: 2px solid rgba(250,204,21,.6);
      outline-offset: 2px;
    }
    .action-icons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(64px, 1fr));
      gap: 8px;
      align-items: stretch;
    }
    .icon-btn {
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(255,255,255,.04);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 8px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      min-height: 56px;
      cursor: pointer;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      transition: transform .18s ease, border .18s ease, box-shadow .18s ease;
      text-align: center;
      position: relative;
    }
    .icon-btn::before {
      content: attr(data-icon);
      font-size: 1.05rem;
      display: inline-block;
    }
    .icon-btn:hover {
      border-color: rgba(34,211,238,.8);
      box-shadow: 0 10px 24px rgba(34,211,238,.18);
      transform: translateY(-1px);
    }
    .drop-stack {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.22);
      background: linear-gradient(180deg, rgba(15,23,42,.8), rgba(4,6,20,.92));
      padding: 12px;
      display: grid;
      gap: 10px;
      position: relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .drop-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .drop-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .inventory-grid {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .inventory-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(148,163,184,.25);
      font-size: .9rem;
      color: var(--text);
    }
    .inventory-chip img {
      width: 22px;
      height: 22px;
      object-fit: contain;
      display: block;
    }
    .daily-reward {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.03);
      padding: 10px 12px;
      display: grid;
      gap: 8px;
    }
    .daily-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .daily-items {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .daily-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(99,102,241,.12);
      border: 1px solid rgba(99,102,241,.3);
      font-weight: 600;
      color: var(--text);
    }
    .daily-item img {
      width: 22px;
      height: 22px;
      object-fit: contain;
    }
    .bonus-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }
    .bonus-item {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.03);
      padding: 10px 12px;
    }
    .bonus-label {
      margin: 0;
      font-weight: 600;
    }
    .bonus-note {
      margin: 2px 0 0;
      color: var(--muted);
      font-size: .9rem;
    }
    .bonus-value {
      font-weight: 700;
      white-space: nowrap;
    }
    .drop-log {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(2,6,23,.7);
      padding: 10px;
      max-height: 180px;
      overflow-y: auto;
      font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: .85rem;
      color: var(--muted);
    }
    .drop-entry {
      display: flex;
      gap: 8px;
      align-items: center;
      line-height: 1.3;
    }
    .drop-entry + .drop-entry {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,.06);
    }
    .drop-icon {
      width: 22px;
      height: 22px;
      object-fit: contain;
      border-radius: 6px;
      background: rgba(255,255,255,.05);
      padding: 3px;
      display: block;
    }
    .drop-amount {
      font-weight: 600;
      color: var(--text);
    }
    .drop-panel {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 10px;
      width: min(480px, 100%);
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(4,6,20,.96);
      box-shadow: 0 20px 50px rgba(2,6,23,.65);
      padding: 12px 14px;
      z-index: 8;
    }
    .drop-panel[hidden] {
      display: none;
    }
    .drop-panel h4 {
      margin: 0 0 8px;
      font-size: 1rem;
    }
    .drop-panel__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 0 0 8px;
      flex-wrap: wrap;
    }
    .drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,.65);
      backdrop-filter: blur(6px);
      display: grid;
      place-items: center;
      padding: clamp(8px, 4vw, 20px);
      z-index: 1400;
    }
    .drop-overlay[hidden] {
      display: none;
    }
    .drop-panel--overlay {
      position: relative;
      top: auto;
      right: auto;
      left: auto;
      margin: 0;
      width: min(520px, 100%);
      max-height: min(80vh, 680px);
      overflow: auto;
      box-shadow: 0 20px 70px rgba(2,6,23,.6);
      border-radius: 18px;
    }
    .drop-panel ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
    }
    .drop-panel li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.2);
      padding: 8px 10px;
      background: rgba(255,255,255,.03);
    }
    .gear-card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 10px;
      margin-top: 0;
    }
    .gear-panel,
    .card-panel {
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(180deg, rgba(12,18,36,.9), rgba(6,10,22,.92));
      padding: 12px;
      display: grid;
      gap: 10px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .panel-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .gear-slots,
    .card-slots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }
    .gear-slot,
    .card-slot {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.25);
      padding: 10px;
      background: rgba(255,255,255,.03);
      display: grid;
      gap: 6px;
      min-height: 90px;
    }
    .gear-slot.locked,
    .card-slot.locked {
      opacity: .55;
    }
    .gear-slot__meta,
    .card-slot__meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .gear-slot__name,
    .card-slot__name {
      margin: 0;
      font-weight: 700;
    }
    .gear-slot__bonus,
    .card-slot__effect {
      margin: 0;
      color: var(--muted);
      font-size: .9rem;
    }
    .gear-inventory,
    .card-collection {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }
    .gear-item,
    .card-item {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(255,255,255,.02);
      padding: 10px;
      display: grid;
      gap: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .rarity-tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: .8rem;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(255,255,255,.05);
    }
    .card-item img,
    .card-slot img {
      width: 44px;
      height: 44px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(255,255,255,.05);
      padding: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .rate-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .drop-tier-label {
      margin: 6px 0 4px;
      font-size: .8rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: var(--muted);
    }
    .drop-mult {
      margin: 4px 0;
      font-size: .85rem;
      color: var(--muted);
    }
    .items-panel {
      display: grid;
      gap: 12px;
      padding: 12px;
      background: linear-gradient(180deg, rgba(14,20,35,.9), rgba(6,10,22,.95));
    }
    .items-grid {
      display: grid;
      grid-template-columns: 1.25fr 1fr;
      gap: 12px;
      align-items: start;
    }
    @media (max-width: 900px) {
      .items-grid {
        grid-template-columns: 1fr;
      }
    }
    .premium-panel {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,.6);
      backdrop-filter: blur(6px);
      z-index: 2000;
    }
    .premium-panel[hidden] {
      display: none;
    }
    .premium-card {
      width: min(560px, 96vw);
      max-height: 90vh;
      overflow: auto;
      background: linear-gradient(180deg, rgba(12,18,36,.95), rgba(4,8,18,.96));
      border: 1px solid rgba(148,163,184,.3);
      border-radius: 16px;
      box-shadow: 0 24px 80px rgba(0,0,0,.55);
      padding: 16px;
      display: grid;
      gap: 12px;
    }
    .premium-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .premium-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .premium-item {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.25);
      padding: 10px;
      background: rgba(255,255,255,.03);
      display: grid;
      gap: 6px;
    }
    .premium-item h4 {
      margin: 0;
      font-size: 1rem;
    }
    .premium-meta {
      font-size: .85rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 6px;
      flex-wrap: wrap;
    }
    .premium-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .premium-actions button {
      flex: 1 1 auto;
    }
    .upgrade-panel {
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.2);
      background: rgba(15,23,42,.8);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 1100px;
      margin: 0 auto;
    }
    .upgrade-panel h2,
    .upgrade-panel h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .upgrade-category + .upgrade-category {
      margin-top: 16px;
    }
    .upgrade-category h3 {
      margin: 0 0 6px;
      font-size: .9rem;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: rgba(226,232,240,.75);
    }
    #upgrade-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .upgrade-card-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      align-items: stretch;
    }
    .upgrade-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.25);
      padding: 10px;
      background: linear-gradient(180deg, rgba(14,20,35,.9), rgba(6,10,22,.94));
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 120px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .upgrade-card[data-highlight="true"] {
      outline: 2px solid var(--accent);
      box-shadow: 0 0 0 3px rgba(250,204,21,.35), inset 0 1px 0 rgba(255,255,255,.08);
    }
    .upgrade-card__meta {
      font-size: .82rem;
      color: rgba(148,163,184,.85);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .upgrade-card__note {
      font-size: .78rem;
      color: rgba(248,250,252,.7);
      margin: 0;
    }
    .upgrade-card__tags {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .upgrade-tag {
      font-size: .72rem;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,.3);
      color: rgba(226,232,240,.9);
      background: rgba(255,255,255,.05);
      letter-spacing: .03em;
      text-transform: uppercase;
    }
    .upgrade-card h4 {
      margin: 0;
      font-size: 1rem;
    }
    .upgrade-card strong {
      font-size: .95rem;
    }
    .upgrade-card button {
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: .9rem;
      background: rgba(99,102,241,.12);
      color: var(--text);
      cursor: pointer;
      width: 100%;
      margin-top: auto;
    }
    .upgrade-card button[data-disabled="true"],
    .upgrade-card button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      align-items: stretch;
    }
    .hud-card {
      border-radius: 12px;
      padding: 8px 10px;
      background: linear-gradient(180deg, rgba(17,24,39,.94), rgba(11,16,30,.92));
      border: 1px solid rgba(148,163,184,.26);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .hud-label {
      margin: 0;
      font-size: .75rem;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: rgba(148,163,184,.8);
    }
    .hud-value {
      font-size: clamp(1rem, 2.2vw, 1.15rem);
      margin-top: 6px;
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-variant-numeric: tabular-nums;
    }
    .bet-presets .chip {
      width: 100%;
      justify-content: center;
      text-align: center;
    }
    .chip {
      border: 1px solid rgba(148,163,184,.45);
      background: linear-gradient(180deg, rgba(15,23,42,.95), rgba(9,14,26,.95));
      color: #e2e8f0;
      border-radius: 12px;
      padding: 8px 10px;
      font-size: .88rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
    }
    .chip:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    .machine-messages {
      min-height: 32px;
      display: grid;
      gap: 6px;
    }
    .machine-messages--stage {
      display: none;
      background: rgba(2,6,23,.65);
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .machine-messages--stage .machine-outcome {
      font-size: 1.05rem;
    }
    .machine-outcome-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .machine-outcome {
      margin: 0;
      font-weight: 600;
      font-size: 1rem;
      word-break: break-word;
    }
    .machine-lines {
      margin: 0;
      font-size: .85rem;
      color: var(--muted);
      word-break: break-word;
    }
    .machine-error {
      margin: 0;
      color: #f97316;
      font-size: .9rem;
    }
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      align-items: stretch;
      justify-items: stretch;
    }
    .action-buttons .line-btn {
      padding: 9px 12px;
      font-size: .85rem;
      border-radius: 12px;
      min-width: 0;
    }
    .action-buttons .spin-btn {
      width: 100%;
    }
    .action-select {
      display: none;
    }
    .spin-btn {
      border: none;
      border-radius: 18px;
      padding: 16px 22px;
      font-size: 1.05rem;
      font-weight: 800;
      letter-spacing: .02em;
      color: #041226;
      background: linear-gradient(135deg, #22d3ee, #facc15);
      box-shadow: 0 22px 44px rgba(34,211,238,.36);
      cursor: pointer;
      transition: transform .18s ease, box-shadow .18s ease;
      min-width: 100%;
      min-height: 64px;
    }
    .action-rail--spin #auto-spin-btn {
      flex: 1 1 0;
      max-width: 120px;
      text-align: center;
    }
    .action-rail--spin #spin-btn {
      flex: 3 1 0;
    }
    .spin-btn--secondary {
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid rgba(148,163,184,.3);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      min-width: auto;
    }
    .spin-btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .spin-btn:not(:disabled):hover {
      box-shadow: 0 22px 44px rgba(34,211,238,.36);
      transform: translateY(-1px);
    }
    .spin-btn:not(:disabled):active {
      transform: translateY(0);
      box-shadow: 0 12px 28px rgba(34,211,238,.3);
    }
    .paytable-panel {
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.22);
      background: linear-gradient(180deg, rgba(10,16,30,.92), rgba(5,9,18,.95));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .paytable {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }
    .paytable li {
      display: flex;
      justify-content: space-between;
      background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(9,14,26,.9));
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 16px;
      padding: 12px 16px;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
    }
    .paytable li[data-active="false"] {
      opacity: .45;
      border-style: dashed;
    }
    .paytable-symbol {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }
    .paytable-symbol img {
      width: 36px;
      height: 36px;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
    }
    .paytable-meta {
      font-size: .9rem;
      color: rgba(148,163,184,.85);
    }
    .paytable-status {
      font-size: .8rem;
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.35);
      background: rgba(255,255,255,.04);
      color: rgba(226,232,240,.85);
      text-transform: uppercase;
      letter-spacing: .04em;
    }
    .paytable li[data-active="false"] .paytable-status {
      border-color: rgba(248,113,113,.45);
      color: #fca5a5;
    }
.desktop-nav {
  display: flex;
  flex-wrap: nowrap;
  gap: 6px;
  border-radius: 16px;
  border: 1px solid rgba(148,163,184,.22);
  background: linear-gradient(145deg, rgba(10,16,30,.92), rgba(8,13,24,.94));
  padding: 8px;
  box-shadow: 0 12px 32px rgba(2,6,23,.42);
}
.desktop-nav button {
  flex: 1 1 0;
  min-width: 0;
  border: 1px solid rgba(148,163,184,.22);
  background: rgba(255,255,255,.03);
  color: var(--text);
  border-radius: 12px;
  padding: 8px 10px;
  font-weight: 700;
  letter-spacing: 0;
  font-size: .95rem;
  cursor: pointer;
  display: grid;
  place-items: center;
  transition: border .16s ease, background .16s ease, transform .16s ease, box-shadow .16s ease;
}
    .desktop-nav button.active {
      background: linear-gradient(120deg, #22d3ee, #facc15);
      color: #041226;
      border-color: transparent;
      box-shadow: 0 12px 28px rgba(34,211,238,.35);
      transform: translateY(-1px);
    }
    .desktop-nav button:not(.active):hover {
      border-color: rgba(148,163,184,.55);
      transform: translateY(-1px);
    }
.mobile-nav {
  display: none;
  gap: 4px;
  flex-wrap: nowrap;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,.16);
  background: rgba(15,23,42,.82);
  padding: 4px;
}
.mobile-nav button {
  flex: 1;
  border: none;
  border-radius: 12px;
  padding: 5px;
  background: rgba(99,102,241,.12);
  color: var(--text);
  font-weight: 600;
  cursor: pointer;
  min-width: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: .72rem;
      line-height: 1.1;
    }
.mobile-nav button svg {
  width: 18px;
  height: 18px;
  display: block;
}
    .mobile-nav button span {
      font-size: .72rem;
      letter-spacing: .04em;
    }
    .mobile-nav button.active {
      background: linear-gradient(120deg, var(--accent), #fde047);
      color: #020617;
      box-shadow: 0 6px 18px rgba(250,204,21,.3);
    }
    main[data-pane-mode="tabbed"] [data-mobile-pane] {
      display: none;
    }
    main[data-pane-mode="tabbed"] [data-mobile-pane][data-mobile-active="true"] {
      display: block;
    }
    @media (max-width: 768px) {
      html, body {
        height: 100%;
      }
      body {
        padding: env(safe-area-inset-top, 0px) 0 env(safe-area-inset-bottom, 0px) 0;
        min-height: 100svh;
        background: #020617;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      main {
        border-radius: 0;
        min-height: 0;
        min-height: calc(100svh - var(--safe-top, 0px) - var(--safe-bottom, 0px));
        height: 100%;
        padding: 0;
        gap: 8px;
        box-shadow: none;
        border: none;
        display: grid;
        grid-template-rows: auto 1fr auto;
        grid-template-columns: 100%;
        flex: 1;
        width: 100%;
        overflow: hidden;
      }
      main > * {
        margin-inline: 14px;
      }
      header {
        padding: 10px 12px;
      }
      .status-row {
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        margin: 0;
        grid-row: 1;
        flex-shrink: 0;
      }
      .desktop-nav {
        display: none;
      }
      .mobile-nav {
        display: flex;
        flex-wrap: nowrap;
        gap: 4px;
        overflow-x: auto;
        position: static;
        margin: 0;
        background: transparent;
        border: none;
        box-shadow: none;
        padding: 0;
      }
      .mobile-nav button {
        font-size: .85rem;
        min-height: 48px;
        width: 100%;
      }
      main[data-tabs="true"] {
        gap: 8px;
        grid-template-rows: auto 1fr auto;
      }
      main[data-tabs="true"] [data-mobile-pane] {
        display: none;
        margin-inline: 16px;
        min-height: 0;
        grid-row: 2;
      }
      main[data-tabs="true"] [data-mobile-pane][data-mobile-active="true"] {
        display: flex;
        flex-direction: column;
        min-height: 0;
        max-height: 100%;
        overflow: auto;
      }
      main[data-tabs="true"] [data-mobile-pane][data-mobile-active="true"].slot-machine {
        overflow: hidden;
      }
      main[data-tabs="true"] section.panel {
        max-height: none;
        overflow: visible;
      }
      .slot-machine {
        flex: 1;
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 0;
        box-shadow: none;
        min-height: 0;
        margin-bottom: 0;
        height: 100%;
      }
      .slot-machine__body {
        display: grid;
        grid-template-rows: 1fr auto;
        gap: 10px;
        padding-top: 0;
        align-items: stretch;
        min-height: 0;
        height: 100%;
        min-width: 0;
      }
      .machine-stage {
        padding: 8px;
        grid-template-rows: 1fr;
      }
      .machine-frame {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        padding: 8px;
        min-height: 0;
      }
      .machine-frame__reels {
        padding: 6px 8px;
        overflow: hidden;
        min-height: 0;
        height: auto;
        min-width: 0;
      }
      .slot-grid {
        gap: 6px;
        --cell-size: clamp(64px, 24vw, 120px);
        min-height: 0;
        grid-template-columns: repeat(var(--reel-count), minmax(0, 1fr));
        align-content: start;
        align-items: start;
        padding: 8px;
      }
      .slot-grid .slot-cell {
        border-width: 1px;
        padding: 4px;
      }
      .slot-grid .slot-cell__symbol {
        max-width: 76px;
      }
      .control-deck {
        gap: 10px;
        padding: 0;
      }
      .machine-frame__reels {
        padding-right: clamp(8px, 2vw, 14px);
      }
      .skill-strip--overlay {
        position: static;
        width: 100%;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        grid-auto-rows: 52px;
        padding: 0;
        border: none;
        box-shadow: none;
        margin: 6px 0 0;
        background: transparent;
      }
      .skill-strip--overlay .skill-pill {
        font-size: .82rem;
        border-radius: 10px;
      }
      .bet-bar {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex-wrap: nowrap;
      }
      .bet-info {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .action-rail {
        position: sticky;
        bottom: calc(var(--safe-bottom) + 6px);
        align-items: stretch;
      }
      .action-icons {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
      .spin-btn {
        width: 100%;
        min-width: 0;
      }
      .drop-log {
        max-height: 140px;
      }
      .drop-panel {
        position: fixed;
        left: 16px;
        right: 16px;
        bottom: clamp(96px, 22vh, 260px);
        top: auto;
        width: auto;
      }
      .drop-overlay {
        align-items: flex-end;
        padding: 0 0 clamp(12px, 3vh, 18px) 0;
      }
      .drop-panel--overlay {
        position: relative;
        left: auto;
        right: auto;
        bottom: auto;
        top: auto;
        width: calc(100% - 12px);
        max-height: 72vh;
        border-radius: 18px 18px 0 0;
        margin: 0 auto;
      }
      .hud {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        order: 3;
      }
      .hud-card {
        padding: 6px 8px;
        min-height: 54px;
      }
      .hud-value {
        font-size: .85rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-variant-numeric: tabular-nums;
      }
      .slot-topbar {
        gap: 8px;
        padding: 8px 10px;
        margin-inline: 10px;
      }
      .topbar-row {
        grid-template-columns: 1fr;
      }
      .top-actions {
        justify-content: flex-end;
      }
      .currency-row {
        flex-wrap: wrap;
        gap: 8px;
      }
      .machine-chip {
        justify-content: flex-end;
      }
      .machine-messages {
        min-height: 42px;
      }
      .action-select {
        display: block;
        width: 100%;
        padding: 10px 8px;
        border-radius: 12px;
        border: 1px solid rgba(148,163,184,.35);
        background: rgba(8,12,24,.9);
        color: var(--text);
        font-size: .9rem;
      }
      .account-sheet {
        width: calc(100% - 32px);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        bottom: auto;
        right: auto;
      }
      .machine-card {
        min-width: 120px;
        scroll-snap-align: start;
      }
      .chip {
        min-height: 46px;
      }
    }

    @media (max-width: 480px) {
      .grid-two,
      dl,
      .auth-card,
      .account-grid,
      .hud--ribbon,
      .bet-info,
      .layout-stats,
      .action-icons,
      .gear-card-grid,
      .gear-slots,
      .card-slots,
      .gear-inventory,
      .card-collection,
      .hud,
      .action-buttons {
        grid-template-columns: 1fr;
      }

      .top-actions,
      .machine-chip {
        flex-wrap: wrap;
      }

      .currency-chip {
        min-width: 0;
      }

      .currency-chip strong {
        white-space: normal;
      }

      .bonus-item {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    @media (max-width: 420px) {
      header h1 {
        font-size: 1.4rem;
      }
      header p {
        font-size: .9rem;
      }
      main > * {
        margin-inline: 10px;
      }
      .panel {
        padding: 14px;
      }
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      .controls input[type="number"] {
        width: 100%;
      }
      .controls button {
        width: 100%;
      }
      .reels {
        gap: 8px;
      }
      .slot-cell {
        font-size: 2.2rem;
      }
    }
  </style>
</head>
<body>
  <div class="auth-overlay" id="auth-overlay" aria-hidden="false" data-hidden="false">
    <div class="auth-card">
      <div class="auth-copy">
        <p class="status-pill ghost"> Demo Slot Machine</p>
        <h2>Log in to save your credits and keep the reels rolling.</h2>
        <p>This is a fun, server-backed slot machine demo. No real money is involved. Every spin is validated in AWS so balances carry across devices.</p>
        <p class="muted-text small">Passwords are hashed before storing and sessions auto-expire. Have fun exploring the animations and payouts.</p>
      </div>
      <div class="auth-body" id="auth-body" data-mode="login">
        <div class="auth-tabs" role="tablist">
          <button type="button" class="auth-tab active" data-mode="login">Sign In</button>
          <button type="button" class="auth-tab" data-mode="register">Create Account</button>
        </div>
        <div class="auth-forms">
          <label>
            Email
            <input type="email" id="auth-email" autocomplete="email" placeholder="you@example.com" required />
          </label>
          <label>
            Password
            <input type="password" id="auth-password" autocomplete="current-password" placeholder="At least 8 characters" required />
          </label>
          <label id="auth-confirm-group" hidden>
            Confirm password
            <input type="password" id="auth-confirm" autocomplete="new-password" placeholder="Repeat password" />
          </label>
          <div class="auth-actions">
            <button type="button" class="ghost-btn primary" id="auth-submit">Sign In</button>
            <button type="button" class="ghost-btn tertiary" id="auth-info">Need access? Register in seconds.</button>
          </div>
          <p class="muted-text small" id="auth-note">Passwords never leave AWS without hashing. Sessions expire automatically to keep balances safe.</p>
          <div class="alert" id="auth-alert" hidden role="status" aria-live="polite" tabindex="-1"></div>
        </div>
      </div>
    </div>
  </div>
  <a class="skip-link" href="#main">Skip to content</a>
  <main id="main" data-api-base="https://4kvebym8b3.execute-api.us-east-2.amazonaws.com/prod" data-max-bet="100" data-machine-config="slot-config/classic.json">
    <nav class="desktop-nav" id="desktop-nav" aria-label="Game sections" data-requires-auth hidden>
      <button type="button" data-pane-target="play" class="active">Play</button>
      <button type="button" data-pane-target="stats">Stats</button>
      <button type="button" data-pane-target="paytable">Paytable</button>
      <button type="button" data-pane-target="items">Items</button>
      <button type="button" data-pane-target="log">Log</button>
      <button type="button" data-pane-target="upgrades">Upgrades</button>
    </nav>
    <div class="slot-topbar" data-requires-auth hidden>
      <div class="topbar-row">
        <div class="currency-row currency-row--top">
          <div class="currency-chip" id="credits-chip" aria-label="Credits">
            <span aria-hidden="true"></span>
            <strong id="hud-balance">$0</strong>
          </div>
          <div class="currency-chip" id="vip-chip" aria-label="VIP Marks">
            <span aria-hidden="true"></span>
            <strong id="hud-vip">0</strong>
          </div>
          <div class="top-actions">
            <button type="button" class="status-icon" id="premium-shop-btn" aria-label="Premium shop">
              <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
                <path d="M5 7h14l-1 12H6L5 7zm3-4h8l1 3H7l1-3z" fill="currentColor"/>
                <circle cx="9" cy="19.5" r="1" fill="currentColor"/>
                <circle cx="15" cy="19.5" r="1" fill="currentColor"/>
              </svg>
            </button>
            <button type="button" class="status-icon" id="drop-rates-play-btn" aria-label="Drop rates">
              <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
                <path d="M12 3l7 7-7 7-7-7 7-7z" fill="none" stroke="currentColor" stroke-width="1.6"></path>
                <path d="M12 6v6l4 4" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
              </svg>
            </button>
            <button type="button" class="status-icon" id="account-toggle" aria-label="Account details">
              <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
                <path d="M12 13.5c3.05 0 5.5-2.45 5.5-5.5S15.05 2.5 12 2.5 6.5 4.95 6.5 8s2.45 5.5 5.5 5.5zm0 2c-4.05 0-7.5 2.45-7.5 5.5 0 .28.22.5.5.5h14c.28 0 .5-.22.5-.5 0-3.05-3.45-5.5-7.5-5.5z" fill="currentColor"/>
              </svg>
            </button>
            <button type="button" class="status-icon status-icon--logout" id="logout-btn" aria-label="Log out">
              <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
                <path d="M14 3a1 1 0 00-1 1v4h2V5h4v14h-4v-3h-2v4a1 1 0 001 1h6a1 1 0 001-1V4a1 1 0 00-1-1h-6z" fill="currentColor"/>
                <path d="M15 11H7V9l-5 3 5 3v-2h8v-2z" fill="currentColor"/>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <nav class="mobile-nav" id="mobile-nav" aria-label="Game sections">
        <button type="button" data-mobile-target="play" class="active" aria-label="Play">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <rect x="3" y="5" width="18" height="14" rx="3" ry="3" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
            <circle cx="9" cy="12" r="1.6" fill="currentColor"></circle>
            <circle cx="12" cy="12" r="1.6" fill="currentColor" opacity=".65"></circle>
            <circle cx="15" cy="12" r="1.6" fill="currentColor" opacity=".4"></circle>
          </svg>
          <span>Play</span>
        </button>
        <button type="button" data-mobile-target="stats" aria-label="Stats">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <path d="M5 17v-4m4 4V7m4 10v-7m4 7V9" fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.6"></path>
          </svg>
          <span>Stats</span>
        </button>
        <button type="button" data-mobile-target="paytable" aria-label="Paytable">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <rect x="5" y="6" width="14" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
            <path d="M8 9h8M8 12h8M8 15h5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
          </svg>
          <span>Pay</span>
        </button>
        <button type="button" data-mobile-target="items" aria-label="Items">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <rect x="5" y="4" width="14" height="16" rx="3" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
            <path d="M9 9h6M9 13h3" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
          </svg>
          <span>Items</span>
        </button>
        <button type="button" data-mobile-target="log" aria-label="Log">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <rect x="6" y="5" width="12" height="14" rx="2" fill="none" stroke="currentColor" stroke-width="1.4"></rect>
            <path d="M9 9h6M9 12h6M9 15h4" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
          </svg>
          <span>Log</span>
        </button>
        <button type="button" data-mobile-target="upgrades" aria-label="Upgrades">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
            <path d="M12 5v14m0-14l-3 3m3-3l3 3" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" fill="none"></path>
            <path d="M7 19h10" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"></path>
          </svg>
          <span>Upg</span>
        </button>
      </nav>
    </div>
    <section class="panel account-sheet" id="account-panel" role="dialog" aria-modal="true" aria-hidden="true" hidden tabindex="-1">
      <div class="account-sheet__header">
        <div>
          <p class="muted-text">Signed in as</p>
          <strong id="account-user"></strong>
        </div>
        <button type="button" class="ghost-btn tertiary" id="account-close" aria-label="Close account details">Close</button>
      </div>
      <div class="account-grid">
        <div class="account-actions">
          <div class="actions">
            <button type="button" class="ghost-btn secondary" id="sync-btn">Sync balance</button>
            <button type="button" class="ghost-btn tertiary" id="reset-btn">Reset session</button>
            <button type="button" class="ghost-btn primary" id="debug-add-coins" hidden>+100k credits</button>
            <button type="button" class="ghost-btn danger" id="delete-account-btn">Delete account</button>
          </div>
          <div class="actions">
            <button type="button" class="ghost-btn secondary" id="export-state-btn">Export key</button>
            <input type="text" id="import-state-input" placeholder="Paste key to import" aria-label="Import key" />
            <button type="button" class="ghost-btn tertiary" id="import-state-btn">Import key</button>
          </div>
          <p class="muted-text small" id="transfer-status"></p>
        </div>
        <div>
          <p class="hud-label">Recent activity</p>
          <div class="account-log" id="account-log" aria-live="polite"></div>
        </div>
      </div>
    </section>

    <section class="panel slot-machine" data-requires-auth hidden data-mobile-pane="play" data-mobile-active="true">
      <div class="slot-machine__body">
        <div class="machine-stage">
          <div class="machine-frame">
            <div class="machine-frame__glow"></div>
            <div class="flyover flyover--level" id="flyover-level" aria-live="polite"></div>
            <div class="flyover flyover--xp" id="flyover-xp" aria-live="polite"></div>
            <div class="flyover flyover--loot" id="flyover-loot" aria-live="polite"></div>
            <div class="flyover flyover--top" id="flyover-top" aria-live="polite"></div>
            <div class="machine-xp">
            <div class="machine-flyout" id="machine-flyout" data-open="false">
              <button type="button" class="machine-flyout__toggle" id="machine-picker" aria-label="Change machine" aria-haspopup="true" aria-expanded="false">
                <span id="machine-picker-label" class="sr-only">Switch</span>
                <strong id="machine-picker-level" aria-hidden="true">Lv 0</strong>
              </button>
              <div class="machine-flyout__panel">
                <div class="machine-flyout__head">
                  <p class="hud-label">Select machine</p>
                </div>
                <div class="machine-list" id="machine-list" role="list"></div>
              </div>
            </div>
            <div class="xp-track" aria-label="Machine XP progress">
              <div class="xp-fill" id="machine-xp-fill"></div>
            </div>
            <div class="machine-level machine-perks">
              <button type="button" class="perks-btn" id="perks-btn" aria-label="View level perks">?</button>
              <div class="perks-popover" id="perks-popover" role="status" aria-live="polite"></div>
            </div>
          </div>
            <div class="machine-frame__reels" id="reel-stage">
              <div class="skill-strip skill-strip--overlay" id="skill-strip" aria-label="Skills"></div>
              <div class="slot-grid" id="slot-grid" aria-live="polite"></div>
              <div class="line-overlay" id="line-overlay" aria-hidden="true"></div>
            </div>
          </div>
            <div class="machine-messages machine-messages--stage">
              <div class="machine-outcome-group">
                <p class="machine-outcome" id="machine-outcome">Sign in to start spinning.</p>
                <p class="machine-lines" id="machine-lines"></p>
              </div>
              <p class="machine-error" id="error" role="status" aria-live="polite"></p>
              <div class="alert" id="alert" hidden></div>
            </div>
        </div>
        <div class="control-deck control-deck--ground">
          <div class="bet-bar">
            <div class="bet-info">
              <div class="info-pill">
                <p class="hud-label">Bet</p>
                <strong class="hud-value" id="hud-bet">$0</strong>
              </div>
              <div class="info-pill">
                <p class="hud-label">Last win</p>
                <strong class="hud-value" id="hud-last-win">$0</strong>
              </div>
            </div>
            <div class="bet-presets" role="group" aria-label="Quick bet percentages">
              <button type="button" class="chip" data-chip="pct-10" aria-label="Bet ten percent of balance">10%</button>
              <button type="button" class="chip" data-chip="pct-25" aria-label="Bet twenty five percent of balance">25%</button>
              <button type="button" class="chip" data-chip="pct-50" aria-label="Bet fifty percent of balance">50%</button>
              <button type="button" class="chip" data-chip="pct-100" aria-label="Bet all balance">100%</button>
            </div>
          </div>
          <div class="action-rail action-rail--spin">
            <button type="button" class="spin-btn spin-btn--secondary" id="auto-spin-btn" aria-pressed="false">Auto</button>
            <button type="button" class="spin-btn" id="spin-btn" disabled>Spin</button>
          </div>
        </div>
      </div>
    </section>

    <section class="grid grid-two" data-requires-auth hidden data-mobile-pane="stats">
      <div class="panel">
        <h2>Session</h2>
        <dl id="session-stats">
          <dt>Player ID</dt><dd id="player-id">N/A</dd>
          <dt>Balance</dt><dd id="balance">N/A</dd>
          <dt>Max Bet</dt><dd id="max-bet">N/A</dd>
          <dt>Total Spins</dt><dd id="spin-count">N/A</dd>
        </dl>
      </div>
      <div class="panel">
        <h2>Last Result</h2>
        <dl>
          <dt>Outcome</dt><dd id="last-outcome">N/A</dd>
          <dt>Winnings</dt><dd id="last-win">N/A</dd>
          <dt>Multiplier</dt><dd id="last-multiplier">N/A</dd>
          <dt>Timestamp</dt><dd id="last-time">N/A</dd>
        </dl>
      </div>
      <div class="panel" id="daily-panel">
        <div class="status-row">
          <h2>Daily Rewards</h2>
          <span class="status-pill" id="daily-status">Syncing</span>
        </div>
        <p class="muted-text" id="daily-streak">Day 1 of 7</p>
        <div class="daily-reward" id="daily-reward">
          <div class="daily-row">
            <span class="hud-label">Today&apos;s reward</span>
            <strong class="hud-value" id="daily-reward-main">$0</strong>
          </div>
          <div class="daily-items" id="daily-items"></div>
        </div>
        <div class="actions">
          <button type="button" class="ghost-btn primary" id="daily-claim-btn">Claim</button>
        </div>
        <p class="muted-text small" id="daily-next-reset">Resets daily</p>
      </div>
      <div class="panel" id="bonus-panel">
        <h2>Equipment Bonuses</h2>
        <ul class="bonus-list" id="bonus-list">
          <li class="bonus-item"><span class="bonus-label">Calculating bonuses</span></li>
        </ul>
      </div>
    </section>

    <section class="panel paytable-panel" data-requires-auth hidden data-mobile-pane="paytable">
      <h2>Paytable</h2>
      <ul class="paytable" id="paytable"></ul>
      <p class="muted-text small">Multipliers apply to your active bet. Triple matches and pairs are calculated server-side.</p>
    </section>

    <section class="panel items-panel" data-requires-auth hidden data-mobile-pane="items">
      <div class="items-grid">
        <div class="drop-stack">
          <div class="drop-header">
            <div>
              <p class="hud-label">Inventory</p>
              <div class="inventory-grid" id="inventory-grid"></div>
            </div>
            <div class="drop-actions">
              <button type="button" class="ghost-btn secondary" id="drop-rates-btn">Drop rates</button>
              <button type="button" class="ghost-btn tertiary" id="drop-skill-btn">Drop boost</button>
              <button type="button" class="ghost-btn tertiary" id="drop-close-btn">Close</button>
            </div>
          </div>
          <div class="drop-log" id="drop-log" aria-live="polite"></div>
          <div class="drop-panel" id="drop-panel" hidden aria-live="polite" data-panel-type="inventory" data-drop-body tabindex="-1"></div>
        </div>
        <div class="gear-card-grid">
          <div class="gear-panel" id="gear-panel">
            <div class="panel-heading">
              <div>
                <p class="hud-label">Equipment</p>
                <strong class="hud-value" id="gear-summary">0/3 equipped</strong>
              </div>
              <span class="status-pill ghost" id="gear-cap">3 slots</span>
            </div>
            <div class="gear-slots" id="gear-slots"></div>
            <div class="gear-inventory" id="gear-inventory"></div>
          </div>
          <div class="card-panel" id="card-panel">
            <div class="panel-heading">
              <div>
                <p class="hud-label">VIP Cards</p>
                <strong class="hud-value" id="card-summary">Deck 0/3</strong>
              </div>
              <span class="status-pill ghost" id="card-cap">3 slots</span>
            </div>
            <div class="card-slots" id="card-slots"></div>
            <div class="card-collection" id="card-collection"></div>
          </div>
        </div>
      </div>
    </section>
    <div class="premium-panel" id="premium-panel" hidden role="dialog" aria-modal="true" aria-label="Premium shop">
      <div class="premium-card">
        <div class="premium-header">
          <div>
            <p class="hud-label">Premium Shop</p>
            <strong class="hud-value" id="premium-vip-balance">VIP 0</strong>
          </div>
          <div class="actions">
            <button type="button" class="ghost-btn tertiary" id="premium-close">Close</button>
          </div>
        </div>
        <div class="premium-grid" id="premium-grid"></div>
      </div>
    </div>

        <section class="panel log-panel" data-requires-auth hidden data-mobile-pane="log">
          <h2>Server Event Log</h2>
          <div class="log" id="log" aria-live="polite"></div>
        </section>

    <section class="panel upgrade-panel" id="upgrade-panel" data-requires-auth hidden data-mobile-pane="upgrades">
      <h2>Machine Upgrades</h2>
      <div class="upgrade-grid" id="upgrade-grid"></div>
    </section>
  </main>

  <div class="drop-overlay" id="drop-overlay" hidden aria-hidden="true">
    <div class="drop-panel drop-panel--overlay" id="drop-panel-overlay" role="dialog" aria-modal="true" aria-label="Drop rates" data-panel-type="overlay" tabindex="-1">
      <div class="drop-panel__header">
        <h4>Drop rates</h4>
        <button type="button" class="ghost-btn tertiary" id="drop-overlay-close">Close</button>
      </div>
      <div data-drop-body id="drop-panel-overlay-body"></div>
    </div>
  </div>

  <script src="js/demos/aws-client.js"></script>
  <script>
    (() => {
      const DEBUG = true;
      const debug = (...args) => {
        if (!DEBUG) return;
        console.debug('[slot-demo]', ...args);
      };
      const debugError = (scope, error, extra = {}) => {
        if (!DEBUG) return;
        console.error(`[slot-demo][${scope}]`, error, extra);
      };
      const logLocal = (scope, payload) => {
        if (!DEBUG) return;
        console.debug(`[slot-demo][local][${scope}]`, payload);
      };
      const logAction = (scope, payload) => {
        if (!DEBUG) return;
        console.info(`[slot-demo][action][${scope}]`, payload);
      };
      const debugInfo = (scope, data) => {
        if (!DEBUG) return;
        console.info(`[slot-demo][${scope}]`, data);
      };
      const collectPendingIdle = () => {
        if (!state.pendingIdleCoins) return;
        const delta = Math.max(0, state.pendingIdleCoins);
        addMachineBalance(delta);
        state.pendingIdleCoins = 0;
        if (els.balance) els.balance.textContent = formatMoney(state.balance, { compact: false });
        updateHud();
        if (els.spinBtn) {
          els.spinBtn.textContent = `Spin: ${formatMoney(state.bet || 0)}`;
        }
      };
      window.addEventListener('error', (event) => {
        debugError('window-error', event.error || event.message, { event });
      });
      window.addEventListener('unhandledrejection', (event) => {
        debugError('unhandled-rejection', event.reason, {});
      });

      const setViewportUnit = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--app-vh', `${vh}px`);
      };
      setViewportUnit();
      window.addEventListener('resize', setViewportUnit);
      window.addEventListener('orientationchange', setViewportUnit, { passive: true });

      const root = document.getElementById('main');
      if (!root) {
        debugError('init', 'Missing #main element');
        return;
      }
      const DEFAULT_API_BASE = root.dataset.apiBase;
      const STORAGE_KEY = 'demo.endpoint.slot';
      const { resolveEndpoint } = window.DemoAws;
      const endpointConfig = { defaultUrl: DEFAULT_API_BASE, storageKey: STORAGE_KEY };
      const API_BASE = resolveEndpoint(endpointConfig).replace(/\/$/, '');
      const DEFAULT_MAX_BET = Number(root.dataset.maxBet) || 100;
      const MACHINE_CONFIG_URL = root.dataset.machineConfig || '';
      const MACHINE_LIST_URL = 'slot-config/machines/index.json';
      const MACHINE_CONFIG_DIR = 'slot-config/machines';
      const DROP_TABLE_URL = 'slot-config/drop-tables.json';
      const GEAR_DEFS_URL = 'slot-config/gear-definitions.json';
      const CARD_DEFS_URL = 'slot-config/card-definitions.json';
      const LOCAL_MACHINE_KEY = 'slotMachineActiveMachine';
      const LOCAL_EQUIPMENT_KEY = 'slotMachineEquipment';
      const LOCAL_CARD_KEY = 'slotMachineCards';
      const LOCAL_UPGRADES_KEY = 'slotDemoLocalUpgrades';
      const SESSION_SYNC_MS = 60000;
      let sessionSyncTimer = null;
      let sessionSyncInFlight = false;
      const storageKeys = {
        player: 'slotMachineDemoPlayerId',
        token: 'slotMachineAuthToken',
        user: 'slotMachineAuthUser'
      };
      const DEBUG_EMAIL = 'danielshort3@gmail.com';
      const requestFrame = window.requestAnimationFrame?.bind(window) || (cb => setTimeout(() => cb(performance.now()), 1000 / 60));
      const cancelFrame = window.cancelAnimationFrame?.bind(window) || clearTimeout;
      const AUTH_MODE_KEY = 'slotMachineAuthMode';
      const urlParams = new URLSearchParams(window.location.search);
      const offlineParam = urlParams.get('offline');
      const offlineForced = offlineParam === '1' || offlineParam === 'true';
      const offlineDisabled = offlineParam === '0' || offlineParam === 'false';
      const OFFLINE_USER = 'Offline Demo';
      const OFFLINE_SNAPSHOT_KEY = 'slotMachineOfflineSnapshot';
      const OFFLINE_START_BALANCE = 50000;
      const isLocalhost = ['localhost', '127.0.0.1', '::1'].includes(window.location.hostname);
      const offlineDefault = (window.location.protocol === 'file:' || isLocalhost);
      const offlineMode = offlineForced || (offlineDefault && !offlineDisabled) || (!offlineDisabled && !getStored(storageKeys.token));
      const reelState = new Map();
      const getStored = (key) => {
        const value = localStorage.getItem(key);
        return value && value !== 'null' ? value : null;
      };
      const clearDebugLocalState = () => {
        const keys = [
          LOCAL_MACHINE_KEY,
          LOCAL_EQUIPMENT_KEY,
          LOCAL_CARD_KEY,
          LOCAL_UPGRADES_KEY,
          storageKeys.player,
          storageKeys.token,
          storageKeys.user,
          OFFLINE_SNAPSHOT_KEY
        ];
        keys.forEach(key => {
          try { localStorage.removeItem(key); } catch { /* ignore */ }
        });
        logLocal('reset', 'Cleared local state for debug');
      };
      clearDebugLocalState();
      const DEFAULT_SYMBOLS = [
        { key: 'cherry', label: 'Cherry', asset: 'img/slot/classic/symbols/cherry.png' },
        { key: 'lemon', label: 'Lemon', asset: 'img/slot/classic/symbols/lemon.png' },
        { key: 'orange', label: 'Orange', asset: 'img/slot/classic/symbols/orange.png' },
        { key: 'plum', label: 'Plum', asset: 'img/slot/classic/symbols/plum.png' },
        { key: 'watermelon', label: 'Watermelon', asset: 'img/slot/classic/symbols/watermelon.png' },
        { key: 'horseshoe', label: 'Horseshoe', asset: 'img/slot/classic/symbols/horseshoe.png' },
        { key: 'bell', label: 'Bell', asset: 'img/slot/classic/symbols/bell.png' },
        { key: 'diamond', label: 'Diamond', asset: 'img/slot/classic/symbols/diamond.png' },
        { key: 'seven', label: 'Lucky Seven', asset: 'img/slot/classic/symbols/seven.png' },
        { key: 'crown', label: 'Crown', asset: 'img/slot/classic/symbols/crown.png' },
        { key: 'wild', label: 'Wild', asset: 'img/slot/classic/symbols/wild.png' },
        { key: 'bonus', label: 'Bonus Sigil', asset: 'img/slot/classic/symbols/bonus.png' }
      ];
      const PLACEHOLDER_ASSET = 'img/slot/placeholder.png';
      const buildSymbolMap = (symbols = [], baseMap = null, placeholderAsset = PLACEHOLDER_ASSET) => {
        const seedEntries = baseMap
          ? Array.from(baseMap.entries())
          : DEFAULT_SYMBOLS.map(entry => [entry.key, { ...entry }]);
        const map = new Map(seedEntries.map(([key, val]) => [key, { ...val, asset: val.asset || placeholderAsset }]));
        if (!Array.isArray(symbols) || !symbols.length) return map;
        symbols.forEach(entry => {
          if (!entry || !entry.key) return;
          const prev = map.get(entry.key) || { key: entry.key, label: entry.label || entry.key, asset: placeholderAsset };
          map.set(entry.key, {
            ...prev,
            ...entry,
            asset: entry.asset || prev.asset || placeholderAsset
          });
        });
        return map;
      };
      const cloneSymbolMap = (map) => new Map(Array.from(map.entries()).map(([key, val]) => [key, { ...val }]));
      const DEFAULT_SYMBOL_MAP = buildSymbolMap(DEFAULT_SYMBOLS, null, PLACEHOLDER_ASSET);
      const DAILY_LENGTH = 7;
      const OFFLINE_DATA = {
        machineList: ['classic', 'burst', 'charm', 'goldrush', 'cyber', 'pirate', 'dragon', 'cosmic'],
        machines: {
          classic: {
            id: 'classic',
            name: 'Lucky Lambda Classic',
            tier: 'Offline Demo',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: DEFAULT_SYMBOLS,
            payouts: {
              cherry: 5,
              lemon: 6,
              orange: 7,
              plum: 8,
              watermelon: 10,
              horseshoe: 12,
              bell: 16,
              diamond: 20,
              seven: 25,
              crown: 30,
              wild: 50,
              bonus: 70
            },
            assets: {
              icon: 'img/slot/classic/icon.png',
              frame: 'img/slot/classic/frame.png',
              background: {
                portrait: 'img/slot/classic/background_vertical.png',
                landscape: 'img/slot/classic/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: PLACEHOLDER_ASSET
            },
            spinTiming: {
              overspin: [10, 12, 15],
              brake: 180
            },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          },
          burst: {
            id: 'burst',
            name: 'Burst Booster',
            tier: 'Fine',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: [
              { key: 'fuse', label: 'Fuse', asset: 'img/slot/burst/symbols/fuse.png' },
              { key: 'emblem', label: 'Emblem', asset: 'img/slot/burst/symbols/emblem.png' },
              { key: 'star', label: 'Star', asset: 'img/slot/burst/symbols/star.png' },
              { key: 'firework', label: 'Firework', asset: 'img/slot/burst/symbols/firework.png' },
              { key: 'medal', label: 'Medal', asset: 'img/slot/burst/symbols/medal.png' },
              { key: 'orb', label: 'Orb', asset: 'img/slot/burst/symbols/orb.png' },
              { key: 'wheel', label: 'Wheel', asset: 'img/slot/burst/symbols/wheel.png' },
              { key: 'seven', label: 'Seven', asset: 'img/slot/burst/symbols/seven.png' },
              { key: 'wild', label: 'Wild', asset: 'img/slot/burst/symbols/wild.png' },
              { key: 'bonus', label: 'Bonus', asset: 'img/slot/burst/symbols/bonus.png' }
            ],
            payouts: {
              fuse: 6,
              emblem: 7,
              star: 8,
              firework: 9,
              medal: 12,
              orb: 16,
              wheel: 22,
              seven: 30,
              wild: 50,
              bonus: 80
            },
            assets: {
              icon: 'img/slot/burst/icon.png',
              frame: 'img/slot/burst/frame.png',
              background: {
                portrait: 'img/slot/burst/background_vertical.png',
                landscape: 'img/slot/burst/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: 'img/slot/placeholder.png'
            },
            spinTiming: { overspin: [10, 12, 15], brake: 180 },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          },
          charm: {
            id: 'charm',
            name: 'Lucky Charm',
            tier: 'Rare',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: [
              { key: 'clover', label: 'Clover', asset: 'img/slot/charm/symbols/clover.png' },
              { key: 'horseshoe', label: 'Horseshoe', asset: 'img/slot/charm/symbols/horseshoe.png' },
              { key: 'wishbone', label: 'Wishbone', asset: 'img/slot/charm/symbols/wishbone.png' },
              { key: 'ladybug', label: 'Ladybug', asset: 'img/slot/charm/symbols/ladybug.png' },
              { key: 'rabbit_foot', label: 'Rabbit Foot', asset: 'img/slot/charm/symbols/rabbit_foot.png' },
              { key: 'rainbow', label: 'Rainbow', asset: 'img/slot/charm/symbols/rainbow.png' },
              { key: 'lucky_hat', label: 'Lucky Hat', asset: 'img/slot/charm/symbols/lucky_hat.png' },
              { key: 'shamrock', label: 'Shamrock', asset: 'img/slot/charm/symbols/shamrock.png' },
              { key: 'pot_of_gold', label: 'Pot Of Gold', asset: 'img/slot/charm/symbols/pot_of_gold.png' },
              { key: 'wild', label: 'Wild', asset: 'img/slot/charm/symbols/wild.png' },
              { key: 'bonus', label: 'Bonus', asset: 'img/slot/charm/symbols/bonus.png' }
            ],
            payouts: {
              clover: 7,
              horseshoe: 8,
              wishbone: 9,
              ladybug: 10,
              rabbit_foot: 12,
              rainbow: 18,
              lucky_hat: 24,
              shamrock: 28,
              pot_of_gold: 35,
              wild: 50,
              bonus: 90
            },
            assets: {
              icon: 'img/slot/charm/icon.png',
              frame: 'img/slot/charm/frame.png',
              background: {
                portrait: 'img/slot/charm/background_vertical.png',
                landscape: 'img/slot/charm/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: 'img/slot/placeholder.png'
            },
            spinTiming: { overspin: [10, 12, 15], brake: 180 },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          },
          goldrush: {
            id: 'goldrush',
            name: 'Gold Rush',
            tier: 'Epic',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: [
              { key: 'pickaxe', label: 'Pickaxe', asset: 'img/slot/goldrush/symbols/pickaxe.png' },
              { key: 'gold_pan', label: 'Gold Pan', asset: 'img/slot/goldrush/symbols/gold_pan.png' },
              { key: 'boot_spur', label: 'Boot Spur', asset: 'img/slot/goldrush/symbols/boot_spur.png' },
              { key: 'dynamite', label: 'Dynamite', asset: 'img/slot/goldrush/symbols/dynamite.png' },
              { key: 'lantern', label: 'Lantern', asset: 'img/slot/goldrush/symbols/lantern.png' },
              { key: 'gold_nugget', label: 'Gold Nugget', asset: 'img/slot/goldrush/symbols/gold_nugget.png' },
              { key: 'gold_minecart', label: 'Gold Minecart', asset: 'img/slot/goldrush/symbols/gold_minecart.png' },
              { key: 'gold_bars', label: 'Gold Bars', asset: 'img/slot/goldrush/symbols/gold_bars.png' },
              { key: 'prospector_badge', label: 'Prospector Badge', asset: 'img/slot/goldrush/symbols/prospector_badge.png' },
              { key: 'wild', label: 'Wild', asset: 'img/slot/goldrush/symbols/wild.png' },
              { key: 'bonus', label: 'Bonus', asset: 'img/slot/goldrush/symbols/bonus.png' }
            ],
            payouts: {
              pickaxe: 8,
              gold_pan: 9,
              boot_spur: 10,
              dynamite: 12,
              lantern: 14,
              gold_nugget: 20,
              gold_minecart: 26,
              gold_bars: 32,
              prospector_badge: 40,
              wild: 50,
              bonus: 100
            },
            assets: {
              icon: 'img/slot/goldrush/icon.png',
              frame: 'img/slot/goldrush/frame.png',
              background: {
                portrait: 'img/slot/goldrush/background_vertical.png',
                landscape: 'img/slot/goldrush/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: 'img/slot/placeholder.png'
            },
            spinTiming: { overspin: [10, 12, 15], brake: 180 },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          },
          cyber: {
            id: 'cyber',
            name: 'Cyber Spin',
            tier: 'Elite',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: [
              { key: 'circuit', label: 'Circuit', asset: 'img/slot/cyber/symbols/circuit.png' },
              { key: 'heart', label: 'Heart', asset: 'img/slot/cyber/symbols/heart.png' },
              { key: 'pixel_byte', label: 'Pixel Byte', asset: 'img/slot/cyber/symbols/pixel_byte.png' },
              { key: 'laser_pointer', label: 'Laser Pointer', asset: 'img/slot/cyber/symbols/laser_pointer.png' },
              { key: 'neon_diamond', label: 'Neon Diamond', asset: 'img/slot/cyber/symbols/neon_diamond.png' },
              { key: 'spade', label: 'Spade', asset: 'img/slot/cyber/symbols/spade.png' },
              { key: 'pixel_seven', label: 'Pixel Seven', asset: 'img/slot/cyber/symbols/pixel_seven.png' },
              { key: 'laser_star', label: 'Laser Star', asset: 'img/slot/cyber/symbols/laser_star.png' },
              { key: 'cyber_crown', label: 'Cyber Crown', asset: 'img/slot/cyber/symbols/cyber_crown.png' },
              { key: 'wild', label: 'Wild', asset: 'img/slot/cyber/symbols/wild.png' },
              { key: 'bonus', label: 'Bonus', asset: 'img/slot/cyber/symbols/bonus.png' }
            ],
            payouts: {
              circuit: 9,
              heart: 10,
              pixel_byte: 11,
              laser_pointer: 13,
              neon_diamond: 18,
              spade: 24,
              pixel_seven: 30,
              laser_star: 35,
              cyber_crown: 45,
              wild: 50,
              bonus: 110
            },
            assets: {
              icon: 'img/slot/cyber/icon.png',
              frame: 'img/slot/classic/frame.png',
              background: {
                portrait: 'img/slot/cyber/background_vertical.png',
                landscape: 'img/slot/cyber/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: 'img/slot/placeholder.png'
            },
            spinTiming: { overspin: [10, 12, 15], brake: 180 },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          },
          pirate: {
            id: 'pirate',
            name: "Pirate's Booty",
            tier: 'Mythic',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: [
              { key: 'anchor', label: 'Anchor', asset: 'img/slot/pirate/symbols/anchor.png' },
              { key: 'cannonball', label: 'Cannonball', asset: 'img/slot/pirate/symbols/cannonball.png' },
              { key: 'treasure_map', label: 'Treasure Map', asset: 'img/slot/pirate/symbols/treasure_map.png' },
              { key: 'parrot_feather', label: 'Parrot Feather', asset: 'img/slot/pirate/symbols/parrot_feather.png' },
              { key: 'skull', label: 'Skull', asset: 'img/slot/pirate/symbols/skull.png' },
              { key: 'pirate_hat', label: 'Pirate Hat', asset: 'img/slot/pirate/symbols/pirate_hat.png' },
              { key: 'compass', label: 'Compass', asset: 'img/slot/pirate/symbols/compass.png' },
              { key: 'treasure_chest', label: 'Treasure Chest', asset: 'img/slot/pirate/symbols/treasure_chest.png' },
              { key: 'wild', label: 'Wild', asset: 'img/slot/pirate/symbols/wild.png' },
              { key: 'bonus', label: 'Bonus', asset: 'img/slot/pirate/symbols/bonus.png' }
            ],
            payouts: {
              anchor: 10,
              cannonball: 11,
              treasure_map: 12,
              parrot_feather: 14,
              skull: 20,
              pirate_hat: 26,
              compass: 32,
              treasure_chest: 42,
              wild: 50,
              bonus: 125
            },
            assets: {
              icon: 'img/slot/pirate/icon.png',
              frame: 'img/slot/classic/frame.png',
              background: {
                portrait: 'img/slot/pirate/background_vertical.png',
                landscape: 'img/slot/pirate/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: 'img/slot/placeholder.png'
            },
            spinTiming: { overspin: [10, 12, 15], brake: 180 },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          },
          dragon: {
            id: 'dragon',
            name: "Dragon's Den",
            tier: 'Mythic',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: [
              { key: 'shield', label: 'Shield', asset: 'img/slot/dragon/symbols/shield.png' },
              { key: 'crystal', label: 'Crystal', asset: 'img/slot/dragon/symbols/crystal.png' },
              { key: 'rune', label: 'Rune', asset: 'img/slot/dragon/symbols/rune.png' },
              { key: 'torch', label: 'Torch', asset: 'img/slot/dragon/symbols/torch.png' },
              { key: 'dragon_egg', label: 'Dragon Egg', asset: 'img/slot/dragon/symbols/dragon_egg.png' },
              { key: 'flaming_sword', label: 'Flaming Sword', asset: 'img/slot/dragon/symbols/flaming_sword.png' },
              { key: 'dragon_eye', label: 'Dragon Eye', asset: 'img/slot/dragon/symbols/dragon_eye.png' },
              { key: 'fire_seven', label: 'Fire Seven', asset: 'img/slot/dragon/symbols/fire_seven.png' },
              { key: 'wild', label: 'Wild', asset: 'img/slot/dragon/symbols/wild.png' },
              { key: 'bonus', label: 'Bonus', asset: 'img/slot/dragon/symbols/bonus.png' }
            ],
            payouts: {
              shield: 11,
              crystal: 12,
              rune: 14,
              torch: 16,
              dragon_egg: 22,
              flaming_sword: 30,
              dragon_eye: 40,
              fire_seven: 50,
              wild: 50,
              bonus: 150
            },
            assets: {
              icon: 'img/slot/dragon/icon.png',
              frame: 'img/slot/classic/frame.png',
              background: {
                portrait: 'img/slot/dragon/background_vertical.png',
                landscape: 'img/slot/dragon/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: 'img/slot/placeholder.png'
            },
            spinTiming: { overspin: [10, 12, 15], brake: 180 },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          },
          cosmic: {
            id: 'cosmic',
            name: 'Cosmic Chaos',
            tier: 'Divine',
            rows: 5,
            reels: 5,
            baseRows: 3,
            baseReels: 3,
            maxRows: 5,
            maxReels: 5,
            baseSymbolCount: 5,
            symbols: [
              { key: 'meteor', label: 'Meteor', asset: 'img/slot/cosmic/symbols/meteor.png' },
              { key: 'rocket', label: 'Rocket', asset: 'img/slot/cosmic/symbols/rocket.png' },
              { key: 'satellite', label: 'Satellite', asset: 'img/slot/cosmic/symbols/satellite.png' },
              { key: 'asteroid', label: 'Asteroid', asset: 'img/slot/cosmic/symbols/asteroid.png' },
              { key: 'planet', label: 'Planet', asset: 'img/slot/cosmic/symbols/planet.png' },
              { key: 'galaxy_swirl', label: 'Galaxy Swirl', asset: 'img/slot/cosmic/symbols/galaxy_swirl.png' },
              { key: 'alien', label: 'Alien', asset: 'img/slot/cosmic/symbols/alien.png' },
              { key: 'crystal', label: 'Crystal', asset: 'img/slot/cosmic/symbols/crystal.png' },
              { key: 'wild', label: 'Wild', asset: 'img/slot/cosmic/symbols/wild.png' },
              { key: 'bonus', label: 'Bonus', asset: 'img/slot/cosmic/symbols/bonus.png' }
            ],
            payouts: {
              meteor: 12,
              rocket: 13,
              satellite: 14,
              asteroid: 16,
              planet: 24,
              galaxy_swirl: 32,
              alien: 42,
              crystal: 55,
              wild: 50,
              bonus: 170
            },
            assets: {
              icon: 'img/slot/cosmic/icon.png',
              frame: 'img/slot/cosmic/frame.png',
              background: {
                portrait: 'img/slot/cosmic/background_vertical.png',
                landscape: 'img/slot/cosmic/background_horizontal.png'
              },
              spinButton: 'img/slot/classic/spin-button.png',
              chip: 'img/slot/classic/circle.png',
              bet: 'img/slot/classic/square.png',
              info: 'img/slot/classic/rectangle.png',
              placeholder: 'img/slot/placeholder.png'
            },
            spinTiming: { overspin: [10, 12, 15], brake: 180 },
            upgradeCosts: {
              rows: [600, 1450],
              reels: [700, 1800],
              lines: [450, 1100, 2750]
            }
          }
        },
        dropTables: {
          tierWeights: { common: 0.8, rare: 0.15, epic: 0.05 },
          tables: {
            classic: {
              common: [
                { type: 'goldChip', name: 'Golden Chip', icon: 'img/slot/items/gold_chip.png', amount: 50, chance: 0.6 },
                { type: 'spinBooster', tier: 1, icon: 'img/slot/items/spinBoosterT1.png', amount: 1, chance: 0.15 }
              ],
              rare: [
                { type: 'gear', rarity: 'Rare', icon: 'img/slot/items/gear.png', amount: 1, chance: 0.25 },
                { type: 'card', tier: 'Rare', icon: 'img/slot/items/card.png', amount: 1, chance: 0.2 },
                { type: 'vipMarks', icon: 'img/slot/items/vip_mark.png', amount: 3, chance: 0.15 }
              ],
              epic: [
                { type: 'gear', rarity: 'Epic', icon: 'img/slot/items/gear.png', amount: 1, chance: 0.2 },
                { type: 'card', tier: 'Epic', icon: 'img/slot/items/card.png', amount: 1, chance: 0.2 },
                { type: 'spinBooster', tier: 2, icon: 'img/slot/items/spinBoosterT1.png', amount: 1, chance: 0.15 }
              ]
            }
          }
        },
        upgradeDefs: [
          { "key": "idle", "label": "Idle Coins", "description": "Gain +1 coin per second per level.", "category": "Economy", "cost": 120, "max": 5, "levels": ["+1/sec", "+2/sec", "+3/sec", "+4/sec", "+5/sec"], "defaultLevel": 1 },
          { "key": "retrigger", "label": "Retrigger", "description": "5% chance per level to replay a losing spin for free.", "category": "Spin", "cost": 220, "max": 5, "levels": ["5% chance", "10%", "15%", "20%", "25%"] },
          { "key": "speed", "label": "Faster Spins", "description": "Reduce spin duration by 10% per level.", "category": "Spin", "cost": 150, "max": 5, "levels": ["10% faster", "20%", "30%", "40%", "50%"] },
          { "key": "rows", "label": "Extra Rows", "description": "Add additional rows of symbols.", "category": "Layout", "cost": 600, "max": 2, "levels": ["Unlock second row", "Unlock third row"] },
          { "key": "lines", "label": "Multi-lines", "description": "Unlock diagonals, zigzags, then all-touching paylines.", "category": "Layout", "cost": 450, "max": 3, "levels": ["Unlock diagonals", "Unlock zigzags", "Unlock all-touching"] },
          { "key": "reels", "label": "Extra Reels", "description": "Increase reels for longer combos.", "category": "Layout", "cost": 700, "max": 2, "levels": ["Unlock 4th reel", "Unlock 5th reel"] },
          { "key": "premium", "label": "Premium Symbols", "description": "Add higher value symbols to the reels.", "category": "Symbols", "cost": 800, "max": 0, "dynamicMax": "premiumSymbols", "levels": [] },
          { "key": "disable", "label": "Cull Symbols", "description": "Remove low value symbols from the reels.", "category": "Symbols", "cost": 500, "max": 0, "dynamicMax": "cullSymbols", "levels": [] },
          { "key": "autoSpeed", "label": "Auto Speed", "description": "Reduce idle/autoplay delay by 10% per level.", "category": "Spin", "cost": 140, "max": 5, "levels": ["10% faster", "20%", "30%", "40%", "50%"] },
          { "key": "autoSpinUnlock", "label": "Auto Spin", "description": "Unlock auto spin mode.", "category": "Skills", "cost": 0, "max": 1, "clientOnly": true, "levels": ["Unlock auto spin"] },
          { "key": "autoSpinCount", "label": "Auto Spin Queue", "description": "Increase consecutive auto spins.", "category": "Auto Spin", "cost": 0, "max": 5, "clientOnly": true, "requires": "autoSpinUnlock", "levels": ["+5 spins", "+10", "+15", "+20", "+25"] },
          { "key": "retriggerQuality", "label": "Retrigger Quality", "description": "Increase retrigger chance by 5% per level.", "category": "Spin", "cost": 250, "max": 5, "levels": ["5% bonus", "10%", "15%", "20%", "25%"] },
          { "key": "dropBoost", "label": "Drop Boost", "description": "Increase drop rates slightly per level.", "category": "Drops", "cost": 160, "max": 5, "levels": ["+5% drops", "+10%", "+15%", "+20%", "+25%"] },
          { "key": "dropBoostUnlock", "label": "Drop Boost Skill", "description": "Unlock the drop-rate skill button.", "category": "Skills", "cost": 350, "max": 1, "levels": ["Unlock skill"] },
          { "key": "wildUnlock", "label": "Add Wilds", "description": "Unlock wild symbols on the reels.", "category": "Symbols", "cost": 1400, "max": 1, "levels": ["Unlock wilds"] },
          { "key": "wildFrequency", "label": "Wild Frequency", "description": "Increase wild appearance rate.", "category": "Symbols", "cost": 280, "max": 5, "levels": ["+20% wilds", "+40%", "+60%", "+80%", "+100%"] },
          { "key": "dropRateEffect", "label": "Drop Skill Power", "description": "Increase drop skill effect by 10% per level.", "category": "Drops", "cost": 200, "max": 10, "requires": "dropBoostUnlock", "levels": ["+10%", "+20%", "+30%", "+40%", "+50%", "+60%", "+70%", "+80%", "+90%", "+100%"] },
          { "key": "dropRateDuration", "label": "Drop Skill Duration", "description": "Increase drop skill duration by 1 minute per level.", "category": "Drops", "cost": 180, "max": 10, "requires": "dropBoostUnlock", "levels": ["1 min", "2 min", "3 min", "4 min", "5 min", "6 min", "7 min", "8 min", "9 min", "10 min"] },
          { "key": "betMultiplier", "label": "Bet Multiplier", "description": "Increase wager cap 10 per level.", "category": "Economy", "cost": 2500, "max": 5, "levels": ["10", "100", "1,000", "10,000", "100,000"] }
        ],
        gearDefs: {
          slots: ['Head', 'Outfit', 'Accessory', 'Pet', 'Trinket'],
          rarities: [
            { name: 'Common', dropChance: 0.6 },
            { name: 'Rare', dropChance: 0.3 },
            { name: 'Epic', dropChance: 0.1 }
          ],
          names: {
            Common: { Head: { name: 'Common Headgear' }, Outfit: { name: 'Common Outfit' }, Accessory: { name: 'Common Charm' }, Pet: { name: 'Common Pet' }, Trinket: { name: 'Common Trinket' } },
            Rare: { Head: { name: 'Rare Headgear' }, Outfit: { name: 'Rare Outfit' }, Accessory: { name: 'Rare Charm' }, Pet: { name: 'Rare Pet' }, Trinket: { name: 'Rare Trinket' } },
            Epic: { Head: { name: 'Epic Headgear' }, Outfit: { name: 'Epic Outfit' }, Accessory: { name: 'Epic Charm' }, Pet: { name: 'Epic Pet' }, Trinket: { name: 'Epic Trinket' } }
          },
          bonuses: {
            Common: { bonuses: [{ desc: '+{coinPct}% coins', coinPct: [2, 4] }, { desc: '+{dropPct}% drops', dropPct: [2, 4] }] },
            Rare: { bonuses: [{ desc: '+{coinPct}% coins', coinPct: [5, 8] }, { desc: '+{dropPct}% drops', dropPct: [5, 8] }] },
            Epic: { bonuses: [{ desc: '+{coinPct}% coins', coinPct: [10, 14] }, { desc: '+{dropPct}% drops', dropPct: [10, 14] }] }
          }
        },
        cardDefs: {
          definitions: [
            { name: 'Lucky Penny', tier: 'Rare', icon: 'img/slot/items/card.png', desc: 'Offline demo card that boosts coin gains.' },
            { name: 'Fortune Token', tier: 'Epic', icon: 'img/slot/items/card.png', desc: 'Offline demo card that boosts drop rates.' }
          ],
          effects: {
            'Lucky Penny': ['+5% coins', '+8% coins', '+10% coins'],
            'Fortune Token': ['+5% drops', '+8% drops', '+12% drops']
          }
        }
      };

  const state = {
        playerId: null,
        balance: 0,
        maxBet: DEFAULT_MAX_BET,
        bet: 25,
        busy: false,
        gameReady: false,
        auth: {
          token: offlineMode ? null : getStored(storageKeys.token),
          username: offlineMode ? OFFLINE_USER : getStored(storageKeys.user)
        },
        authMode: localStorage.getItem(AUTH_MODE_KEY) || 'login',
        offlineMode,
        machine: {
          id: 'classic',
          name: 'Lucky Lambda Classic',
          rows: 3,
          reels: 3,
          lineTier: 0,
          lines: [],
          payouts: {},
          assets: {},
          placeholder: PLACEHOLDER_ASSET,
          upgradeSettings: {
            baseRows: 3,
            maxRows: 5,
            baseReels: 3,
            maxReels: 5,
            costs: { rows: [], reels: [], lines: [] }
          },
          baseSymbolCount: 5,
          activeSymbols: [],
          spinTiming: { overspin: [10, 12, 15], brake: 180 }
        },
        drop: {
          tableKey: 'classic',
          table: { common: [], rare: [], epic: [] },
          tierWeights: { common: 0.8, rare: 0.15, epic: 0.05 },
          constants: { betScale: 0.1, win: 2, lose: 1, boostScale: 0.05 },
          inventory: {},
          lastDrops: [],
          history: [],
          lastTimestamp: 0
        },
        daily: {
          streak: 1,
          claimedToday: false,
          ready: false,
          lastClaimMs: 0,
          nextResetAt: 0,
          todayReward: null
        },
        skills: {
          dropRate: {
            active: false,
            expiresAt: 0,
            cooldownUntil: 0,
            spec: { durationMs: 60000, cooldownMs: 120000, multiplier: 1.05 }
          }
        },
        equipment: {
          slots: { Head: null, Outfit: null, Accessory: null, Pet: null, Trinket: null },
          inventory: [],
          slotCap: 3
        },
        cards: {
          deck: [],
          collection: [],
          slots: 3
        },
        globalPerks: {},
        premium: {
          purchases: {},
          mods: {
            lockSpinsBonus: 0,
            surgeMult: 1,
            bonusTier: 0,
            payoutMult: 1
          }
        },
        symbolMap: cloneSymbolMap(DEFAULT_SYMBOL_MAP),
        gridCells: new Map(),
        serverUpgrades: {},
        pendingUpgrades: {},
        upgrades: {},
        upgradeCatalog: [],
        lineFlashTimer: null,
        symbolWeights: { entries: [], total: 0 },
        autoSpin: { active: false, remaining: 0 },
        pendingFreeSpins: 0,
        lastWin: 0,
        pendingIdleCoins: 0,
        idleTicker: null,
        idleTickerActive: false,
        lastIdleTick: 0,
        spinCount: 0,
        currentRows: 3,
        currentReels: 3,
        currentLineTier: 0,
        sync: {
          rev: 0,
          dirty: false,
          inFlight: false,
          lastPush: 0,
          debounceTimer: null,
          queue: []
        },
        machines: {},
        worker: {
          active: false,
          timer: null,
          intervalMs: 1800
        },
        skills: {
          payout: { activeUntil: 0, cooldownUntil: 0, durationMs: 15000, cooldownMs: 30000, multiplier: 1.25 },
          dropRate: {
            active: false,
            expiresAt: 0,
            cooldownUntil: 0,
            spec: { durationMs: 60000, cooldownMs: 120000, multiplier: 1.05 }
          }
        },
        jackpots: {
          chance: 0.01,
          multiplier: 10,
          hotStreak: { wins: 0, bonusPct: 0.1 }
        }
      };
      window.slotDemoDebug = window.slotDemoDebug || {};
      window.slotDemoDebug.state = state;
      window.slotDemoDebug.log = debug;
      window.slotDemoDebug.dumpState = () => JSON.parse(JSON.stringify({
        ...state,
        symbolMap: Array.from(state.symbolMap.keys()),
        upgrades: { ...state.upgrades },
        dropInventory: { ...state.drop.inventory },
        daily: { ...state.daily }
      }));
      const machineCache = new Map();
      let machineList = [];
      let dropTableCache = null;
      let gearDefinitions = null;
      let cardDefinitions = null;
      const SYNC_ENDPOINT = '/sync';
      const SYNC_DEBOUNCE_MS = 5000;
      const EXPORT_VERSION = 1;

      const upgradeCatalogUrl = 'slot-config/upgrade-definitions.json';
      const tagClientOnly = (defs = []) => defs.map(def => ({ ...def, clientOnly: true }));
      const loadUpgradeCatalog = async () => {
        if (state.upgradeCatalog.length) {
          state.upgradeCatalog = tagClientOnly(state.upgradeCatalog);
          return state.upgradeCatalog;
        }
        if (state.offlineMode) {
          state.upgradeCatalog = tagClientOnly(OFFLINE_DATA.upgradeDefs || []);
          applyUpgradeState();
          renderUpgrades();
          return state.upgradeCatalog;
        }
        try {
          const res = await fetch(upgradeCatalogUrl, { cache: 'no-cache' });
          if (res.ok) {
            const defs = tagClientOnly(await res.json());
            if (Array.isArray(defs)) {
              state.upgradeCatalog = defs;
              applyUpgradeState();
              renderUpgrades();
              return defs;
            }
          }
        } catch (error) {
          console.error('upgrade catalog load failed', error);
        }
        return state.upgradeCatalog;
      };

      const getUpgradeDef = (key) => state.upgradeCatalog.find(def => def.key === key);
      const getLevelPerkEffects = (lvl = Math.max(0, Math.floor(state.machines?.[state.machine.id]?.lvl || 0))) => {
        const biasPct = Math.min(60, lvl * 2);
        const biasMult = 1 + biasPct / 100;
        const stack = (threshold, step = 5, pctPerStack = 0) => {
          if (lvl < threshold) return 0;
          return ((Math.floor((lvl - threshold) / step) + 1) * pctPerStack) / 100;
        };
        const wildBonus = stack(5, 5, 2);
        const dropBonus = stack(10, 5, 3);
        const payoutBonusPct = lvl < 15 ? 0 : 10 + Math.max(0, Math.floor((lvl - 15) / 5)) * 5;
        const speedBonus = stack(20, 5, 5);
        const capBoost = lvl < 25 ? 0 : Math.floor((lvl - 25) / 5) + 1;
        const jackpotBonus = stack(30, 5, 2);
        return {
          biasPct,
          biasMult,
          wildWeightMult: 1 + wildBonus,
          dropMult: 1 + dropBonus,
          payoutSkillMult: 1 + payoutBonusPct / 100,
          speedMult: 1 + speedBonus,
          capBoost,
          jackpotMult: 1 + jackpotBonus
        };
      };
      const LEVEL_CAP_BOOST_TARGETS = new Set(['idle', 'speed', 'dropBoost', 'retrigger', 'autoSpeed', 'betMultiplier']);
      const getLevelCapBoost = () => {
        return getLevelPerkEffects().capBoost || 0;
      };
      const PREMIUM_ITEMS = [
        { key: 'payoutNova', name: 'Payout Nova', desc: 'Permanent +10% payouts per level.', costVip: 30, max: 3 },
        { key: 'lockMastery', name: 'Lucky Lock Mastery', desc: '+2 locked spins per level.', costVip: 24, max: 3 },
        { key: 'surgeCore', name: 'Surge Core', desc: '+20% Jackpot Surge power per level.', costVip: 26, max: 3 },
        { key: 'bonusCatalyst', name: 'Bonus Catalyst', desc: '+1 Bonus Storm tier per level.', costVip: 20, max: 3 },
        { key: 'dropAlchemy', name: 'Drop Alchemy', desc: '+10% drop rate multiplier per level.', costVip: 22, max: 3 },
        { key: 'wildForge', name: 'Wild Forge', desc: '+25% wild weight per level.', costVip: 18, max: 3 },
        { key: 'hasteCore', name: 'Haste Core', desc: 'Spins resolve 5% faster per level.', costVip: 16, max: 3 },
        { key: 'betOverclock', name: 'Bet Overclock', desc: '+50% max bet cap per level.', costVip: 28, max: 2 }
      ];

      const formatUpgradeLevel = (def, level) => {
        if (!def || level <= 0) return level <= 0 ? 'Base' : `Level ${level}`;
        const levels = Array.isArray(def.levels) ? def.levels : [];
        if (levels.length) {
          const idx = Math.min(level - 1, levels.length - 1);
          const label = levels[idx];
          const overflow = level - 1 > idx;
          return overflow ? `${label} (cap+)` : label;
        }
        return `Level ${level}`;
      };

      const getUpgradeMaxLevel = (key) => {
        const def = getUpgradeDef(key);
        if (!def) return 0;
        if (def.dynamicMax === 'premiumSymbols') {
          const base = state.machine.baseSymbolCount || 5;
          const available = (state.machine.symbols || []).filter(entry => entry.key !== 'wild').length;
          return Math.max(0, available - base);
        }
        if (def.dynamicMax === 'cullSymbols') {
          const base = state.machine.baseSymbolCount || 5;
          return Math.max(0, base - 1);
        }
        let max = Number.isFinite(def.max) ? def.max : 0;
        if (LEVEL_CAP_BOOST_TARGETS.has(key)) {
          max += getLevelCapBoost();
        }
        return Math.max(0, max);
      };

      const computeActiveSymbols = (upgrades = state.upgrades) => {
        const list = (state.machine.symbols || []).filter(entry => entry.key !== 'wild');
        const disable = Math.max(0, Math.floor(upgrades.disable || 0));
        const premium = Math.max(0, Math.floor(upgrades.premium || 0));
        const baseCount = state.machine.baseSymbolCount || 5;
        const start = Math.min(disable, list.length - 1);
        const count = Math.min(list.length - start, baseCount + premium);
        const pool = list.slice(start, start + count).map(entry => entry.key);
        if (upgrades.wildUnlock) pool.push('wild');
        return pool;
      };
      const machineBalance = (id = state.machine.id) => {
        const prog = ensureMachineProgress(id);
        return Number.isFinite(prog.balance) ? prog.balance : 0;
      };
      const setMachineBalance = (amount = 0, id = state.machine.id) => {
        const prog = ensureMachineProgress(id);
        prog.balance = Math.max(0, Math.trunc(amount));
        if (id === state.machine.id) {
          state.balance = prog.balance;
          if (els.hudBalance) els.hudBalance.textContent = formatCompactMoney(state.balance);
          if (els.balance) els.balance.textContent = formatMoney(state.balance, { compact: false });
          if (els.spinBtn) els.spinBtn.textContent = `Spin: ${formatMoney(state.bet || 0)}`;
        }
      };
      const addMachineBalance = (amount = 0, id = state.machine.id) => {
        if (!Number.isFinite(amount) || amount === 0) return;
        setMachineBalance(machineBalance(id) + amount, id);
      };
      const spendMachineBalance = (amount = 0, id = state.machine.id) => {
        if (!Number.isFinite(amount) || amount <= 0) return false;
        const current = machineBalance(id);
        if (current < amount) return false;
        setMachineBalance(current - amount, id);
        return true;
      };
      const syncCurrentBalanceToMachine = () => {
        setMachineBalance(state.balance || 0, state.machine.id);
      };
      const loadMachineBalance = (id = state.machine.id) => {
        const bal = machineBalance(id);
        state.balance = bal;
        if (els.hudBalance) els.hudBalance.textContent = formatCompactMoney(bal);
        if (els.balance) els.balance.textContent = formatMoney(bal, { compact: false });
        if (els.spinBtn) els.spinBtn.textContent = `Spin: ${formatMoney(state.bet || 0)}`;
      };
      const applyPremiumMods = () => {
        const purchases = state.premium?.purchases || {};
        const mods = {
          lockSpinsBonus: 0,
          surgeMult: 1,
          bonusTier: 0,
          payoutMult: 1,
          dropMult: 1,
          wildWeight: 1,
          speedFactor: 1,
          betCapMult: 1
        };
        const lockLvl = purchases.lockMastery || 0;
        mods.lockSpinsBonus = lockLvl * 2;
        const surgeLvl = purchases.surgeCore || 0;
        mods.surgeMult = 1 + surgeLvl * 0.2;
        const bonusLvl = purchases.bonusCatalyst || 0;
        mods.bonusTier = bonusLvl;
        const payoutLvl = purchases.payoutNova || 0;
        mods.payoutMult = 1 + payoutLvl * 0.1;
        const dropLvl = purchases.dropAlchemy || 0;
        mods.dropMult = 1 + dropLvl * 0.1;
        const wildLvl = purchases.wildForge || 0;
        mods.wildWeight = 1 + wildLvl * 0.25;
        const hasteLvl = purchases.hasteCore || 0;
        mods.speedFactor = Math.max(0.6, 1 - hasteLvl * 0.05);
        const betLvl = purchases.betOverclock || 0;
        mods.betCapMult = 1 + betLvl * 0.5;
        state.premium.mods = mods;
      };
      const premiumItemByKey = new Map(PREMIUM_ITEMS.map(item => [item.key, item]));
      const getVipBalance = () => Math.max(0, Number(state.drop?.inventory?.vipMarks || 0));
      const spendVip = (amount = 0) => {
        const inventory = state.drop.inventory || (state.drop.inventory = {});
        inventory.vipMarks = Math.max(0, getVipBalance() - amount);
      };
      const getEffectiveUpgrades = () => {
        const out = {};
        if (state.upgradeCatalog?.length) {
          state.upgradeCatalog.forEach(def => {
            out[def.key] = getEffectiveUpgradeLevel(def.key);
          });
        } else {
          Object.assign(out, state.upgrades);
        }
        return out;
      };

      const currency = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      });
      const NUMBER_ABBREVIATIONS = [
        { value: 1e33, suffix: 'Dc' },
        { value: 1e30, suffix: 'No' },
        { value: 1e27, suffix: 'Oc' },
        { value: 1e24, suffix: 'Sp' },
        { value: 1e21, suffix: 'Sx' },
        { value: 1e18, suffix: 'Qi' },
        { value: 1e15, suffix: 'Qa' },
        { value: 1e12, suffix: 'T' },
        { value: 1e9, suffix: 'B' },
        { value: 1e6, suffix: 'M' },
        { value: 1e3, suffix: 'K' }
      ];
      const abbreviateNumber = (value = 0, { decimals = 1, prefix = '' } = {}) => {
        const num = Number(value);
        if (!Number.isFinite(num)) return `${prefix}0`;
        const abs = Math.abs(num);
        const entry = NUMBER_ABBREVIATIONS.find(item => abs >= item.value);
        if (!entry) {
          return `${prefix}${num.toLocaleString('en-US', { maximumFractionDigits: 0 })}`;
        }
        const scaled = num / entry.value;
        const places = scaled >= 100 ? 0 : scaled >= 10 ? 1 : decimals;
        const rounded = scaled.toFixed(places).replace(/\.0+$/, '');
        return `${prefix}${rounded}${entry.suffix}`;
      };
      const formatMoney = (value = 0, { compact = true } = {}) => {
        const num = Number(value);
        if (!Number.isFinite(num)) return '$0';
        const abs = Math.abs(num);
        if (!compact && abs < 1e6) return currency.format(num);
        return abbreviateNumber(num, { prefix: '$' });
      };
      const formatCompactMoney = (value = 0) => abbreviateNumber(value, { prefix: '$', decimals: 1 });
      const formatCompactNumber = (value = 0) => abbreviateNumber(Math.max(0, Number.isFinite(value) ? value : 0), { decimals: 1 });
      const formatTime = (ms = 0) => {
        const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
        const m = Math.floor(totalSeconds / 60);
        const s = totalSeconds % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      };
      const textEncoder = new TextEncoder();
      const textDecoder = new TextDecoder();
      const base64UrlEncode = (bytes) => {
        const bin = Array.from(bytes || []).map(b => String.fromCharCode(b)).join('');
        return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      };
      const base64UrlDecode = (str = '') => {
        const padded = str.replace(/-/g, '+').replace(/_/g, '/').padEnd(Math.ceil(str.length / 4) * 4, '=');
        const bin = atob(padded);
        const out = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i += 1) out[i] = bin.charCodeAt(i);
        return out;
      };
      const deriveKey = async (token = '', salt = new Uint8Array(0), usage = 'encrypt', context = API_BASE || '') => {
        const seed = textEncoder.encode(context ? `${token}::${context}` : token);
        const data = new Uint8Array(seed.length + salt.length);
        data.set(seed, 0);
        data.set(salt, seed.length);
        const hash = await crypto.subtle.digest('SHA-256', data);
        if (usage === 'hmac') {
          return crypto.subtle.importKey('raw', hash, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign', 'verify']);
        }
        return crypto.subtle.importKey('raw', hash, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
      };
      const encryptBlob = async (token, payload) => {
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const key = await deriveKey(token, salt, 'encrypt');
        const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, payload);
        return { salt, iv, cipher: new Uint8Array(cipher) };
      };
      const decryptBlob = async (token, blob) => {
        const key = await deriveKey(token, blob.salt, 'encrypt');
        const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: blob.iv }, key, blob.cipher);
        return new Uint8Array(plain);
      };
      const hmacSign = async (token, payload, context = '') => {
        const salt = crypto.getRandomValues(new Uint8Array(8));
        const key = await deriveKey(token, salt, 'hmac', context);
        const sig = await crypto.subtle.sign('HMAC', key, payload);
        return { salt, sig: new Uint8Array(sig) };
      };
      const hmacVerify = async (token, payload, signature = {}, context = '') => {
        if (!signature) return false;
        try {
          const salt = signature.salt ? base64UrlDecode(signature.salt) : (signature.s ? base64UrlDecode(signature.s) : null);
          const sig = signature.value ? base64UrlDecode(signature.value) : (signature.sig ? base64UrlDecode(signature.sig) : null);
          if (!salt || !sig) return false;
          const key = await deriveKey(token, salt, 'hmac', context);
          return crypto.subtle.verify('HMAC', key, sig, payload);
        } catch {
          return false;
        }
      };
      const safeJsonParse = (raw, fallback = null) => {
        try {
          return JSON.parse(raw);
        } catch {
          return fallback;
        }
      };
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const randomGaussian = (mean = 0.5, std = 0.15) => {
        let u = 0; let v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const norm = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        const value = mean + std * norm;
        return Math.min(1, Math.max(0, value));
      };
      const resolveMaxBet = (incoming) => {
        const numeric = Number(incoming);
        if (Number.isFinite(numeric) && numeric > 0) return numeric;
        if (typeof state !== 'undefined' && Number.isFinite(state.maxBet) && state.maxBet > 0) return state.maxBet;
        return DEFAULT_MAX_BET;
      };
      const xpNeeded = (lvl = 0) => Math.max(50, Math.round(80 * Math.pow(lvl + 1, 2)));
      const MACHINE_UNLOCK_LEVEL = 50;
      const UPGRADE_COST_GROWTH = 2.05;
      const computeUpgradeCost = (def, level = 0) => {
        if (!def) return 0;
        const base = def.cost || 0;
        const growth = Number.isFinite(def.costGrowth) ? def.costGrowth : UPGRADE_COST_GROWTH;
        const step = Math.max(0, Math.floor(level));
        return Math.round(base * Math.pow(Math.max(1, growth), step));
      };
      const buildBetSteps = (maxBet = DEFAULT_MAX_BET) => {
        const max = Math.max(1, Math.round(Number(maxBet) || DEFAULT_MAX_BET));
        const stepCount = Math.max(8, Math.min(18, Math.ceil(Math.log10(max) * 4)));
        const ratio = Math.pow(max, 1 / Math.max(1, stepCount - 1));
        const steps = new Set([1, max]);
        for (let i = 1; i < stepCount - 1; i += 1) {
          const value = Math.max(1, Math.round(Math.pow(ratio, i)));
          steps.add(value);
        }
        return Array.from(steps).sort((a, b) => a - b);
      };
      let betSteps = buildBetSteps(DEFAULT_MAX_BET);
      const getNearestBetIndex = (value) => {
        const steps = betSteps.length ? betSteps : buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        let bestIndex = 0;
        let bestDelta = Infinity;
        steps.forEach((step, idx) => {
          const delta = Math.abs(step - value);
          if (delta < bestDelta) {
            bestDelta = delta;
            bestIndex = idx;
          }
        });
        return bestIndex;
      };
      const betFromIndex = (index) => {
        const steps = betSteps.length ? betSteps : buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        const clamped = clamp(Math.round(index), 0, Math.max(0, steps.length - 1));
        return steps[clamped] || 1;
      };
      const syncBetSteps = () => {
        betSteps = buildBetSteps(state.maxBet || DEFAULT_MAX_BET);
        if (els.betSlider) {
          els.betSlider.min = 0;
          els.betSlider.max = Math.max(0, betSteps.length - 1);
          els.betSlider.step = 1;
          els.betSlider.value = getNearestBetIndex(state.bet);
        }
      };
      const isAutoSpinUnlocked = () => (state.upgrades.autoSpinUnlock || 0) > 0;
      const getAutoSpinCount = () => {
        const level = Math.max(0, state.upgrades.autoSpinCount || 0);
        return 5 + level * 5;
      };
      const CLIENT_ONLY_UPGRADES = new Set(['autoSpinUnlock', 'autoSpinCount']);
      const loadLocalUpgrades = () => {
        try {
          const raw = localStorage.getItem(LOCAL_UPGRADES_KEY);
          const parsed = raw ? JSON.parse(raw) : {};
          return parsed && typeof parsed === 'object' ? parsed : {};
        } catch {
          return {};
        }
      };
      const saveLocalUpgrades = (data) => {
        try {
          localStorage.setItem(LOCAL_UPGRADES_KEY, JSON.stringify(data));
        } catch {
          // ignore
        }
      };
      const localUpgrades = loadLocalUpgrades(); // shape: { [machineId]: { upgradeKey: level } }
      const localUpgradeBucket = (machineId = state.machine.id) => {
        if (!localUpgrades[machineId]) localUpgrades[machineId] = {};
        return localUpgrades[machineId];
      };
      const clearLocalUpgradeState = () => {
        Object.keys(localUpgrades || {}).forEach(key => { delete localUpgrades[key]; });
        try {
          localStorage.removeItem(LOCAL_UPGRADES_KEY);
        } catch {
          // ignore
        }
      };
      const resetAutoState = () => {
        state.autoSpin = { active: false, remaining: 0 };
      };
      const getEffectiveUpgradeLevel = (key) => {
        const currentLocal = localUpgradeBucket();
        const base = Number(getMachineUpgrades(state.machine.id)?.[key] || state.serverUpgrades?.[key] || 0);
        const pending = Number(state.pendingUpgrades?.[key] || 0);
        const local = Number(currentLocal?.[key] || 0);
        return Math.max(0, base + pending + local);
      };

      const machineIndex = (id = state.machine.id) => Math.max(0, (machineList || []).indexOf(id));
      const previousMachineId = (id = state.machine.id) => {
        const idx = machineIndex(id);
        return idx > 0 ? machineList?.[idx - 1] : null;
      };
      const ensureMachineProgress = (id = state.machine.id) => {
        if (!state.machines[id]) {
          const isFirst = machineIndex(id) === 0;
          const startBalance = (state.offlineMode || window.location.protocol === 'file:') && isFirst ? 50000 : 0;
          state.machines[id] = { xp: 0, lvl: 0, balance: startBalance, unlocked: isFirst, upgrades: {} };
        }
        if (typeof state.machines[id].balance !== 'number') {
          const isFirst = machineIndex(id) === 0;
          const startBalance = (state.offlineMode || window.location.protocol === 'file:') && isFirst ? 50000 : 0;
          state.machines[id].balance = startBalance;
        }
        return state.machines[id];
      };
      const meetsMachineLevelRequirement = (id = state.machine.id) => {
        const prevId = previousMachineId(id);
        if (!prevId) return true;
        const prev = ensureMachineProgress(prevId);
        return (prev.lvl || 0) >= MACHINE_UNLOCK_LEVEL;
      };
      const getMachineUpgrades = (id = state.machine.id) => {
        const prog = ensureMachineProgress(id);
        prog.upgrades = prog.upgrades || {};
        return prog.upgrades;
      };
      const addMachineXp = (id, xp) => {
        const prog = ensureMachineProgress(id);
        prog.xp = Math.max(0, (prog.xp || 0) + xp);
        let leveled = false;
        while (prog.xp >= xpNeeded(prog.lvl)) {
          prog.xp -= xpNeeded(prog.lvl);
          prog.lvl += 1;
          leveled = true;
          if ((prog.lvl || 0) >= 100 && !state.globalPerks[id]) {
            state.globalPerks[id] = true;
            log('Legacy perk unlocked', `${id} grants +5% payout/+3% drops forever`);
          }
        }
        return leveled;
      };

      const buildLinePatterns = (rows, reels) => {
        const patterns = [];
        // Tier 0: straight lines
        for (let r = 0; r < rows; r += 1) {
          patterns.push({ pattern: Array(reels).fill(r), tier: 0 });
        }
        if (rows >= 2) {
          // Tier 1: simple diagonals
          const down = Array.from({ length: reels }, (_, i) => Math.min(rows - 1, i));
          const up = Array.from({ length: reels }, (_, i) => Math.max(0, rows - 1 - i));
          patterns.push({ pattern: down, tier: 1 });
          patterns.push({ pattern: up, tier: 1 });
          // Tier 2: zigzag bounce
          const zig = [];
          const zag = [];
          let r1 = 0; let d1 = 1;
          let r2 = rows - 1; let d2 = -1;
          for (let i = 0; i < reels; i += 1) {
            zig.push(r1);
            zag.push(r2);
            r1 += d1;
            r2 += d2;
            if (r1 === rows - 1 || r1 === 0) d1 *= -1;
            if (r2 === rows - 1 || r2 === 0) d2 *= -1;
          }
          patterns.push({ pattern: zig, tier: 2 });
          patterns.push({ pattern: zag, tier: 2 });
        }
        // Tier 3: all-touching paths (-1/0/+1 steps)
        if (rows > 0 && reels > 0) {
          const path = Array(reels).fill(0);
          const enumerate = (col, row) => {
            path[col] = row;
            if (col === reels - 1) {
              patterns.push({ pattern: [...path], tier: 3 });
              return;
            }
            for (const delta of [-1, 0, 1]) {
              const nr = row + delta;
              if (nr >= 0 && nr < rows) enumerate(col + 1, nr);
            }
          };
          for (let r = 0; r < rows; r += 1) enumerate(0, r);
        }
        return patterns;
      };

      const els = {
        connectionPill: document.getElementById('connection-pill'),
        connectionText: document.getElementById('connection-text'),
        slotGrid: document.getElementById('slot-grid'),
        lineOverlay: document.getElementById('line-overlay'),
        lineFlashBtn: document.getElementById('line-flash-btn'),
        spinBtn: document.getElementById('spin-btn'),
        autoSpinBtn: document.getElementById('auto-spin-btn'),
        premiumBtn: document.getElementById('premium-shop-btn'),
        resetBtn: document.getElementById('reset-btn'),
        syncBtn: document.getElementById('sync-btn'),
        alert: document.getElementById('alert'),
        error: document.getElementById('error'),
        machineOutcome: document.getElementById('machine-outcome'),
        machineLines: document.getElementById('machine-lines'),
        reelStage: document.getElementById('reel-stage'),
        machineStage: document.querySelector('.machine-stage'),
        betSlider: document.getElementById('bet-range'),
        chipButtons: Array.from(document.querySelectorAll('[data-chip]')),
        hudBalance: document.getElementById('hud-balance'),
        hudBet: document.getElementById('hud-bet'),
        hudWin: document.getElementById('hud-last-win'),
        hudVip: document.getElementById('hud-vip'),
        hudLevel: document.getElementById('hud-level'),
        balance: document.getElementById('balance'),
        playerId: document.getElementById('player-id'),
        maxBet: document.getElementById('max-bet'),
        spinCount: document.getElementById('spin-count'),
        lastOutcome: document.getElementById('last-outcome'),
        lastWin: document.getElementById('last-win'),
        lastMult: document.getElementById('last-multiplier'),
        lastTime: document.getElementById('last-time'),
        log: document.getElementById('log'),
        paytable: document.getElementById('paytable'),
        dropLog: document.getElementById('drop-log'),
        dropPanel: document.getElementById('drop-panel'),
        dropPanelOverlay: document.getElementById('drop-panel-overlay'),
        dropOverlay: document.getElementById('drop-overlay'),
        dropOverlayClose: document.getElementById('drop-overlay-close'),
        dropRatesBtn: document.getElementById('drop-rates-btn'),
        dropRatesPlayBtn: document.getElementById('drop-rates-play-btn'),
        dropSkillBtn: document.getElementById('drop-skill-btn'),
        dropCloseBtn: document.getElementById('drop-close-btn'),
        inventoryGrid: document.getElementById('inventory-grid'),
        machineFlyout: document.getElementById('machine-flyout'),
        machineList: document.getElementById('machine-list'),
        machinePicker: document.getElementById('machine-picker'),
        machinePickerLabel: document.getElementById('machine-picker-label'),
        machinePickerLevel: document.getElementById('machine-picker-level'),
        machineName: document.getElementById('machine-name'),
        machineTier: document.getElementById('machine-tier'),
        machineXpFill: document.getElementById('machine-xp-fill'),
        hudRows: document.getElementById('hud-rows'),
        hudReels: document.getElementById('hud-reels'),
        hudLines: document.getElementById('hud-lines'),
        creditsChip: document.getElementById('credits-chip'),
        vipChip: document.getElementById('vip-chip'),
        flyover: null,
        flyoverLevel: document.getElementById('flyover-level'),
        flyoverXp: document.getElementById('flyover-xp'),
        flyoverLoot: document.getElementById('flyover-loot'),
        flyoverTop: document.getElementById('flyover-top'),
        perksBtn: document.getElementById('perks-btn'),
        perksPopover: document.getElementById('perks-popover'),
        dailyStatus: document.getElementById('daily-status'),
        dailyRewardMain: document.getElementById('daily-reward-main'),
        dailyItems: document.getElementById('daily-items'),
        dailyClaimBtn: document.getElementById('daily-claim-btn'),
        dailyNextReset: document.getElementById('daily-next-reset'),
        dailyStreak: document.getElementById('daily-streak'),
        bonusList: document.getElementById('bonus-list'),
        gearSlots: document.getElementById('gear-slots'),
        gearInventory: document.getElementById('gear-inventory'),
        gearSummary: document.getElementById('gear-summary'),
        gearCap: document.getElementById('gear-cap'),
        gearPanel: document.getElementById('gear-panel'),
        cardSlots: document.getElementById('card-slots'),
        cardCollection: document.getElementById('card-collection'),
        cardSummary: document.getElementById('card-summary'),
        cardCap: document.getElementById('card-cap'),
        cardPanel: document.getElementById('card-panel'),
        accountLog: document.getElementById('account-log'),
        premiumPanel: document.getElementById('premium-panel'),
        premiumClose: document.getElementById('premium-close'),
        premiumGrid: document.getElementById('premium-grid'),
        premiumVipBalance: document.getElementById('premium-vip-balance'),
        authOverlay: document.getElementById('auth-overlay'),
        authBody: document.getElementById('auth-body'),
        authAlert: document.getElementById('auth-alert'),
        authEmail: document.getElementById('auth-email'),
        authPassword: document.getElementById('auth-password'),
        authConfirmGroup: document.getElementById('auth-confirm-group'),
        authConfirm: document.getElementById('auth-confirm'),
        authSubmit: document.getElementById('auth-submit'),
        authInfo: document.getElementById('auth-info'),
        authTabs: Array.from(document.querySelectorAll('.auth-tab')),
        authOverlayNote: document.getElementById('auth-note'),
        accountPanel: document.getElementById('account-panel'),
        accountToggle: document.getElementById('account-toggle'),
        accountClose: document.getElementById('account-close'),
        accountUser: document.getElementById('account-user'),
        logoutBtn: document.getElementById('logout-btn'),
        deleteBtn: document.getElementById('delete-account-btn'),
        debugCoinBtn: document.getElementById('debug-add-coins'),
        upgradeGrid: document.getElementById('upgrade-grid'),
        upgradePanel: document.getElementById('upgrade-panel'),
        mobileNav: document.getElementById('mobile-nav'),
        exportStateBtn: document.getElementById('export-state-btn'),
        importStateBtn: document.getElementById('import-state-btn'),
        importStateInput: document.getElementById('import-state-input'),
        transferStatus: document.getElementById('transfer-status'),
        payoutSkillBtn: document.getElementById('payout-skill-btn'),
        workerBtn: document.getElementById('worker-btn'),
        skillStrip: document.getElementById('skill-strip')
      };
      const positionMachineFlyout = () => {
        const panel = els.machineFlyout?.querySelector('.machine-flyout__panel');
        if (!panel) return;
        const rect = els.machinePicker?.getBoundingClientRect();
        const top = Math.max(12, (rect?.bottom || 80) + 10);
        panel.style.setProperty('--machine-flyout-top', `${top}px`);
      };
      const setMachineFlyout = (open = false) => {
        if (!els.machineFlyout) return;
        if (open) positionMachineFlyout();
        els.machineFlyout.dataset.open = open ? 'true' : 'false';
        if (els.machinePicker) {
          els.machinePicker.setAttribute('aria-expanded', open ? 'true' : 'false');
        }
      };
      const toggleMachineFlyout = () => {
        if (!els.machineFlyout) return;
        const next = els.machineFlyout.dataset.open !== 'true';
        setMachineFlyout(next);
      };
      const paneState = {
        mq: window.matchMedia('(max-width: 768px)'),
        active: 'play'
      };
      const mobileButtons = Array.from(els.mobileNav?.querySelectorAll('[data-mobile-target]') || []);
      const desktopButtons = Array.from(document.querySelectorAll('[data-pane-target]'));
      const mobilePanes = Array.from(document.querySelectorAll('[data-mobile-pane]'));
      const setPaneVisibility = () => {
        const active = paneState.active || 'play';
        mobilePanes.forEach(pane => {
          const paneId = pane.dataset.mobilePane || 'play';
          const isActive = paneId === active;
          pane.dataset.mobileActive = isActive ? 'true' : 'false';
          pane.hidden = !isActive;
        });
      };
      const applyPaneMode = () => {
        const isMobile = paneState.mq.matches;
        document.body.dataset.mobile = isMobile ? 'true' : 'false';
        if (root) {
          root.dataset.tabs = 'true';
          root.dataset.paneMode = 'tabbed';
          root.dataset.activePane = paneState.active;
        }
        const allButtons = [...mobileButtons, ...desktopButtons];
        allButtons.forEach(btn => {
          const target = btn.dataset.mobileTarget || btn.dataset.paneTarget;
          btn.classList.toggle('active', target === paneState.active);
        });
        setPaneVisibility();
      };
      const setPaneActive = (target) => {
        document.querySelectorAll('[data-upgrade-key][data-highlight]').forEach(card => {
          card.dataset.highlight = 'false';
        });
        if (target) {
          paneState.active = target;
        }
        if (root) {
          root.dataset.activePane = paneState.active;
        }
        applyPaneMode();
      };
      mobileButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          setPaneActive(btn.dataset.mobileTarget);
        });
      });
      desktopButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          setPaneActive(btn.dataset.paneTarget);
        });
      });
      if (paneState.mq.addEventListener) {
        paneState.mq.addEventListener('change', applyPaneMode);
      } else if (paneState.mq.addListener) {
        paneState.mq.addListener(applyPaneMode);
      }
      applyPaneMode();
      els.accountToggle?.addEventListener('click', () => toggleAccountSheet(true));
      els.accountClose?.addEventListener('click', () => toggleAccountSheet(false));
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (!els.accountPanel?.hidden) {
            toggleAccountSheet(false);
          }
          if (!els.dropPanel?.hidden) {
            toggleDropPanel(false);
          }
          if (!els.dropOverlay?.hidden) {
            toggleDropPanel(false, 'overlay');
          }
          if (els.perksPopover?.dataset.visible === 'true') {
            togglePerks(false);
          }
        }
      });
      const probedSymbols = new Set();
      let pendingWinGroups = [];
      let pendingSpinResult = null;
      let activeReelLocks = 0;
      const settleWaiters = [];
      const notifyReelsSettled = () => {
        if (activeReelLocks === 0 && !anyReelSpinning()) {
          const waiters = settleWaiters.splice(0, settleWaiters.length);
          waiters.forEach(fn => fn());
        }
      };
      const waitForReelsToSettle = () => new Promise(resolve => {
        settleWaiters.push(resolve);
        notifyReelsSettled();
      });
      const getPlaceholderAsset = () => state?.machine?.assets?.placeholder || state?.machine?.placeholder || PLACEHOLDER_ASSET;
      const auditSymbolAssets = () => {
        state.symbolMap.forEach(entry => {
          if (!entry || !entry.key || !entry.asset || probedSymbols.has(entry.key)) return;
          probedSymbols.add(entry.key);
          const img = new Image();
          img.addEventListener('load', () => {
            debug('asset:load-ok', { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.addEventListener('error', () => {
            debugError('asset:load-failed', new Error('Failed to load symbol asset'), { symbol: entry.key, src: entry.asset });
          }, { once: true });
          img.src = entry.asset;
        });
      };
      const attachImageDebugging = (img, symbolKey) => {
        if (!img || img.dataset.debugAttached) return;
        img.dataset.debugAttached = 'true';
        img.addEventListener('error', () => {
          debugError('image', new Error('Image failed to load'), { symbol: symbolKey || img.dataset.symbolKey || img.alt, src: img.currentSrc || img.src });
          img.src = getPlaceholderAsset();
        });
      };
      function getSymbolEntry(symbolKey) {
        if (!symbolKey) {
          return { key: 'placeholder', label: 'Symbol', asset: getPlaceholderAsset() };
        }
        const entry = state.symbolMap.get(symbolKey) || DEFAULT_SYMBOL_MAP.get(symbolKey);
        if (entry) {
          return { ...entry, asset: entry.asset || getPlaceholderAsset() };
        }
        return { key: symbolKey, label: symbolKey, asset: getPlaceholderAsset() };
      }
      const applySymbolToImage = (img, symbolKey) => {
        const info = getSymbolEntry(symbolKey);
        if (!img) return info;
        const needsUpdate = img.dataset.symbolKey !== info.key || img.dataset.symbolAsset !== info.asset;
        if (needsUpdate) {
          img.dataset.symbolKey = info.key;
          img.dataset.symbolAsset = info.asset;
          img.alt = info.label || info.key;
          img.src = info.asset || getPlaceholderAsset();
          if (!info.asset || info.asset === getPlaceholderAsset()) {
            debug('symbol:placeholder-used', { symbol: info.key, reason: 'missing asset' });
          }
        }
        attachImageDebugging(img, info.key);
        return info;
      };
      const upgradeDefinitions = {
        rows: {
          label: 'Extra Rows',
          description: 'Adds another horizontal row so more lines can form.',
          format: (current, max) => `${current}/${max} rows`
        },
        reels: {
          label: 'Extra Reels',
          description: 'Extends the machine vertically for longer combos.',
          format: (current, max) => `${current}/${max} reels`
        },
        lines: {
          label: 'Line Patterns',
          description: 'Unlocks diagonal and zig-zag paylines.',
          format: (current, max) => `${current}/${max} tiers`
        }
      };
      function getUpgradeSettings() {
        const defaults = {
          baseRows: 3,
          maxRows: 5,
          baseReels: 3,
          maxReels: 5,
          costs: { rows: [], reels: [], lines: [] }
        };
      const settings = state.machine.upgradeSettings || state.machine.upgrades || {};
      return {
        baseRows: settings.baseRows ?? defaults.baseRows,
        maxRows: settings.maxRows ?? defaults.maxRows,
        baseReels: settings.baseReels ?? defaults.baseReels,
        maxReels: settings.maxReels ?? defaults.maxReels,
        costs: settings.costs || defaults.costs
      };
    }
    state.playerId = state.auth.token ? null : getStored(storageKeys.player);

      const updateAccountLog = () => {
        if (!els.accountLog || !els.log) return;
        const entries = Array.from(els.log.querySelectorAll('.log-entry')).slice(0, 6);
        if (!entries.length) {
          els.accountLog.innerHTML = '<p class="muted-text small">No recent events yet.</p>';
          return;
        }
        els.accountLog.innerHTML = entries.map(entry => `<div class="account-log__item">${entry.innerHTML}</div>`).join('');
      };

      const log = (message, data) => {
        debug('ui-log', { message, data, stateSnapshot: { busy: state.busy, auth: !!state.auth.token, balance: state.balance, bet: state.bet } });
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<strong>${time}</strong> - ${message}${data ? `<br><span>${data}</span>` : ''}`;
        els.log.prepend(entry);
        const entries = els.log.querySelectorAll('.log-entry');
        if (entries.length > 40) {
          entries[entries.length - 1].remove();
        }
        updateAccountLog();
      };

      const setStatus = (text, stateAttr = 'ok') => {
        debug('ui:setStatus', { text, stateAttr });
        log('Status', text);
        if (els.connectionPill && els.connectionText) {
          els.connectionText.textContent = text;
          els.connectionPill.dataset.state = stateAttr;
          els.connectionPill.setAttribute('data-state', stateAttr === 'ok' ? 'ok' : stateAttr);
        }
      };

      const showAlert = (text = '') => {
        els.alert.hidden = !text;
        els.alert.textContent = text;
        if (text) debug('ui:alert', text);
      };

      const showPopup = (text = '') => {
        if (!text) return;
        try {
          window.alert(text);
        } catch {
          // ignore
        }
      };

      const showAuthAlert = (text = '') => {
        if (text) debug('auth:alert', text);
        if (!els.authAlert) return;
        els.authAlert.hidden = !text;
        els.authAlert.textContent = text;
        if (text) {
          requestFrame(() => {
            els.authAlert?.scrollIntoView?.({ block: 'nearest', behavior: 'smooth' });
            els.authAlert?.focus?.({ preventScroll: false });
          });
        }
      };

      const gamePanels = Array.from(document.querySelectorAll('[data-requires-auth]'));

      const setGameVisibility = (visible) => {
        debug('ui:setGameVisibility', { visible });
        state.gameReady = visible;
        gamePanels.forEach(panel => {
          panel.hidden = !visible;
        });
        if (!visible) {
          toggleAccountSheet(false);
          toggleDropPanel(false);
          toggleDropPanel(false, 'overlay');
        }
        const disableInputs = !visible || state.busy || state.autoSpin?.active;
        els.spinBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.resetBtn) els.resetBtn.disabled = disableInputs;
        if (els.dropRatesBtn) els.dropRatesBtn.disabled = disableInputs;
        if (els.dropRatesPlayBtn) els.dropRatesPlayBtn.disabled = disableInputs;
        renderUpgrades();
        renderSkillButton();
        renderPayoutSkill();
        renderDaily();
        renderBonusSummary();
        renderAutoSpinButton();
        renderWorkerButton();
        applyPaneMode();
        if (visible) startIdleTicker();
        else stopIdleTicker();
        if (visible) startSkillTicker();
        else stopSkillTicker();
      };

      const setBusy = (flag) => {
        debug('ui:setBusy', { flag, prev: state.busy });
        state.busy = flag;
        const disableInputs = flag || !state.gameReady || state.autoSpin?.active;
        els.spinBtn.disabled = disableInputs;
        if (els.syncBtn) els.syncBtn.disabled = disableInputs;
        if (els.betSlider) els.betSlider.disabled = disableInputs;
        els.chipButtons.forEach(btn => { btn.disabled = disableInputs; });
        if (els.dropRatesBtn) els.dropRatesBtn.disabled = disableInputs;
        if (els.dropRatesPlayBtn) els.dropRatesPlayBtn.disabled = disableInputs;
        if (els.payoutSkillBtn) els.payoutSkillBtn.disabled = disableInputs;
        if (els.workerBtn) els.workerBtn.disabled = disableInputs;
        if (disableInputs) {
          toggleDropPanel(false);
          toggleDropPanel(false, 'overlay');
        }
        renderUpgrades();
        renderSkillButton();
        renderPayoutSkill();
        renderDaily();
        renderBonusSummary();
        renderAutoSpinButton();
        renderWorkerButton();
      };

      const refreshControls = () => {
        setGameVisibility(state.gameReady);
        renderAutoSpinButton();
        renderSkillStrip();
      };

      const toggleAuthInputs = (disabled) => {
        [els.authEmail, els.authPassword, els.authConfirm, els.authSubmit, els.authInfo].forEach(node => {
          if (node) node.disabled = disabled;
        });
        (els.authTabs || []).forEach(btn => {
          btn.disabled = disabled;
        });
      };

      const toggleAccountSheet = (force) => {
        if (!els.accountPanel) return;
        const shouldShow = typeof force === 'boolean' ? force : els.accountPanel.hidden;
        els.accountPanel.hidden = !shouldShow;
        els.accountPanel.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
        if (shouldShow) {
          els.accountPanel.focus({ preventScroll: false });
          updateAccountLog();
        }
      };

      function randomSymbolInfo() {
        const weights = state.symbolWeights?.entries || [];
        const total = state.symbolWeights?.total || 0;
        if (total > 0 && weights.length) {
          const target = Math.floor(Math.random() * total);
          const hit = weights.find(entry => entry.total > target);
          if (hit) return getSymbolEntry(hit.key);
        }
        const pool = Array.from(state.symbolMap.values());
        if (!pool.length) return getSymbolEntry('placeholder');
        return pool[Math.floor(Math.random() * pool.length)];
      }

      const describeUpgradeExtra = (key) => {
        const settings = getUpgradeSettings();
        switch (key) {
          case 'rows':
            return `${state.currentRows || settings.baseRows}/${settings.maxRows} rows`;
          case 'reels':
            return `${state.currentReels || settings.baseReels}/${settings.maxReels} reels`;
          case 'lines': {
            const tier = state.currentLineTier ?? 0;
            return `Tier ${tier}`;
          }
          case 'idle':
            return `Idle +${state.upgrades.idle || 0}/sec`;
          case 'speed':
            return `${(state.upgrades.speed || 0) * 10}% faster`;
          case 'retrigger':
            return `${(state.upgrades.retrigger || 0) * 5}% chance`;
          case 'dropBoost':
            return `${(state.upgrades.dropBoost || 0) * 5}% drops`;
          case 'premium': {
            const active = state.machine.activeSymbols?.length || 0;
            return `${active} symbols active`;
          }
          case 'betMultiplier':
            return `Max bet ${formatMoney(state.maxBet || DEFAULT_MAX_BET)}`;
          default:
            return '';
        }
      };

      const buildLevelPerks = (lvl = 0) => {
        const perks = [];
        const tierCount = (threshold, step = 5) => (lvl >= threshold ? (Math.floor((lvl - threshold) / step) + 1) : 0);
        const addPerk = (req, label, active) => {
          perks.push({ req, label: `Lv ${req}+: ${label}`, active });
        };
        const bias = Math.round(Math.min(60, lvl * 2));
        addPerk(1, `+${bias}% higher-tier symbol bias (scales every level)`, lvl >= 1);
        const wildStacks = tierCount(5);
        addPerk(5, `Wild frequency bonus +${wildStacks * 2}% (grows every 5 levels)`, wildStacks > 0);
        const dropStacks = tierCount(10);
        addPerk(10, `Drop rate bonus +${dropStacks * 3}% (grows every 5 levels)`, dropStacks > 0);
        const payoutStacks = tierCount(15);
        const payoutBonus = payoutStacks > 0 ? 10 + (payoutStacks - 1) * 5 : 0;
        addPerk(15, payoutBonus > 0 ? `Payout skill boost +${payoutBonus}%` : 'Payout skill boost begins at Lv 15', payoutBonus > 0);
        const speedStacks = tierCount(20);
        addPerk(20, `Auto/idle speed bonus +${speedStacks * 5}%`, speedStacks > 0);
        const capBoost = Math.max(0, tierCount(25));
        addPerk(25, capBoost > 0 ? `Upgrade caps +${capBoost} for economy perks (Idle, Drop Boost, Speed, Bet Multiplier)` : 'Upgrade cap raises begin at Lv 25', capBoost > 0);
        const jackpotStacks = tierCount(30);
        addPerk(30, `Jackpot payout bonus +${jackpotStacks * 2}%`, jackpotStacks > 0);
        const nextUnlock = Math.max(5, (Math.floor(lvl / 5) + 1) * 5);
        const future = `Next perk upgrade at Lv ${nextUnlock}`;
        return { perks, future };
      };

      const buildUpgradeCard = (def) => {
        const level = Math.max(0, state.upgrades?.[def.key] || 0);
        const maxLevel = Math.max(0, getUpgradeMaxLevel(def.key));
        const reqs = def.requires ? (Array.isArray(def.requires) ? def.requires : [def.requires]) : [];
        const requirementsMet = reqs.every(req => (state.upgrades?.[req] || 0) > 0);
        const locked = reqs.length > 0 && !requirementsMet;
        const currentLabel = level > 0 ? formatUpgradeLevel(def, level) : 'None';
        const nextLabel = level >= maxLevel
          ? 'Maxed'
          : formatUpgradeLevel(def, level + 1);
        const cost = level >= maxLevel ? null : computeUpgradeCost(def, level);
        const buttonDisabled = state.busy || locked || level >= maxLevel || !Number.isFinite(cost);
        const buttonText = locked
          ? 'Locked'
          : level >= maxLevel
            ? 'Maxed'
            : `Buy ${formatMoney(cost || 0)}`;
        const requirementNote = locked
          ? `Requires ${reqs.map(req => getUpgradeDef(req)?.label || req).join(', ')}`
          : '';
        const skillLinkMap = {
          dropBoostUnlock: 'Drop Boost',
          dropRateEffect: 'Drop Boost',
          dropRateDuration: 'Drop Boost',
          payout: 'Payout Burst',
          payoutSkill: 'Payout Burst',
          wildUnlock: 'Wild Boost',
          wildFrequency: 'Wild Boost',
          retrigger: 'Retrigger',
          retriggerQuality: 'Retrigger',
          luckyLock: 'Lucky Lock',
          jackpotSurge: 'Jackpot Surge',
          bonusStorm: 'Bonus Storm'
        };
        const skillTags = skillLinkMap[def.key] ? [skillLinkMap[def.key]] : [];
        return `
          <div class="upgrade-card" data-upgrade-key="${def.key}">
            <h4>${def.label}</h4>
            <div class="upgrade-card__meta">
              <span>Level ${Math.min(level, maxLevel)}/${maxLevel}</span>
            </div>
            <div class="upgrade-card__note">Current: ${currentLabel}</div>
            <div class="upgrade-card__note">Next: ${nextLabel}</div>
            <button type="button" data-upgrade="${def.key}" ${buttonDisabled ? 'data-disabled="true" disabled' : ''}>${buttonText}</button>
            ${requirementNote ? `<div class="upgrade-card__note">${requirementNote}</div>` : ''}
            ${skillTags.length ? `<div class="upgrade-card__tags">${skillTags.map(tag => `<span class="upgrade-tag">${tag}</span>`).join('')}</div>` : ''}
          </div>
        `;
      };

      const renderUpgrades = () => {
        if (!els.upgradeGrid) return;
        if (els.upgradePanel) {
          els.upgradePanel.hidden = !state.gameReady;
        }
        if (!state.upgradeCatalog.length) {
          els.upgradeGrid.innerHTML = '<p class="muted-text">Loading upgrades</p>';
          return;
        }
        const grouped = state.upgradeCatalog.reduce((acc, def) => {
          if (!acc[def.category]) acc[def.category] = [];
          acc[def.category].push(def);
          return acc;
        }, {});
        const categoryOrder = ['Economy', 'Spin', 'Layout', 'Symbols', 'Drops', 'Skills', 'Auto Spin'];
        const seen = new Set();
        const sections = [];
        [...categoryOrder, ...Object.keys(grouped)].forEach(category => {
          if (!category || seen.has(category)) return;
          seen.add(category);
          const defs = grouped[category];
          if (!defs || !defs.length) return;
          const visibleDefs = defs.filter(def => {
            if (!def.requires) return true;
            const reqs = Array.isArray(def.requires) ? def.requires : [def.requires];
            return reqs.every(req => (state.upgrades?.[req] || 0) > 0);
          });
          if (!visibleDefs.length) return;
          sections.push(`
            <div class="upgrade-category" data-category="${category}">
              <h3>${category}</h3>
              <div class="upgrade-card-grid" role="group" aria-label="${category} upgrades">
                ${visibleDefs.map(buildUpgradeCard).join('')}
              </div>
            </div>
          `);
        });
        els.upgradeGrid.innerHTML = sections.join('') || '<p class="muted-text">No upgrades available.</p>';
        renderSkillStrip();
      };

      const focusUpgrade = (upgradeKey, message = '') => {
        if (!upgradeKey) return;
        setPaneActive('upgrades');
        if (els.upgradePanel) {
          els.upgradePanel.hidden = false;
        }
        requestFrame(() => {
          const card = document.querySelector(`[data-upgrade-key="${upgradeKey}"]`);
          if (!card) return;
          card.dataset.highlight = 'true';
          card.scrollIntoView?.({ behavior: 'smooth', block: 'center' });
          card.querySelector('button')?.focus?.({ preventScroll: true });
        });
        if (message) showAlert(message);
      };

      const DROP_ITEM_NAMES = {
        goldChip: 'Golden Chip',
        scratchCard: 'Scratch Card',
        circuit: 'Circuit',
        inventorySlotCoupon: 'Inventory Slot Coupon',
        gearSlotCoupon: 'Gear Slot Coupon',
        storageSlotCoupon: 'Storage Slot Coupon',
        deckSlotCoupon: 'Deck Slot Coupon',
        cardSlotCoupon: 'Card Slot Coupon',
        vipMarks: 'VIP Mark',
        reelMod: 'Reel Mod',
        spinBooster: 'Spin Booster',
        card: 'Card',
        gear: 'Gear'
      };
      const DROP_ITEM_ICONS = {
        goldChip: 'img/slot/items/gold_chip.png',
        scratchCard: 'img/slot/items/scratch_card.png',
        circuit: 'img/slot/items/circuit.png',
        inventorySlotCoupon: 'img/slot/items/inventory_slot_coupon.png',
        gearSlotCoupon: 'img/slot/items/gear_slot_coupon.png',
        storageSlotCoupon: 'img/slot/items/storage_slot_coupon.png',
        deckSlotCoupon: 'img/slot/items/deck_slot_coupon.png',
        cardSlotCoupon: 'img/slot/items/card_slot_coupon.png',
        vipMarks: 'img/slot/items/vip_mark.png',
        reelMod: 'img/slot/items/reel_mod_t1.png',
        spinBooster: 'img/slot/items/spinBoosterT1.png',
        card: 'img/slot/items/card.png',
        gear: 'img/slot/items/gear.png'
      };
      const DROP_TIER_ORDER = ['common', 'rare', 'epic'];
      const MAX_DROP_HISTORY = 25;
      const dropPercent = (value = 0) => `${(Math.min(1, Math.max(0, value)) * 100).toFixed(2)}%`;

      const normalizeDrop = (entry = {}) => {
        const type = entry.type || 'item';
        const name = entry.name || DROP_ITEM_NAMES[type] || type;
        const icon = entry.icon || DROP_ITEM_ICONS[type] || getPlaceholderAsset();
        const amount = Number.isFinite(entry.amount) ? entry.amount : 1;
        return {
          type,
          amount,
          name,
          icon,
          rarity: entry.rarity,
          tier: entry.tier
        };
      };

      const dropKey = (drop = {}) => {
        if (drop.type === 'gear') {
          return `gear:${drop.rarity || drop.tier || 'Basic'}`;
        }
        if (drop.type === 'card') {
          return `card:${drop.tier || drop.rarity || 'Basic'}`;
        }
        if (drop.type === 'reelMod' || drop.type === 'spinBooster') {
          return `${drop.type}:${drop.tier || 1}`;
        }
        return drop.type || 'item';
      };

      const inventoryMeta = (key = '') => {
        const [type, variant] = key.split(':');
        switch (type) {
          case 'gear':
            return { name: `${variant || 'Basic'} Gear`, icon: DROP_ITEM_ICONS.gear };
          case 'card':
            return { name: `${variant || 'Card'} Card`, icon: DROP_ITEM_ICONS.card };
          case 'reelMod':
            return { name: `Reel Mod ${variant ? `T${variant}` : ''}`.trim(), icon: DROP_ITEM_ICONS.reelMod };
          case 'spinBooster':
            return { name: `Spin Booster ${variant ? `T${variant}` : ''}`.trim(), icon: DROP_ITEM_ICONS.spinBooster };
          default:
            return { name: DROP_ITEM_NAMES[type] || type || 'Item', icon: DROP_ITEM_ICONS[type] || getPlaceholderAsset() };
        }
      };

      const applyDropState = (dropState = {}) => {
        if (!dropState || typeof dropState !== 'object') return;
        if (dropState.tableKey) state.drop.tableKey = dropState.tableKey;
        if (dropState.table) state.drop.table = dropState.table;
        if (dropState.tierWeights) {
          state.drop.tierWeights = { ...state.drop.tierWeights, ...dropState.tierWeights };
        }
        if (dropState.constants) {
          const c = dropState.constants;
          state.drop.constants = {
            ...state.drop.constants,
            betScale: Number(c.BET_DROP_SCALE ?? c.betScale ?? state.drop.constants.betScale),
            win: Number(c.WIN_DROP_MULT ?? c.win ?? state.drop.constants.win),
            lose: Number(c.LOSE_DROP_MULT ?? c.lose ?? state.drop.constants.lose),
            boostScale: Number(c.DROP_BOOST_SCALE ?? c.boostScale ?? state.drop.constants.boostScale)
          };
        }
        if (dropState.inventory) {
          state.drop.inventory = { ...dropState.inventory };
        }
        if (Array.isArray(dropState.lastDrops) && dropState.lastDrops.length && !state.drop.history.length) {
          recordDrops(dropState.lastDrops, Date.now());
        } else {
          renderDropLog();
        }
        updateSkillSpec();
        renderSkillButton();
        renderInventory();
        renderGear();
        renderCards();
        updateHud();
        renderBonusSummary();
      };

      const recordDrops = (drops = [], timestamp = Date.now()) => {
        if (!Array.isArray(drops) || !drops.length) return;
        const ts = Number.isFinite(timestamp) ? timestamp : Date.now();
        if (ts <= (state.drop.lastTimestamp || 0)) {
          state.drop.lastDrops = drops.map(normalizeDrop);
          return;
        }
        const normalized = drops.map(normalizeDrop);
        state.drop.lastDrops = normalized;
        state.drop.lastTimestamp = ts;
        state.drop.history.unshift({ timestamp: ts, drops: normalized });
        if (state.drop.history.length > MAX_DROP_HISTORY) {
          state.drop.history.length = MAX_DROP_HISTORY;
        }
        renderDropLog();
      };

      const pushFlyoverItem = (container, node, duration = 1500) => {
        if (!container || !node) return;
        container.appendChild(node);
        while (container.childElementCount > 4) {
          container.firstElementChild?.remove();
        }
        setTimeout(() => node.remove(), duration);
      };

      const showWinFlyover = (amount = 0) => {
        if (!Number.isFinite(amount) || amount <= 0) return;
        const item = document.createElement('div');
        item.className = 'flyover-item win';
        item.textContent = `+${formatMoney(amount)}`;
        pushFlyoverItem(els.flyoverLoot || els.flyoverTop, item, 1600);
      };

      const showDropFlyover = (drops = []) => {
        if (!Array.isArray(drops) || !drops.length) return;
        drops.slice(0, 3).forEach(drop => {
          const info = normalizeDrop(drop);
          const item = document.createElement('div');
          item.className = 'flyover-item drop';
          const img = document.createElement('img');
          img.src = info.icon;
          img.alt = info.name;
          const text = document.createElement('span');
          text.textContent = `${info.name} ${info.amount || 1}`;
          item.appendChild(img);
          item.appendChild(text);
          pushFlyoverItem(els.flyoverLoot || els.flyoverTop, item, 1800);
        });
      };

      const showLevelFlyover = (level = 0) => {
        if (!Number.isFinite(level)) return;
        const item = document.createElement('div');
        item.className = 'flyover-item level';
        item.textContent = `Level ${level} reached`;
        pushFlyoverItem(els.flyoverLevel || els.flyoverTop, item, 1700);
      };

      const showXpFlyover = (xp = 0) => {
        if (!Number.isFinite(xp) || xp <= 0) return;
        const item = document.createElement('div');
        item.className = 'flyover-item xp';
        item.textContent = `+${formatCompactNumber(xp)} XP`;
        pushFlyoverItem(els.flyoverXp || els.flyoverTop, item, 1400);
      };

      const applyDropsToInventory = (drops = [], timestamp = Date.now()) => {
        if (!Array.isArray(drops) || !drops.length) return;
        drops.forEach(drop => {
          const key = dropKey(drop);
          const amount = Number.isFinite(drop.amount) ? drop.amount : 1;
          state.drop.inventory[key] = (state.drop.inventory[key] || 0) + amount;
          if (drop.type === 'vipMarks') {
            state.drop.inventory.vipMarks = state.drop.inventory[key];
          }
          if (drop.type === 'gear') {
            for (let i = 0; i < amount; i += 1) addGear(generateGear(drop.rarity || drop.tier));
          }
          if (drop.type === 'card') {
            for (let i = 0; i < amount; i += 1) addCard(generateCard(drop.rarity || drop.tier));
          }
          if (drop.type === 'gearSlotCoupon') {
            state.equipment.slotCap = Math.min(gearSlotsList().length, (state.equipment.slotCap || 0) + amount);
          }
          if (drop.type === 'deckSlotCoupon' || drop.type === 'cardSlotCoupon') {
            state.cards.slots = Math.min(5, (state.cards.slots || 0) + amount);
          }
        });
        recordDrops(drops, timestamp);
        renderInventory();
        renderGear();
        renderCards();
        renderBonusSummary();
        updateHud();
        saveLocalEquipment();
        saveLocalCards();
        markDirty('drop');
      };

      const consumeSpinModifiers = () => {
        const inventory = state.drop.inventory || {};
        let extraReels = 0;
        let payoutMult = 1;
        const consumed = [];
        const reelKey = Object.keys(inventory).find(key => key.startsWith('reelMod') && inventory[key] > 0);
        if (reelKey) {
          inventory[reelKey] -= 1;
          if (inventory[reelKey] <= 0) delete inventory[reelKey];
          extraReels = 1;
          consumed.push('Reel Mod');
        }
        const boosterKey = Object.keys(inventory).find(key => key.startsWith('spinBooster') && inventory[key] > 0);
        if (boosterKey) {
          inventory[boosterKey] -= 1;
          if (inventory[boosterKey] <= 0) delete inventory[boosterKey];
          payoutMult = 2;
          consumed.push('Spin Booster');
        }
        if (consumed.length) {
          renderInventory();
          renderBonusSummary();
          markDirty('drop');
          log('Modifiers applied', consumed.join('  '));
        }
        return { extraReels, payoutMult };
      };

      const renderInventory = () => {
        if (!els.inventoryGrid) return;
        const entries = Object.entries(state.drop.inventory || {}).filter(([, count]) => Number(count) > 0);
        if (!entries.length) {
          els.inventoryGrid.innerHTML = '<span class="muted-text">No drops yet.</span>';
          return;
        }
        entries.sort((a, b) => b[1] - a[1]);
        const chips = entries.slice(0, 6).map(([key, count]) => {
          const meta = inventoryMeta(key);
          return `
            <span class="inventory-chip" data-key="${key}">
              <img src="${meta.icon}" alt="${meta.name}">
              <span>${meta.name}</span>
              <strong class="drop-amount">${count}</strong>
            </span>
          `;
        });
        els.inventoryGrid.innerHTML = chips.join('');
      };
      const renderPremiumShop = () => {
        if (!els.premiumGrid) return;
        const purchases = state.premium.purchases || {};
        const vip = getVipBalance();
        if (els.premiumVipBalance) els.premiumVipBalance.textContent = `VIP ${vip}`;
        els.premiumGrid.innerHTML = PREMIUM_ITEMS.map(item => {
          const level = purchases[item.key] || 0;
          const maxed = level >= (item.max || 1);
          const cost = maxed ? null : item.costVip;
          const disabled = maxed || vip < (cost || 0);
          return `
            <div class="premium-item" data-premium-key="${item.key}">
              <h4>${item.name}</h4>
              <p class="premium-meta"><span>${item.desc}</span><span>Lv ${Math.min(level, item.max || 1)}/${item.max || 1}</span></p>
              <div class="premium-actions">
                <button type="button" class="ghost-btn primary" data-buy-premium="${item.key}" ${disabled ? 'disabled' : ''}>${maxed ? 'Maxed' : `Buy (${item.costVip} VIP)`}</button>
              </div>
            </div>
          `;
        }).join('');
      };
      const togglePremiumPanel = (open = false) => {
        if (!els.premiumPanel) return;
        els.premiumPanel.hidden = !open;
        els.premiumPanel.setAttribute('aria-hidden', open ? 'false' : 'true');
        if (open) {
          renderPremiumShop();
          els.premiumPanel.focus?.({ preventScroll: true });
        }
      };
      const purchasePremium = (key) => {
        const item = premiumItemByKey.get(key);
        if (!item) return;
        const purchases = state.premium.purchases || (state.premium.purchases = {});
        const level = purchases[key] || 0;
        if (level >= (item.max || 1)) {
          showAlert('Already maxed.');
          return;
        }
        const vip = getVipBalance();
        if (vip < item.costVip) {
          showAlert(`Need ${item.costVip} VIP marks.`);
          return;
        }
        spendVip(item.costVip);
        purchases[key] = level + 1;
        applyPremiumMods();
        renderPremiumShop();
        renderBonusSummary();
        updateHud();
        showAlert(`${item.name} purchased!`);
      };

      const renderDropLog = () => {
        if (!els.dropLog) return;
        const history = state.drop.history || [];
        if (!history.length) {
          els.dropLog.textContent = 'Spin to collect items.';
          return;
        }
        const rows = history.slice(0, 8).map(entry => {
          const time = new Date(entry.timestamp).toLocaleTimeString();
          const parts = entry.drops.map(drop => {
            const info = normalizeDrop(drop);
            return `<span class="rate-item"><img class="drop-icon" src="${info.icon}" alt="${info.name}">${info.name} ${info.amount}</span>`;
          }).join(', ');
          return `<div class="drop-entry"><strong>${time}</strong><span aria-hidden="true"> - </span><span>${parts}</span></div>`;
        });
        els.dropLog.innerHTML = rows.join('');
      };

      const getDropTable = () => state.drop.table || { common: [], rare: [], epic: [] };
      const getTierWeights = () => state.drop.tierWeights || { common: 0.8, rare: 0.15, epic: 0.05 };

      const isDropSkillActive = () => {
        const skill = state.skills.dropRate;
        if (!skill) return false;
        const now = Date.now();
        if (skill.active && skill.expiresAt && now >= skill.expiresAt) {
          skill.active = false;
        }
        if (!skill.active && skill.expiresAt && now >= skill.expiresAt) {
          skill.expiresAt = 0;
        }
        if (skill.cooldownUntil && now >= skill.cooldownUntil) {
          skill.cooldownUntil = 0;
        }
        return skill.active;
      };

      const computeDropMultiplier = ({ bet = 1, payout = 0 } = {}) => {
        const constants = state.drop.constants || {};
        const betScale = Number(constants.betScale) || 0.1;
        const boostScale = Number(constants.boostScale) || 0.05;
        const winMult = Number(constants.win) || 2;
        const loseMult = Number(constants.lose) || 1;
        const dropBoost = Math.max(0, state.upgrades.dropBoost || 0);
        const base = 1 + boostScale * dropBoost;
        const safeBet = Math.max(0, bet);
        const betMult = 1 + betScale * Math.log(1 + safeBet);
        const skillMult = isDropSkillActive() ? (state.skills.dropRate?.spec?.multiplier || 1) : 1;
        const outcome = payout > 0 ? winMult : loseMult;
        const equip = computeEquipmentStats();
        const equipMult = 1 + Math.max(0, equip.dropPct || 0) / 100;
        const perks = getLevelPerkEffects();
        const levelMult = perks.dropMult || 1;
        const premiumMult = state.premium?.mods?.dropMult || 1;
        const legacyMult = 1 + (Object.keys(state.globalPerks || {}).length * 0.03);
        return {
          total: base * betMult * skillMult * outcome * equipMult * levelMult * premiumMult * legacyMult,
          components: { base, bet: betMult, skill: skillMult, outcome, equip: equipMult, level: levelMult, premium: premiumMult, legacy: legacyMult }
        };
      };

      const getDropMultiplier = (win = false) => computeDropMultiplier({
        bet: state.bet || 1,
        payout: win ? 1 : 0
      });

      const computeDropRates = (mult = 1) => {
        const table = getDropTable();
        const tiers = DROP_TIER_ORDER.filter(tier => Array.isArray(table[tier]) && table[tier].length);
        const weights = tiers.map(tier => getTierWeights()[tier] || 0);
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0) || 1;
        const rates = [];
        tiers.forEach((tier, idx) => {
          const tierProb = (weights[idx] || 0) / totalWeight;
          (table[tier] || []).forEach(entry => {
            const baseChance = Math.max(0, Number(entry.chance) || 0);
            const chance = Math.min(1, baseChance * mult) * tierProb;
            const drop = normalizeDrop(entry);
            rates.push({ ...drop, chance, tier });
          });
        });
        return rates.sort((a, b) => b.chance - a.chance);
      };

      const rollDropsForSpin = (bet = 1, payout = 0) => {
        const table = getDropTable();
        const tiers = DROP_TIER_ORDER.filter(tier => Array.isArray(table[tier]) && table[tier].length);
        if (!tiers.length) return { drops: [], multiplier: computeDropMultiplier({ bet, payout }) };
        const weights = tiers.map(tier => getTierWeights()[tier] || 0);
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0) || 1;
        const mult = computeDropMultiplier({ bet, payout });
        const drops = [];
        tiers.forEach((tier, idx) => {
          const tierProb = (weights[idx] || 0) / totalWeight;
          (table[tier] || []).forEach(entry => {
            const baseChance = Math.max(0, Number(entry.chance) || 0);
            const chance = Math.min(1, baseChance * mult.total) * tierProb;
            if (chance > 0 && Math.random() < chance) {
              drops.push(normalizeDrop(entry));
            }
          });
        });
        return { drops, multiplier: mult };
      };

      const renderDropPanel = (panel = els.dropPanel) => {
        if (!panel) return;
        const target = panel.matches('[data-drop-body]')
          ? panel
          : (panel.querySelector('[data-drop-body]') || panel);
        const lossMult = getDropMultiplier(false);
        const winMult = getDropMultiplier(true);
        const rates = computeDropRates(winMult.total);
        if (!rates.length) {
          target.innerHTML = '<p class="muted-text">Drop table not loaded yet.</p>';
          return;
        }
        const groups = DROP_TIER_ORDER.map(tier => ({
          tier,
          list: rates.filter(rate => rate.tier === tier)
        })).filter(group => group.list.length);
        const listHtml = groups.map(group => `
          <p class="drop-tier-label">${group.tier}</p>
          <ul>
            ${group.list.map(rate => `
              <li>
                <span class="rate-item"><img class="drop-icon" src="${rate.icon}" alt="${rate.name}">${rate.name}</span>
                <span class="drop-amount">${dropPercent(rate.chance)}</span>
              </li>
            `).join('')}
          </ul>
        `).join('');
        const includeHeading = target === panel;
        target.innerHTML = `
          ${includeHeading ? '<h4>Drop rates</h4>' : ''}
          <p class="drop-mult">Win: ${winMult.total.toFixed(2)}  Loss: ${lossMult.total.toFixed(2)}</p>
          ${listHtml || '<p class="muted-text">No drops configured.</p>'}
        `;
      };

      const renderOpenDropPanels = () => {
        [els.dropPanel, els.dropPanelOverlay].forEach(panel => {
          if (panel && !panel.hidden) {
            renderDropPanel(panel);
          }
        });
      };

      const randomChoice = (arr = []) => {
        if (!Array.isArray(arr) || !arr.length) return null;
        return arr[Math.floor(Math.random() * arr.length)];
      };
      const rollRange = (value) => {
        if (Array.isArray(value) && value.length >= 2) {
          const [min, max] = value;
          const span = Math.max(0, (max ?? min) - (min ?? 0));
          return Math.round((min ?? 0) + Math.random() * span);
        }
        return Number.isFinite(value) ? value : 0;
      };

      const loadGearDefinitions = async () => {
        if (gearDefinitions) return gearDefinitions;
        if (state.offlineMode) {
          gearDefinitions = OFFLINE_DATA.gearDefs;
          return gearDefinitions;
        }
        try {
          const res = await fetch(GEAR_DEFS_URL, { cache: 'no-cache' });
          if (res.ok) {
            gearDefinitions = await res.json();
          }
        } catch (error) {
          debugError('gear-defs', error);
        }
        if (!gearDefinitions) {
          gearDefinitions = { slots: ['Head', 'Outfit', 'Accessory', 'Pet', 'Trinket'], rarities: [], names: {}, bonuses: {} };
        }
        return gearDefinitions;
      };

      const loadCardDefinitions = async () => {
        if (cardDefinitions) return cardDefinitions;
        if (state.offlineMode) {
          cardDefinitions = OFFLINE_DATA.cardDefs;
          return cardDefinitions;
        }
        try {
          const res = await fetch(CARD_DEFS_URL, { cache: 'no-cache' });
          if (res.ok) {
            cardDefinitions = await res.json();
          }
        } catch (error) {
          debugError('card-defs', error);
        }
        if (!cardDefinitions) {
          cardDefinitions = { definitions: [], effects: {} };
        }
        return cardDefinitions;
      };

      const loadLocalEquipment = () => {
        try {
          const raw = localStorage.getItem(LOCAL_EQUIPMENT_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch {
          return null;
        }
      };
      const saveLocalEquipment = () => {
        try {
          localStorage.setItem(LOCAL_EQUIPMENT_KEY, JSON.stringify(state.equipment));
        } catch {
          // ignore
        }
      };
      const defaultEquipmentState = () => ({
        slots: { Head: null, Outfit: null, Accessory: null, Pet: null, Trinket: null },
        inventory: [],
        slotCap: 3
      });
      const loadLocalCards = () => {
        try {
          const raw = localStorage.getItem(LOCAL_CARD_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch {
          return null;
        }
      };
      const saveLocalCards = () => {
        try {
          localStorage.setItem(LOCAL_CARD_KEY, JSON.stringify(state.cards));
        } catch {
          // ignore
        }
      };
      const defaultCardState = () => ({
        deck: [],
        collection: [],
        slots: 3
      });
      const resetLocalProgress = () => {
        clearLocalUpgradeState();
        state.pendingUpgrades = {};
        state.serverUpgrades = {};
        state.upgrades = {};
        state.pendingIdleCoins = 0;
        resetAutoState();
        state.drop.inventory = {};
        state.drop.history = [];
        state.drop.lastDrops = [];
        state.drop.lastTimestamp = 0;
        state.equipment = defaultEquipmentState();
        state.cards = defaultCardState();
        saveLocalEquipment();
        saveLocalCards();
        renderDropLog();
        renderInventory();
        renderGear();
        renderCards();
        renderBonusSummary();
        applyUpgradeState({});
        setBetValue(1);
      };

      const markDirty = (reason = 'change') => {
        state.sync.dirty = true;
        state.sync.queue.push({ reason, at: Date.now() });
        scheduleSync();
      };

      const buildSnapshot = () => ({
        v: 1,
        rev: state.sync.rev || 0,
        updatedAt: Date.now(),
        playerId: state.playerId,
        balance: state.balance,
        bet: state.bet,
        maxBet: state.maxBet,
        spinCount: state.spinCount,
        lastWin: state.lastWin,
        machines: state.machines,
        worker: { active: state.worker.active, intervalMs: state.worker.intervalMs },
        skills: { payout: state.skills.payout, dropRate: state.skills.dropRate },
        machine: {
          id: state.machine.id,
          rows: state.currentRows || state.machine.rows,
          reels: state.currentReels || state.machine.reels,
          lineTier: state.currentLineTier || 0,
          upgrades: { ...getMachineUpgrades(state.machine.id) },
          spinTiming: state.machine.spinTiming
        },
        drop: {
          inventory: state.drop.inventory || {},
          history: state.drop.history || [],
          lastDrops: state.drop.lastDrops || [],
          lastTimestamp: state.drop.lastTimestamp || 0
        },
        equipment: state.equipment,
        cards: state.cards,
        daily: state.daily,
        idle: {
          pending: state.pendingIdleCoins || 0,
          lastTick: state.lastIdleTick || 0
        },
        upgrades: state.serverUpgrades,
        clientUpgrades: Object.fromEntries(
          Object.entries(localUpgrades || {}).map(([machineId, bucket]) => [machineId, { ...bucket }])
        ),
        symbolMap: Array.from(state.symbolMap.entries() || [])
      });

      const applySnapshot = async (snapshot = {}, source = 'sync') => {
        if (!snapshot || typeof snapshot !== 'object') return;
        if (typeof snapshot.rev === 'number') state.sync.rev = Math.max(state.sync.rev || 0, snapshot.rev);
        if (typeof snapshot.balance === 'number') {
          state.balance = snapshot.balance;
          if (els.balance) els.balance.textContent = formatMoney(state.balance, { compact: false });
        }
        if (Number.isFinite(snapshot.bet)) setBetValue(snapshot.bet);
        if (snapshot.maxBet) {
          state.maxBet = resolveMaxBet(snapshot.maxBet);
          els.maxBet.textContent = formatMoney(state.maxBet);
          syncBetSteps();
        }
        if (typeof snapshot.spinCount === 'number' && els.spinCount) els.spinCount.textContent = snapshot.spinCount;
        if (snapshot.daily) applyDailyState(snapshot.daily, snapshot.reward);
        if (snapshot.drop) applyDropState(snapshot.drop);
        if (snapshot.machines) {
          state.machines = { ...state.machines, ...snapshot.machines };
        }
        if (snapshot.equipment) {
          state.equipment = snapshot.equipment;
          saveLocalEquipment();
          renderGear();
        }
        if (snapshot.cards) {
          state.cards = snapshot.cards;
          saveLocalCards();
          renderCards();
        }
        if (snapshot.clientUpgrades) {
          Object.assign(localUpgrades, snapshot.clientUpgrades);
          saveLocalUpgrades(localUpgrades);
        }
        if (snapshot.upgrades) {
          ensureMachineProgress(state.machine.id).upgrades = { ...snapshot.upgrades };
        }
        if (snapshot.machine?.upgrades) {
          ensureMachineProgress(snapshot.machine.id || state.machine.id).upgrades = { ...snapshot.machine.upgrades };
        }
        if (snapshot.machine?.id) {
          await setActiveMachine(snapshot.machine.id, { silent: true });
        }
        if (snapshot.machine?.rows) state.currentRows = snapshot.machine.rows;
        if (snapshot.machine?.reels) state.currentReels = snapshot.machine.reels;
        if (snapshot.machine?.lineTier !== undefined) state.currentLineTier = snapshot.machine.lineTier;
        if (snapshot.machine?.spinTiming) state.machine.spinTiming = { ...snapshot.machine.spinTiming };
        if (Array.isArray(snapshot.symbolMap)) {
          state.symbolMap = new Map(snapshot.symbolMap);
          auditSymbolAssets();
          renderPaytable();
        }
        if (snapshot.worker) state.worker = { ...state.worker, ...snapshot.worker };
        if (snapshot.skills?.payout) state.skills.payout = { ...state.skills.payout, ...snapshot.skills.payout };
        if (snapshot.idle) {
          state.pendingIdleCoins = snapshot.idle.pending || 0;
          state.lastIdleTick = snapshot.idle.lastTick || 0;
        }
        applyUpgradeState(getMachineUpgrades(state.machine.id));
        renderBonusSummary();
        updateHud();
        if (source === 'sync') {
          state.sync.dirty = false;
          state.sync.queue = [];
        }
      };

      const loadOfflineSnapshot = () => {
        try {
          const raw = localStorage.getItem(OFFLINE_SNAPSHOT_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch (error) {
          debugError('offline:load', error);
          return null;
        }
      };

      const saveOfflineSnapshot = (snapshot) => {
        try {
          localStorage.setItem(OFFLINE_SNAPSHOT_KEY, JSON.stringify(snapshot));
        } catch (error) {
          debugError('offline:save', error);
        }
      };

      const stopSessionSync = () => {
        if (sessionSyncTimer) {
          clearInterval(sessionSyncTimer);
          sessionSyncTimer = null;
        }
        if (state.sync.debounceTimer) {
          clearTimeout(state.sync.debounceTimer);
          state.sync.debounceTimer = null;
        }
        state.sync.inFlight = false;
      };

      const syncSnapshot = async (force = false) => {
        if (state.offlineMode) {
          if (!force && !state.sync.dirty) return;
          if (state.sync.inFlight) return;
          state.sync.inFlight = true;
          const snapshot = buildSnapshot();
          saveOfflineSnapshot(snapshot);
          state.sync.lastPush = Date.now();
          state.sync.dirty = false;
          state.sync.queue = [];
          state.sync.inFlight = false;
          return;
        }
        if (!state.auth.token) return;
        if (!force && !state.sync.dirty) return;
        if (state.sync.inFlight) return;
        state.sync.inFlight = true;
        const snapshot = buildSnapshot();
        const payloadBytes = textEncoder.encode(JSON.stringify(snapshot));
        let signature = null;
        try {
          const sig = await hmacSign(state.auth.token, payloadBytes, 'sync');
          signature = { salt: base64UrlEncode(sig.salt), value: base64UrlEncode(sig.sig) };
        } catch (error) {
          debugError('sync:hmac', error);
        }
        try {
          const res = await request(SYNC_ENDPOINT, { snapshot, signature });
          if (res?.snapshot) {
            await applySnapshot(res.snapshot, 'sync');
          } else if (typeof res?.rev === 'number') {
            state.sync.rev = Math.max(state.sync.rev || 0, res.rev);
            state.sync.dirty = false;
            state.sync.queue = [];
          }
          state.sync.lastPush = Date.now();
        } catch (error) {
          log('Sync failed', error.message || 'Sync error');
          debugError('sync', error);
        } finally {
          state.sync.inFlight = false;
        }
      };

      const scheduleSync = () => {
        if (state.sync.debounceTimer) {
          clearTimeout(state.sync.debounceTimer);
        }
        state.sync.debounceTimer = setTimeout(() => {
          syncSnapshot(false);
        }, SYNC_DEBOUNCE_MS);
      };

      const startSessionSync = () => {
        stopSessionSync();
        if (state.offlineMode || !state.auth.token) return;
        sessionSyncTimer = setInterval(() => {
          syncSnapshot(true);
        }, SESSION_SYNC_MS);
      };

      const exportStateKey = async () => {
        if (state.offlineMode) {
          showAuthAlert('Export unavailable in offline demo mode.');
          return;
        }
        if (!state.auth.token) {
          showAuthAlert('Sign in to export your state.');
          return;
        }
        if (state.busy) return;
        const snapshot = buildSnapshot();
        const payload = textEncoder.encode(JSON.stringify(snapshot));
        try {
          const blob = await encryptBlob(state.auth.token, payload);
          const bundle = {
            v: EXPORT_VERSION,
            s: base64UrlEncode(blob.salt),
            i: base64UrlEncode(blob.iv),
            c: base64UrlEncode(blob.cipher)
          };
          const signBytes = textEncoder.encode(JSON.stringify({ v: bundle.v, s: bundle.s, i: bundle.i, c: bundle.c }));
          const sig = await hmacSign(state.auth.token, signBytes, 'export');
          bundle.h = { s: base64UrlEncode(sig.salt), v: base64UrlEncode(sig.sig) };
          const encoded = base64UrlEncode(textEncoder.encode(JSON.stringify(bundle)));
          if (els.importStateInput) els.importStateInput.value = encoded;
          if (els.transferStatus) {
            els.transferStatus.textContent = 'Exported encrypted key.';
          }
          try {
            await navigator.clipboard?.writeText?.(encoded);
          } catch {
            // clipboard may be unavailable; ignore
          }
          log('State exported', `rev ${state.sync.rev || 0}`);
        } catch (error) {
          if (els.transferStatus) {
            els.transferStatus.textContent = 'Export failed.';
          }
          debugError('export', error);
        }
      };

      const importStateKey = async () => {
        if (state.offlineMode) {
          showAuthAlert('Import unavailable in offline demo mode.');
          return;
        }
        if (!state.auth.token) {
          showAuthAlert('Sign in to import a state key.');
          return;
        }
        const raw = (els.importStateInput?.value || '').trim();
        if (!raw) {
          if (els.transferStatus) els.transferStatus.textContent = 'Paste a key to import.';
          return;
        }
        try {
          const decoded = base64UrlDecode(raw);
          const parsed = safeJsonParse(textDecoder.decode(decoded));
          if (!parsed || parsed.v !== EXPORT_VERSION) throw new Error('Invalid key format.');
          const blob = {
            salt: base64UrlDecode(parsed.s || ''),
            iv: base64UrlDecode(parsed.i || ''),
            cipher: base64UrlDecode(parsed.c || '')
          };
          const forSign = { v: parsed.v, s: parsed.s, i: parsed.i, c: parsed.c };
          const valid = await hmacVerify(
            state.auth.token,
            textEncoder.encode(JSON.stringify(forSign)),
            { salt: parsed.h?.s || parsed.h?.salt, value: parsed.h?.v || parsed.h?.value },
            'export'
          );
          if (!valid) throw new Error('Export key signature invalid.');
          const plain = await decryptBlob(state.auth.token, blob);
          const snapshot = safeJsonParse(textDecoder.decode(plain));
          if (!snapshot) throw new Error('Invalid snapshot.');
          await applySnapshot(snapshot, 'import');
          markDirty('import');
          if (els.transferStatus) {
            els.transferStatus.textContent = 'Import applied. Syncing';
          }
          syncSnapshot(true);
        } catch (error) {
          if (els.transferStatus) {
            els.transferStatus.textContent = error.message || 'Import failed.';
          }
          debugError('import', error);
        }
      };

      const hydrateLocalCollections = () => {
        const savedGear = loadLocalEquipment();
        if (savedGear) {
          state.equipment = {
            ...state.equipment,
            ...savedGear,
            slots: { ...state.equipment.slots, ...(savedGear.slots || {}) }
          };
        }
        const savedCards = loadLocalCards();
        if (savedCards) {
          state.cards = {
            ...state.cards,
            ...savedCards,
            deck: Array.isArray(savedCards.deck) ? savedCards.deck : [],
            collection: Array.isArray(savedCards.collection) ? savedCards.collection : []
          };
        }
      };

      const gearSlotsList = () => Object.keys(state.equipment.slots || { Head: null, Outfit: null, Accessory: null, Pet: null, Trinket: null });
      const unlockedGearSlots = () => Math.min(state.equipment.slotCap || gearSlotsList().length, gearSlotsList().length);
      const gearIconFor = (rarity = 'basic', slot = 'accessory') => `img/slot/gear/${rarity.toLowerCase()}/gear_${rarity.toLowerCase()}_${slot.toLowerCase()}.png`;

      const generateGear = (rarityHint = null) => {
        const defs = gearDefinitions || {};
        const rarities = defs.rarities || [];
        const rarity = rarityHint
          || (rarities.length
            ? (() => {
              const total = rarities.reduce((sum, r) => sum + (r.dropChance || 0), 0) || 1;
              let roll = Math.random() * total;
              for (const r of rarities) {
                roll -= r.dropChance || 0;
                if (roll <= 0) return r.name;
              }
              return rarities[0].name;
            })()
            : 'Basic');
        const slot = randomChoice(defs.slots || gearSlotsList()) || 'Accessory';
        const bonusPool = defs.bonuses?.[rarity]?.bonuses || [];
        const bonus = randomChoice(bonusPool) || { desc: '+0% drops', dropPct: [1, 2] };
        const effects = {
          coinFlat: rollRange(bonus.coinFlat),
          coinPct: rollRange(bonus.coinPct),
          dropPct: rollRange(bonus.dropPct),
          idlePct: rollRange(bonus.idlePct),
          gearDropPct: rollRange(bonus.gearDropPct) || 0,
          tierChance: bonus.tierChance || null,
          unique: bonus.unique || null
        };
        const desc = (bonus.desc || '').replace('{coinFlat}', effects.coinFlat || 0).replace('{coinPct}', effects.coinPct || 0).replace('{dropPct}', effects.dropPct || 0).replace('{idlePct}', effects.idlePct || 0).replace('{gearDropPct}', effects.gearDropPct || 0);
        const name = defs.names?.[rarity]?.[slot]?.name || `${rarity} ${slot}`;
        return {
          id: `gear-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
          rarity,
          slot,
          name,
          level: 1,
          desc,
          effects,
          icon: gearIconFor(rarity, slot)
        };
      };

      const addGear = (gear) => {
        if (!gear) return;
        if (!Array.isArray(state.equipment.inventory)) state.equipment.inventory = [];
        state.equipment.inventory.push(gear);
        saveLocalEquipment();
      };

      const equipGear = (gearId, targetSlot = null) => {
        const gear = (state.equipment.inventory || []).find(item => item.id === gearId);
        if (!gear) return;
        const slot = targetSlot || gear.slot || gearSlotsList()[0];
        const slotIndex = gearSlotsList().indexOf(slot);
        if (slotIndex >= unlockedGearSlots()) {
          showAlert('Unlock more equipment slots first.');
          return;
        }
        state.equipment.slots[slot] = gear;
        state.equipment.inventory = state.equipment.inventory.filter(item => item.id !== gearId);
        saveLocalEquipment();
        renderGear();
        renderBonusSummary();
        markDirty('gear-equip');
      };

      const unequipGear = (slot) => {
        const current = state.equipment.slots?.[slot];
        if (!current) return;
        state.equipment.slots[slot] = null;
        state.equipment.inventory.push(current);
        saveLocalEquipment();
        renderGear();
        renderBonusSummary();
        markDirty('gear-unequip');
      };

      const upgradeGear = (gearId) => {
        const vip = Number(state.drop.inventory?.vipMarks || 0);
        const allGear = [...(state.equipment.inventory || []), ...Object.values(state.equipment.slots || {})].filter(Boolean);
        const gear = allGear.find(item => item.id === gearId);
        if (!gear) return;
        const cost = Math.max(1, gear.level || 1);
        if (vip < cost) {
          showAlert('Not enough VIP marks to upgrade gear.');
          return;
        }
        state.drop.inventory.vipMarks = vip - cost;
        gear.level = (gear.level || 1) + 1;
        saveLocalEquipment();
        renderGear();
        renderInventory();
        renderBonusSummary();
        updateHud();
        markDirty('gear-upgrade');
      };

      const generateCard = (tierHint = null) => {
        const defs = cardDefinitions?.definitions || [];
        const filtered = defs.filter(c => !tierHint || c.tier === tierHint);
        const pick = randomChoice(filtered.length ? filtered : defs) || { name: 'Wildcard', tier: tierHint || 'Basic', icon: DROP_ITEM_ICONS.card, desc: 'Generic card from offline pool.' };
        const level = 1;
        const effectText = (cardDefinitions?.effects?.[pick.name] || [])[level - 1] || '';
        return {
          id: `card-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
          name: pick.name,
          tier: pick.tier || 'Basic',
          icon: pick.icon || DROP_ITEM_ICONS.card,
          desc: pick.desc || '',
          level,
          effect: effectText
        };
      };

      const addCard = (card) => {
        if (!card) return;
        if (!Array.isArray(state.cards.collection)) state.cards.collection = [];
        state.cards.collection.push(card);
        saveLocalCards();
      };

      const equipCard = (cardId, slotIndex = 0) => {
        const card = (state.cards.collection || []).find(c => c.id === cardId);
        if (!card) return;
        const maxSlots = Math.max(1, state.cards.slots || 1);
        if (slotIndex >= maxSlots) {
          showAlert('Unlock more card slots first.');
          return;
        }
        state.cards.deck = state.cards.deck || [];
        state.cards.deck[slotIndex] = cardId;
        saveLocalCards();
        renderCards();
        renderBonusSummary();
        markDirty('card-equip');
      };

      const unequipCard = (slotIndex = 0) => {
        if (!Array.isArray(state.cards.deck)) return;
        state.cards.deck[slotIndex] = null;
        saveLocalCards();
        renderCards();
        renderBonusSummary();
        markDirty('card-unequip');
      };

      const upgradeCard = (cardId) => {
        const vip = Number(state.drop.inventory?.vipMarks || 0);
        const card = (state.cards.collection || []).find(c => c.id === cardId);
        if (!card) return;
        const cost = Math.max(1, card.level || 1);
        if (vip < cost) {
          showAlert('Not enough VIP marks to upgrade this card.');
          return;
        }
        state.drop.inventory.vipMarks = vip - cost;
        card.level = (card.level || 1) + 1;
        const effectList = cardDefinitions?.effects?.[card.name] || [];
        card.effect = effectList[card.level - 1] || card.effect;
        saveLocalCards();
        renderCards();
        renderInventory();
        renderBonusSummary();
        updateHud();
        markDirty('card-upgrade');
      };

      const parseEffectText = (text = '') => {
        const stats = {};
        const pctMatch = text.match(/([+\\-]?\\d+(?:\\.\\d+)?)%/);
        const pct = pctMatch ? parseFloat(pctMatch[1]) : 0;
        if (/coin/i.test(text)) stats.coinPct = pct;
        if (/drop/i.test(text)) stats.dropPct = pct;
        if (/idle|delay/i.test(text)) stats.idlePct = pct;
        if (/speed|faster|spin/i.test(text)) stats.speedPct = pct;
        return stats;
      };

      const computeEquipmentStats = () => {
        const totals = { coinPct: 0, dropPct: 0, idlePct: 0 };
        Object.values(state.equipment.slots || {}).forEach(item => {
          if (!item) return;
          const level = Math.max(1, item.level || 1);
          const fx = item.effects || {};
          if (fx.coinPct) totals.coinPct += fx.coinPct * level;
          if (fx.dropPct) totals.dropPct += fx.dropPct * level;
          if (fx.idlePct) totals.idlePct += fx.idlePct * level;
        });
        if (Array.isArray(state.cards.deck)) {
          state.cards.deck.forEach(id => {
            const card = (state.cards.collection || []).find(c => c.id === id);
            if (!card) return;
            const stats = parseEffectText(card.effect || '');
            if (stats.coinPct) totals.coinPct += stats.coinPct;
            if (stats.dropPct) totals.dropPct += stats.dropPct;
            if (stats.idlePct) totals.idlePct += stats.idlePct;
          });
        }
        return totals;
      };

      const renderGear = () => {
        if (!els.gearSlots || !els.gearInventory) return;
        if (!state.equipment) return;
        const slots = gearSlotsList();
        const unlocked = unlockedGearSlots();
        const slotHtml = slots.map((slot, idx) => {
          const item = state.equipment.slots?.[slot];
          const locked = idx >= unlocked;
          const bonus = item ? `<p class=\"gear-slot__bonus\">${item.desc || ''}</p>` : '<p class=\"gear-slot__bonus\">Choose an item below to equip.</p>';
          const actions = locked
            ? '<span class=\"muted-text\">Locked slot</span>'
            : item
              ? `<div class=\"actions\"><button type=\"button\" class=\"ghost-btn secondary\" data-unequip-slot=\"${slot}\">Unequip</button><button type=\"button\" class=\"ghost-btn tertiary\" data-upgrade-gear=\"${item.id}\">Upgrade (VIP)</button></div>`
              : '<span class=\"muted-text\">Empty</span>';
          return `
            <div class="gear-slot ${locked ? 'locked' : ''}" data-slot="${slot}">
              <div class="gear-slot__meta">
                <strong class="gear-slot__name">${slot}</strong>
                ${item ? `<span class="rarity-tag">${item.rarity}  Lv ${item.level || 1}</span>` : ''}
              </div>
              ${bonus}
              ${actions}
            </div>
          `;
        }).join('');
        els.gearSlots.innerHTML = slotHtml;
        const equippedIds = new Set(Object.values(state.equipment.slots || {}).filter(Boolean).map(item => item.id));
        const inventory = (state.equipment.inventory || []).filter(item => item && !equippedIds.has(item.id));
        if (!inventory.length) {
          els.gearInventory.innerHTML = '<p class="muted-text">No spare gear. Spin to find equipment drops.</p>';
        } else {
          els.gearInventory.innerHTML = inventory.map(item => `
            <div class="gear-item" data-gear-id="${item.id}">
              <div class="gear-slot__meta">
                <span class="rarity-tag">${item.rarity}</span>
                <span class="hud-label">Lv ${item.level || 1}</span>
              </div>
              <p class="gear-slot__name">${item.name}</p>
              <p class="gear-slot__bonus">${item.desc || ''}</p>
              <div class="actions">
                <button type="button" class="ghost-btn secondary" data-equip-id="${item.id}">Equip</button>
                <button type="button" class="ghost-btn tertiary" data-upgrade-gear="${item.id}">Upgrade (VIP)</button>
              </div>
            </div>
          `).join('');
        }
        if (els.gearSummary) {
          const equipped = Object.values(state.equipment.slots || {}).filter(Boolean).length;
          els.gearSummary.textContent = `${equipped}/${unlocked} equipped`;
        }
        if (els.gearCap) {
          els.gearCap.textContent = `${unlocked} slots`;
        }
      };

      const renderCards = () => {
        if (!els.cardSlots || !els.cardCollection) return;
        const maxSlots = Math.max(1, state.cards.slots || 1);
        const deck = Array.isArray(state.cards.deck) ? state.cards.deck : [];
        const cards = Array.isArray(state.cards.collection) ? state.cards.collection : [];
        const slotHtml = Array.from({ length: maxSlots }).map((_, idx) => {
          const cardId = deck[idx];
          const card = cards.find(c => c && c.id === cardId);
          const body = card
            ? `<p class="gear-slot__name">${card.name}</p><p class="card-slot__effect">${card.effect || card.desc || ''}</p><div class="actions"><button type="button" class="ghost-btn secondary" data-unequip-card="${idx}">Remove</button><button type="button" class="ghost-btn tertiary" data-upgrade-card="${card.id}">Upgrade (VIP)</button></div>`
            : '<p class="gear-slot__bonus">Choose a card from your collection.</p>';
          return `
            <div class="card-slot" data-card-slot="${idx}">
              <div class="card-slot__meta">
                <strong class="card-slot__name">Slot ${idx + 1}</strong>
                ${card ? `<span class="rarity-tag">${card.tier}  Lv ${card.level || 1}</span>` : ''}
              </div>
              ${body}
            </div>
          `;
        }).join('');
        const lockedSlots = Array.from({ length: Math.max(0, 5 - maxSlots) }).map((_, idx) => `<div class="card-slot locked"><p class="muted-text">Locked slot ${maxSlots + idx + 1}</p></div>`).join('');
        els.cardSlots.innerHTML = slotHtml + lockedSlots;
        if (!cards.length) {
          els.cardCollection.innerHTML = '<p class="muted-text">No cards yet. Spin to collect VIP cards.</p>';
        } else {
          const equippedSet = new Set(deck.filter(Boolean));
          els.cardCollection.innerHTML = cards.map(card => `
            <div class="card-item" data-card-id="${card.id}">
              <div class="card-slot__meta">
                <span class="rarity-tag">${card.tier}</span>
                <span class="hud-label">Lv ${card.level || 1}</span>
              </div>
              <div class="card-slot__meta">
                <img src="${card.icon || DROP_ITEM_ICONS.card}" alt="${card.name}">
                <p class="gear-slot__name">${card.name}</p>
              </div>
              <p class="card-slot__effect">${card.effect || card.desc || ''}</p>
              <div class="actions">
                <button type="button" class="ghost-btn secondary" data-equip-card="${card.id}" ${equippedSet.has(card.id) ? 'disabled' : ''}>Add to deck</button>
                <button type="button" class="ghost-btn tertiary" data-upgrade-card="${card.id}">Upgrade (VIP)</button>
              </div>
            </div>
          `).join('');
        }
        if (els.cardSummary) {
          const active = deck.filter(Boolean).length;
          els.cardSummary.textContent = `Deck ${active}/${maxSlots}`;
        }
        if (els.cardCap) {
          els.cardCap.textContent = `${maxSlots} slots`;
        }
      };

      const toggleDropPanel = (force, mode = 'inventory') => {
        const panel = mode === 'overlay' ? els.dropPanelOverlay : els.dropPanel;
        const scrim = mode === 'overlay' ? els.dropOverlay : null;
        if (!panel) return;
        const willShow = typeof force === 'boolean' ? force : panel.hidden;
        if (willShow) renderDropPanel(panel);
        panel.hidden = !willShow;
        if (scrim) {
          scrim.hidden = !willShow;
          scrim.setAttribute('aria-hidden', willShow ? 'false' : 'true');
        }
        if (willShow) {
          panel.focus?.({ preventScroll: false });
        } else if (mode === 'overlay') {
          els.dropRatesPlayBtn?.focus?.();
        } else {
          (els.dropRatesBtn || els.dropRatesPlayBtn)?.focus?.();
        }
      };

      const renderSkillButton = () => {
        if (!els.dropSkillBtn) return;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        const skill = state.skills.dropRate;
        els.dropSkillBtn.hidden = true;
        if (!unlocked) return;
        const now = Date.now();
        const busy = state.busy || !state.gameReady;
        let label = 'Drop boost';
        if (skill.active && skill.expiresAt > now) {
          label = `Drop boost active (${formatTime(skill.expiresAt - now)})`;
          els.dropSkillBtn.dataset.state = 'active';
          els.dropSkillBtn.disabled = busy;
        } else if (skill.cooldownUntil && skill.cooldownUntil > now) {
          label = `Cooldown ${formatTime(skill.cooldownUntil - now)}`;
          els.dropSkillBtn.dataset.state = 'cooldown';
          els.dropSkillBtn.disabled = true;
        } else {
          els.dropSkillBtn.dataset.state = 'ready';
          els.dropSkillBtn.disabled = busy;
          const boost = Math.round(((state.skills.dropRate?.spec?.multiplier || 1) - 1) * 100);
          if (boost > 0) label = `Drop boost +${boost}%`;
        }
        els.dropSkillBtn.textContent = label;
      };

      const SKILL_SLOTS = [
        { key: 'drop', icon: '', requires: 'dropBoostUnlock', action: () => activateDropSkill() },
        { key: 'payout', icon: '', requires: null, action: () => activatePayoutSkill() },
        { key: 'luckyLock', icon: '', requires: null, action: () => activateLuckyLock() },
        { key: 'jackpotSurge', icon: '', requires: null, action: () => activateJackpotSurge() },
        { key: 'bonusStorm', icon: '', requires: null, action: () => activateBonusStorm() }
      ];
      const renderSkillStrip = () => {
        if (!els.skillStrip) return;
        const slots = SKILL_SLOTS.map(slot => {
          const unlocked = slot.requires ? (getEffectiveUpgradeLevel(slot.requires) > 0) : true;
          let stateAttr = unlocked ? 'ready' : 'locked';
          if (slot.key === 'drop' && unlocked) {
            const now = Date.now();
            const skill = state.skills.dropRate;
            if (skill.active && skill.expiresAt > now) stateAttr = 'active';
            else if (skill.cooldownUntil && skill.cooldownUntil > now) stateAttr = 'cooldown';
          }
          let timerText = '';
          const now = Date.now();
          if (slot.key === 'drop' && unlocked) {
            const skill = state.skills.dropRate;
            if (skill.active && skill.expiresAt > now) timerText = formatTime(skill.expiresAt - now);
            else if (skill.cooldownUntil && skill.cooldownUntil > now) timerText = `CD ${formatTime(skill.cooldownUntil - now)}`;
          }
          if (slot.key === 'payout' && unlocked) {
            const skill = state.skills.payout;
            if (skill.activeUntil > now) timerText = formatTime(skill.activeUntil - now);
            else if (skill.cooldownUntil > now) timerText = `CD ${formatTime(skill.cooldownUntil - now)}`;
          }
          if (slot.key === 'luckyLock' && unlocked) {
            const skill = state.skills.luckyLock;
            if (skill?.cooldownUntil > now) timerText = `CD ${formatTime(skill.cooldownUntil - now)}`;
            else if (skill?.lockedFor > 0) timerText = `${skill.lockedFor} spins`;
          }
          if (slot.key === 'jackpotSurge' && unlocked) {
            const skill = state.skills.jackpotSurge;
            if (skill?.activeUntil > now) timerText = formatTime(skill.activeUntil - now);
            else if (skill?.cooldownUntil > now) timerText = `CD ${formatTime(skill.cooldownUntil - now)}`;
          }
          if (slot.key === 'bonusStorm' && unlocked) {
            const skill = state.skills.bonusStorm;
            if (skill?.cooldownUntil > now) timerText = `CD ${formatTime(skill.cooldownUntil - now)}`;
          }
          const disabled = state.busy || (state.autoSpin?.active && slot.key !== 'auto');
          const icon = unlocked ? slot.icon : '';
          return `
            <button type="button" class="skill-pill" data-skill="${slot.key}" data-state="${stateAttr}" data-requires="${slot.requires || ''}" ${disabled ? 'disabled' : ''}>
              <span class="skill-icon" aria-hidden="true">${icon}</span>
              ${timerText ? `<span class="skill-timer">${timerText}</span>` : ''}
            </button>
          `;
        }).join('');
        els.skillStrip.innerHTML = slots;
      };

      const updateSkillSpec = () => {
        const effect = Math.max(0, state.upgrades.dropRateEffect || 0);
        const duration = Math.max(0, state.upgrades.dropRateDuration || 0);
        const baseBoost = state.drop.constants?.boostScale || 0.05;
        const durationMs = 60000 * (1 + duration);
        const cooldownMs = durationMs * 2;
        const multiplier = 1 + baseBoost * (1 + effect);
        state.skills.dropRate.spec = { durationMs, cooldownMs, multiplier };
        renderSkillButton();
      };

      const renderPayoutSkill = () => {
        if (!els.payoutSkillBtn) return;
        const now = Date.now();
        const skill = state.skills.payout;
        const active = skill.activeUntil > now;
        const cooling = skill.cooldownUntil > now;
        const busy = state.busy || !state.gameReady;
        let label = 'Payout +';
        if (active) {
          label = `Payout ${Math.round((skill.multiplier - 1) * 100)}% (${formatTime(skill.activeUntil - now)})`;
          els.payoutSkillBtn.dataset.state = 'active';
          els.payoutSkillBtn.disabled = busy;
        } else if (cooling) {
          label = `Cooldown ${formatTime(skill.cooldownUntil - now)}`;
          els.payoutSkillBtn.dataset.state = 'cooldown';
          els.payoutSkillBtn.disabled = true;
        } else {
          els.payoutSkillBtn.dataset.state = 'ready';
          els.payoutSkillBtn.disabled = busy;
        }
        els.payoutSkillBtn.textContent = label;
      };

      const tickSkills = () => {
        isDropSkillActive();
        renderSkillButton();
        renderSkillStrip();
        renderBonusSummary();
      };

      let skillTimer = null;
      const startSkillTicker = () => {
        if (skillTimer) return;
        skillTimer = setInterval(tickSkills, 500);
      };
      const stopSkillTicker = () => {
        if (skillTimer) {
          clearInterval(skillTimer);
          skillTimer = null;
        }
      };

      function applyDailyState(dailyPayload = {}, rewardOverride = null) {
        const current = state.daily || {};
        const reward = rewardOverride || dailyPayload.todayReward || current.todayReward || null;
        const normalizedReward = reward
          ? { ...reward, drops: Array.isArray(reward.drops) ? reward.drops.map(normalizeDrop) : [] }
          : null;
        const ready = dailyPayload.ready !== undefined
          ? Boolean(dailyPayload.ready)
          : (!dailyPayload.claimedToday && (current.ready ?? true));
        state.daily = {
          streak: Number.isFinite(dailyPayload.streak) ? dailyPayload.streak : (current.streak || 1),
          claimedToday: Boolean(dailyPayload.claimedToday ?? current.claimedToday),
          ready,
          lastClaimMs: Number.isFinite(dailyPayload.lastClaimMs) ? Number(dailyPayload.lastClaimMs) : (current.lastClaimMs || 0),
          nextResetAt: Number.isFinite(dailyPayload.nextResetAt) ? Number(dailyPayload.nextResetAt) : (current.nextResetAt || 0),
          todayReward: normalizedReward
        };
        renderDaily();
      }

      function renderDaily() {
        if (!els.dailyStatus) return;
        const daily = state.daily || {};
        const reward = daily.todayReward;
        const ready = !daily.claimedToday && (daily.ready !== false);
        els.dailyStatus.textContent = ready ? 'Ready to claim' : 'Claimed';
        els.dailyStatus.dataset.state = ready ? 'ok' : 'muted';
        if (els.dailyStreak) {
          const day = Math.max(1, Math.floor(daily.streak || 1));
          els.dailyStreak.textContent = `Day ${day} of ${DAILY_LENGTH}`;
        }
        if (els.dailyRewardMain) {
          const parts = [];
          if (reward?.vipMarks) parts.push(`${reward.vipMarks} VIP`);
          if (reward?.credits) parts.push(formatMoney(reward.credits));
          els.dailyRewardMain.textContent = parts.join('  ') || 'Come back daily for prizes.';
        }
        if (els.dailyItems) {
          const drops = reward?.drops || [];
          if (!drops.length) {
            els.dailyItems.innerHTML = '<span class="muted-text">VIP marks and credits await.</span>';
          } else {
            els.dailyItems.innerHTML = drops.map(drop => {
              const info = normalizeDrop(drop);
              return `<span class="daily-item"><img src="${info.icon}" alt="${info.name}">${info.name} ${info.amount}</span>`;
            }).join('');
          }
        }
        if (els.dailyNextReset) {
          const nextReset = daily.nextResetAt ? new Date(daily.nextResetAt).toLocaleTimeString() : 'midnight';
          els.dailyNextReset.textContent = `Resets at ${nextReset}`;
        }
        if (els.dailyClaimBtn) {
          const disabled = !ready || state.busy || !state.gameReady || (!state.auth.token && !state.offlineMode);
          els.dailyClaimBtn.disabled = disabled;
        }
      }

      function renderBonusSummary() {
        if (!els.bonusList) return;
        const entries = [];
        const winMult = getDropMultiplier(true);
        const lossMult = getDropMultiplier(false);
        entries.push({
          label: 'Drop boost',
          value: `${winMult.total.toFixed(2)} / ${lossMult.total.toFixed(2)}`,
          note: 'Win / loss multiplier (bet, skill, upgrade, level)'
        });
        const equipStats = computeEquipmentStats();
        if (equipStats.coinPct) {
          entries.push({
            label: 'Coin bonus',
            value: `+${equipStats.coinPct.toFixed(1)}%`,
            note: 'From equipped gear and cards'
          });
        }
        if (equipStats.dropPct) {
          entries.push({
            label: 'Drop bonus',
            value: `+${equipStats.dropPct.toFixed(1)}%`,
            note: 'Gear/card bonuses applied to drop rates'
          });
        }
        if (equipStats.idlePct) {
          entries.push({
            label: 'Idle speed',
            value: `+${equipStats.idlePct.toFixed(1)}%`,
            note: 'Passive earnings tick faster'
          });
        }
        const idle = Math.max(0, state.upgrades.idle || 0);
        entries.push({
          label: 'Idle income',
          value: idle ? `+${idle}/s` : 'Locked',
          note: idle ? 'Earned passively while away' : 'Upgrade Idle Coins to start earning'
        });
        const maxBetMult = (state.maxBet || DEFAULT_MAX_BET) / DEFAULT_MAX_BET;
        entries.push({
          label: 'Max bet',
          value: `${maxBetMult.toFixed(1)}`,
          note: `Cap ${formatMoney(state.maxBet || DEFAULT_MAX_BET)}`
        });
        const rows = state.currentRows || state.machine?.rows || 3;
        const reels = state.currentReels || state.machine?.reels || 3;
        entries.push({
          label: 'Layout',
          value: `${rows} rows  ${reels} reels`,
          note: `Line tier ${state.currentLineTier ?? 0}`
        });
        const skill = state.skills.dropRate?.spec;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        if (unlocked || skill) {
          const durationMin = skill ? Math.max(1, Math.round((skill.durationMs || 0) / 60000)) : 1;
          entries.push({
            label: 'Drop skill',
            value: isDropSkillActive() ? 'Boost active' : 'Ready',
            note: `${(skill?.multiplier || 1).toFixed(2)} for ${durationMin}m`
          });
        }
        const html = entries.map(entry => `
          <li class="bonus-item">
            <div>
              <p class="bonus-label">${entry.label}</p>
              ${entry.note ? `<p class="bonus-note">${entry.note}</p>` : ''}
            </div>
            <strong class="bonus-value">${entry.value}</strong>
          </li>
        `).join('');
        els.bonusList.innerHTML = html || '<li class="bonus-item"><span class="bonus-label">No bonuses yet.</span></li>';
      }

      const renderAutoSpinButton = () => {
        if (!els.autoSpinBtn) return;
        const unlocked = isAutoSpinUnlocked();
        const on = state.autoSpin.active;
        const capacity = getAutoSpinCount();
        const remaining = Math.max(0, state.autoSpin.remaining || 0) || capacity;
        const lockedIcon = '';
        const label = unlocked || on
          ? (on ? `Auto (${remaining})` : `Auto ${capacity}`)
          : lockedIcon;
        els.autoSpinBtn.textContent = label;
        els.autoSpinBtn.dataset.locked = (!unlocked && !on) ? 'true' : 'false';
        els.autoSpinBtn.disabled = !state.gameReady;
        els.autoSpinBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
        const ariaLabel = on
          ? `Auto spin running, ${remaining} spins remaining`
          : `Auto spin, queue ${capacity} spins`;
        els.autoSpinBtn.setAttribute('aria-label', unlocked || on ? ariaLabel : 'Unlock auto spin');
      };

      els.skillStrip?.addEventListener('click', (event) => {
        const btn = event.target.closest('[data-skill]');
        if (!btn) return;
        const skillKey = btn.dataset.skill;
        const def = SKILL_SLOTS.find(entry => entry.key === skillKey);
        if (!def || btn.disabled) return;
        if (btn.dataset.state === 'locked') {
          const upgradeKey = btn.dataset.requires;
          if (upgradeKey) {
            focusUpgrade(upgradeKey, 'Unlock this skill in the Upgrades tab.');
          }
          return;
        }
        def.action?.();
        renderSkillStrip();
      });

      const renderWorkerButton = () => {
        if (!els.workerBtn) return;
        els.workerBtn.textContent = state.worker.active ? 'Worker On' : 'Worker Off';
        els.workerBtn.setAttribute('aria-pressed', state.worker.active ? 'true' : 'false');
        els.workerBtn.disabled = state.busy || !state.gameReady;
      };

      const toggleWorker = () => {
        state.worker.active = !state.worker.active;
        if (state.worker.timer) {
          clearTimeout(state.worker.timer);
          state.worker.timer = null;
        }
        if (state.worker.active) {
          const tick = () => {
            if (!state.worker.active) return;
            if (!state.busy) {
              spin(true);
            }
            const interval = Math.max(500, Math.round(state.worker.intervalMs / (getLevelPerkEffects().speedMult || 1)));
            state.worker.timer = setTimeout(tick, interval);
          };
          const interval = Math.max(500, Math.round(state.worker.intervalMs / (getLevelPerkEffects().speedMult || 1)));
          state.worker.timer = setTimeout(tick, interval);
        }
        renderWorkerButton();
      };

      const activateDropSkill = () => {
        if (!state.gameReady || state.busy) return;
        const unlocked = (state.upgrades.dropBoostUnlock || 0) > 0;
        if (!unlocked) {
          showAlert('Unlock the drop boost skill first.');
          return;
        }
        const skill = state.skills.dropRate;
        const now = Date.now();
        if (!skill || (skill.cooldownUntil && skill.cooldownUntil > now) || skill.active) {
          return;
        }
        skill.active = true;
        skill.expiresAt = now + (skill.spec?.durationMs || 60000);
        skill.cooldownUntil = skill.expiresAt + (skill.spec?.cooldownMs || 120000);
        log('Drop boost activated', `Running for ${formatTime(skill.expiresAt - now)}.`);
        renderSkillButton();
        renderOpenDropPanels();
      };

      const activatePayoutSkill = () => {
        if (!state.gameReady || state.busy) return;
        const skill = state.skills.payout;
        const now = Date.now();
        if (!skill) return;
        if (skill.cooldownUntil > now || skill.activeUntil > now) return;
        skill.activeUntil = now + (skill.durationMs || 15000);
        skill.cooldownUntil = skill.activeUntil + (skill.cooldownMs || 30000);
        renderPayoutSkill();
        log('Payout boost activated', `${Math.round((skill.multiplier - 1) * 100)}% for ${formatTime(skill.activeUntil - now)}.`);
      };

      const dropSkillPayload = () => ({
        dropRate: isDropSkillActive()
      });
      const activateLuckyLock = () => {
        if (!state.gameReady || state.busy) return;
        const skill = state.skills.luckyLock = state.skills.luckyLock || { lockedFor: 0, cooldownUntil: 0 };
        const now = Date.now();
        if (skill.cooldownUntil > now) return;
        const bonus = Number(state.premium?.mods?.lockSpinsBonus || 0);
        skill.lockedFor = 5 + bonus;
        skill.cooldownUntil = now + 90000;
        log('Lucky Lock primed', 'Next spins can freeze a reel. Click a reel while spinning to lock it.');
        showAlert('Click a reel during spin to lock it for 5 spins.');
      };
      const activateJackpotSurge = () => {
        if (!state.gameReady || state.busy) return;
        const skill = state.skills.jackpotSurge = state.skills.jackpotSurge || { activeUntil: 0, cooldownUntil: 0, multiplier: 1.3 };
        const now = Date.now();
        if (skill.cooldownUntil > now || skill.activeUntil > now) return;
        skill.activeUntil = now + 15000;
        skill.cooldownUntil = skill.activeUntil + 45000;
        const mult = (skill.multiplier || 1.3) * (state.premium?.mods?.surgeMult || 1);
        skill.activeMultiplier = mult;
        log('Jackpot Surge active', `Boosted jackpots for 15s (${mult.toFixed(2)})`);
        showAlert('Jackpot Surge active: boosted jackpots for 15s!');
      };
      const activateBonusStorm = () => {
        if (!state.gameReady || state.busy) return;
        const skill = state.skills.bonusStorm = state.skills.bonusStorm || { cooldownUntil: 0 };
        const now = Date.now();
        if (skill.cooldownUntil > now) return;
        skill.cooldownUntil = now + 60000;
        const bonusCount = Math.max(0, (state.lastSpin?.winGroups || []).find(group => group.symbol === 'bonus')?.count || 0);
        const tierBoost = Number(state.premium?.mods?.bonusTier || 0);
        const effective = bonusCount + tierBoost;
        let reward = 'Minor bonus';
        if (effective >= 5) reward = 'Mythic bonus';
        else if (effective >= 4) reward = 'Epic bonus';
        else if (effective >= 3) reward = 'Rare bonus';
        log('Bonus Storm', `Triggered: ${reward} (bonus symbols: ${effective || 0})`);
        showAlert(`Bonus Storm: ${reward}! Bonus symbols counted: ${effective || 0}`);
      };
      const handlePerksClickAway = (event) => {
        if (!els.perksPopover || els.perksPopover.dataset.visible !== 'true') return;
        if (els.perksPopover.contains(event.target) || event.target === els.perksBtn) return;
        togglePerks(false);
      };
      const togglePerks = (force) => {
        if (!els.perksPopover) return;
        const next = typeof force === 'boolean'
          ? force
          : els.perksPopover.dataset.visible !== 'true';
        els.perksPopover.dataset.visible = next ? 'true' : 'false';
        if (next) {
          renderPerkPopover();
          document.addEventListener('click', handlePerksClickAway, { capture: true });
        } else {
          document.removeEventListener('click', handlePerksClickAway, { capture: true });
        }
      };
      els.perksBtn?.addEventListener('click', () => {
        togglePerks();
      });


      function ensureGrid(rows, reels) {
        if (!els.slotGrid) return;
        const currentRows = Number(els.slotGrid.dataset.rows) || 0;
        const currentReels = Number(els.slotGrid.dataset.reels) || 0;
        if (currentRows === rows && currentReels === reels && state.gridCells.size === rows * reels) {
          return;
        }
        debug('grid:rebuild', { rows, reels });
        state.gridCells.clear();
        els.slotGrid.dataset.rows = rows;
        els.slotGrid.dataset.reels = reels;
        els.slotGrid.style.setProperty('--row-count', rows);
        els.slotGrid.style.setProperty('--reel-count', reels);
        els.slotGrid.innerHTML = '';
        reelState.clear();
        for (let col = 0; col < reels; col += 1) {
          const reel = document.createElement('div');
          reel.className = 'slot-reel';
          reel.dataset.col = col.toString();
          reel.style.setProperty('--row-count', rows);
          for (let row = 0; row < rows; row += 1) {
            const cell = document.createElement('div');
            cell.className = 'slot-cell';
            cell.dataset.row = row.toString();
            cell.dataset.col = col.toString();
            const wrapper = document.createElement('div');
            wrapper.className = 'slot-cell__symbol';
            const img = document.createElement('img');
            const seedSymbol = randomSymbolInfo();
            applySymbolToImage(img, seedSymbol.key);
            wrapper.appendChild(img);
            cell.appendChild(wrapper);
            reel.appendChild(cell);
            cell.dataset.symbol = seedSymbol.key;
            state.gridCells.set(`${row}:${col}`, cell);
          }
          els.slotGrid.appendChild(reel);
          reelState.set(col, {
            reel,
            offset: 0,
            speed: 0,
            raf: null,
            spinning: false
          });
        }
      };

      const getCellHeight = () => {
        const sample = els.slotGrid?.querySelector('.slot-cell');
        return sample?.getBoundingClientRect().height || 80;
      };

      const anyReelSpinning = () => Array.from(reelState.values()).some(info => info.spinning);

      const stopReelSpin = (col, finalSymbols = null) => {
        const info = reelState.get(col);
        if (!info) return;
        info.spinning = false;
        if (info.raf) {
          cancelFrame(info.raf);
          info.raf = null;
        }
        info.offset = 0;
        info.reel.style.transform = 'translateY(0px)';
        const rows = state.currentRows || state.machine.rows;
        const symbols = Array.isArray(finalSymbols) && finalSymbols.length
          ? finalSymbols
          : Array.from({ length: rows }, () => randomSymbolInfo().key);
        info.reel.innerHTML = '';
        for (let row = 0; row < rows; row += 1) {
          const cell = document.createElement('div');
          cell.className = 'slot-cell';
          cell.dataset.row = row.toString();
          cell.dataset.col = col.toString();
          const wrapper = document.createElement('div');
          wrapper.className = 'slot-cell__symbol';
          const img = document.createElement('img');
          const key = symbols[row] || randomSymbolInfo().key;
          applySymbolToImage(img, key);
          wrapper.appendChild(img);
          cell.appendChild(wrapper);
          info.reel.appendChild(cell);
          cell.dataset.symbol = key;
          cell.dataset.state = 'settled';
          state.gridCells.set(`${row}:${col}`, cell);
        }
      };

      const spinReel = (col) => {
        const info = reelState.get(col);
        if (!info) return;
        const cellHeight = getCellHeight();
        info.offset = 0;
        info.speed = 9 + col;
        info.spinning = true;
        const step = () => {
          if (!info.spinning) return;
          info.offset += info.speed;
          if (info.offset >= cellHeight) {
            info.offset -= cellHeight;
            const last = info.reel.lastElementChild;
            if (last) info.reel.prepend(last);
          }
          info.reel.style.transform = `translateY(${info.offset}px)`;
          info.raf = requestFrame(step);
        };
        info.raf = requestFrame(step);
      };

      const updateMachineMeta = () => {
        if (!els.machineLines) return;
        const settings = getUpgradeSettings();
        const lineTier = state.currentLineTier ?? 0;
        const patterns = Array.isArray(state.machine.lines) ? state.machine.lines : [];
        const lineCount = patterns.filter(def => def.tier <= lineTier).length || patterns.length || 0;
        const rows = state.currentRows || settings.baseRows;
        const reels = state.currentReels || settings.baseReels;
        const parts = [
          `${rows}/${settings.maxRows} rows`,
          `${reels}/${settings.maxReels} reels`
        ];
        if (lineCount) parts.push(`${lineCount} lines`);
        if (Array.isArray(state.machine.activeSymbols) && state.machine.activeSymbols.length) {
          parts.push(`${state.machine.activeSymbols.length} symbols`);
        }
        els.machineLines.textContent = parts.join('  ');
        if (els.hudRows) els.hudRows.textContent = `${rows}`;
        if (els.hudReels) els.hudReels.textContent = `${reels}`;
        if (els.hudLines) els.hudLines.textContent = `${lineCount}`;
      };

      const applyMachineTheme = () => {
        if (!els.reelStage) return;
        const assets = state.machine.assets || {};
        const frame = assets.frame || null;
        const bg = (() => {
          const isPortrait = window.matchMedia?.('(orientation: portrait)')?.matches || window.innerHeight > window.innerWidth;
          return isPortrait
            ? (assets.background?.portrait || assets.background?.landscape || null)
            : (assets.background?.landscape || assets.background?.portrait || null);
        })();
        if (els.machineStage) {
          if (bg) {
            els.machineStage.style.backgroundImage = `url('${bg}')`;
            els.machineStage.style.backgroundSize = 'cover';
            els.machineStage.style.backgroundPosition = 'center';
          } else {
            els.machineStage.style.backgroundImage = '';
          }
        }
        els.reelStage.style.backgroundColor = 'rgba(2,6,23,.75)';
        if (frame) {
          els.reelStage.style.backgroundImage = `url('${frame}')`;
          els.reelStage.style.backgroundSize = 'contain';
          els.reelStage.style.backgroundRepeat = 'no-repeat';
          els.reelStage.style.backgroundPosition = 'center';
        } else {
          els.reelStage.style.backgroundImage = '';
        }
      };

      const updateGridSymbols = (grid = []) => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        ensureGrid(rows, reels);
        for (let row = 0; row < rows; row += 1) {
          const rowSymbols = grid[row] || [];
          for (let col = 0; col < reels; col += 1) {
            const symbolKey = rowSymbols[col] || randomSymbolInfo().key;
            const cell = state.gridCells.get(`${row}:${col}`);
            if (!cell) continue;
            const img = cell.querySelector('img');
            const info = applySymbolToImage(img, symbolKey);
            cell.dataset.symbol = info.key;
            if (cell.dataset.state !== 'win') {
              cell.dataset.state = 'settled';
            }
            debug('grid:update-cell', { row, col, symbol: info.key });
          }
        }
      };

      const setGridState = (mode) => {
        state.gridCells.forEach(cell => {
          cell.dataset.state = mode;
        });
      };
      const refreshIdleGridSymbols = () => {
        if (!els.slotGrid || state.busy || anyReelSpinning()) return;
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        if (!rows || !reels) return;
        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < reels; col += 1) {
            const cell = state.gridCells.get(`${row}:${col}`);
            if (!cell) continue;
            const img = cell.querySelector('img');
            const symbol = randomSymbolInfo();
            applySymbolToImage(img, symbol.key);
            cell.dataset.symbol = symbol.key;
            cell.dataset.state = 'settled';
          }
        }
      };

      const getSpinIntervalDelay = (col) => {
        const timing = state.machine.spinTiming || {};
        const overspin = Array.isArray(timing.overspin) ? timing.overspin : [];
        const step = overspin.length ? overspin[col % overspin.length] : 18;
        const base = (step || 18) * 24;
        const speedLevel = Math.max(0, state.upgrades.speed || 0);
        const factor = Math.max(90, 170 - 18 * speedLevel);
        const premiumFactor = state.premium?.mods?.speedFactor || 1;
        return Math.max(80, Math.trunc((base * factor * premiumFactor) / 100));
      };

      const getReelStopDelay = (col) => {
        const timing = state.machine.spinTiming || {};
        const brake = Number.isFinite(timing.brake) ? timing.brake : 260;
        const base = Math.trunc(brake * 1.4) + col * Math.max(160, Math.trunc(brake * 1.1));
        const speedLevel = Math.max(0, state.upgrades.speed || 0);
        const autoLevel = Math.max(0, state.upgrades.autoSpeed || 0);
        const factor = Math.max(80, 170 - 15 * (speedLevel + autoLevel));
        const premiumFactor = state.premium?.mods?.speedFactor || 1;
        return Math.max(180, Math.trunc((base * factor * premiumFactor) / 100));
      };

      const startGridSpin = () => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        ensureGrid(rows, reels);
        activeReelLocks = reels;
        pendingSpinResult = null;
        pendingWinGroups = [];
        clearLineFlash(true);
        state.gridCells.forEach(cell => {
          cell.classList.remove('slot-lock');
          cell.dataset.state = 'spinning';
        });
        setGridState('spinning');
        for (let col = 0; col < reels; col += 1) {
          spinReel(col);
        }
      };

      function flushPendingSpinResult() {
        if (pendingSpinResult && activeReelLocks === 0 && !anyReelSpinning()) {
          const data = pendingSpinResult;
          pendingSpinResult = null;
          updateLastSpin(data);
        }
      }

      const stopGridSpin = (grid) => {
        const rows = state.currentRows || state.machine.rows;
        const reels = state.currentReels || state.machine.reels;
        if (!Array.isArray(grid)) {
          reelState.forEach((_, col) => stopReelSpin(col, null));
          state.gridCells.forEach(cell => {
            if (cell.dataset.state === 'spinning') cell.dataset.state = 'settled';
          });
          activeReelLocks = 0;
          flushPendingSpinResult();
          notifyReelsSettled();
          return;
        }
        activeReelLocks = reels;
        for (let col = 0; col < reels; col += 1) {
          const columnSymbols = [];
          for (let row = 0; row < rows; row += 1) {
            columnSymbols[row] = grid[row]?.[col];
          }
          const delay = getReelStopDelay(col) + Math.random() * 120;
          setTimeout(() => {
            stopReelSpin(col, columnSymbols);
            activeReelLocks = Math.max(0, activeReelLocks - 1);
            flushPendingSpinResult();
            notifyReelsSettled();
          }, delay);
        }
      };

      const highlightWins = (groups = []) => {
        state.gridCells.forEach(cell => {
          if (cell.dataset.state === 'spinning') return;
          cell.dataset.state = 'settled';
        });
        if (!groups.length) return;
        groups.forEach(group => {
          if (group.symbol === 'bonus') {
            state.gridCells.forEach(cell => {
              if (cell.dataset.symbol === 'bonus') cell.dataset.state = 'win';
            });
            return;
          }
          if (!Array.isArray(group.pattern) || !Array.isArray(group.indexes)) return;
          const rows = state.currentRows || state.machine.rows;
          group.indexes.forEach(index => {
            const row = Math.max(0, Math.min(group.pattern[index] ?? 0, rows - 1));
            const cell = state.gridCells.get(`${row}:${index}`);
            if (cell) cell.dataset.state = 'win';
          });
        });
      };

      const evaluateClientOutcome = (grid = [], bet = 1) => {
        const rows = grid.length;
        const reels = grid[0]?.length || 0;
        const patterns = (state.machine.lines || []).filter(def => (def.tier ?? 0) <= (state.currentLineTier ?? 0));
        const groups = [];
        let payout = 0;
        patterns.forEach(def => {
          const pattern = def.pattern || [];
          let base = null;
          const indexes = [];
          for (let col = 0; col < Math.min(pattern.length, reels); col += 1) {
            const row = Math.max(0, Math.min(rows - 1, pattern[col]));
            const symbol = grid[row]?.[col];
            if (col === 0) {
              base = symbol === 'wild' ? null : symbol;
              indexes.push(col);
              continue;
            }
            if (symbol === base || symbol === 'wild' || base === null) {
              if (base === null && symbol !== 'wild') base = symbol;
              indexes.push(col);
            } else {
              break;
            }
          }
          const count = indexes.length;
          const key = base || 'wild';
          if (count >= 3) {
            const pay = (state.machine.payouts?.[key] || 1) * Math.max(1, count - 2) * bet;
            payout += pay;
            groups.push({ symbol: key, count, indexes, pattern, payout: pay });
          }
        });
        const equip = computeEquipmentStats();
        const coinMult = 1 + Math.max(0, equip.coinPct || 0) / 100;
        return { payout: payout * coinMult, groups, coinMult };
      };

      const runClientSpin = (bet, overrides = {}) => {
        const rows = (overrides.rows ?? state.currentRows) || state.machine.rows;
        const reels = (overrides.reels ?? state.currentReels) || state.machine.reels;
        ensureGrid(rows, reels);
        const spinOnce = () => {
          const grid = Array.from({ length: rows }, () => Array(reels).fill(''));
          for (let row = 0; row < rows; row += 1) {
            for (let col = 0; col < reels; col += 1) {
              const symbol = randomSymbolInfo();
              grid[row][col] = symbol.key;
            }
          }
          const { payout, groups } = evaluateClientOutcome(grid, bet);
          return { grid, payout, groups };
        };
        let result = spinOnce();
        let retriggered = false;
        const base = 0.05 * Math.max(0, state.upgrades.retrigger || 0);
        const bonus = 0.05 * Math.max(0, state.upgrades.retriggerQuality || 0);
        const retriggerChance = Math.min(0.95, base + bonus);
        if (result.payout <= 0 && retriggerChance > 0 && Math.random() < retriggerChance) {
          retriggered = true;
          result = spinOnce();
        }
        return {
          grid: result.grid,
          winAmount: result.payout,
          winGroups: result.groups,
          retriggered,
          outcome: result.payout > 0 ? 'Win' : 'No win',
          timestamp: new Date().toISOString()
        };
      };

      function renderPaytable() {
        if (!els.paytable) return;
        if (!state.symbolMap.size) {
          state.symbolMap = cloneSymbolMap(DEFAULT_SYMBOL_MAP);
        }
        const activeSymbols = computeActiveSymbols(getEffectiveUpgrades());
        const activeSet = new Set(activeSymbols || []);
        const entries = Array.from(state.symbolMap.values());
        els.paytable.innerHTML = entries.map(entry => {
          const payout = state.machine.payouts[entry.key] || 0;
          const tiers = [1, 2, 3].map(mult => `${mult + 2} ${payout ? payout * mult : 0} bet`).join('  ');
          const asset = entry.asset || getPlaceholderAsset();
          if (!entry.asset || asset === getPlaceholderAsset()) {
            debug('paytable:placeholder', { symbol: entry.key });
          }
          const isActive = activeSet.has(entry.key);
          return `
            <li data-active="${isActive ? 'true' : 'false'}">
              <div class="paytable-symbol">
                <img src="${asset}" alt="${entry.label}" data-symbol="${entry.key}" loading="lazy">
                ${entry.label}
              </div>
              <div class="paytable-meta">${tiers}</div>
              <span class="paytable-status">${isActive ? 'Active' : 'Inactive'}</span>
            </li>
          `;
        }).join('');
        els.paytable.querySelectorAll('.paytable-symbol img').forEach(img => {
          attachImageDebugging(img, img.dataset.symbol);
        });
        debug('paytable:render', { symbols: entries.length });
      }

      function setSymbolMap(symbols = [], reason = 'update') {
        const list = Array.isArray(symbols) ? symbols : [];
        state.symbolMap = buildSymbolMap(list, state.symbolMap || DEFAULT_SYMBOL_MAP, getPlaceholderAsset());
        if (list.length) {
          state.machine.symbols = list.map(entry => ({ ...entry }));
        } else if (!state.machine.symbols || !state.machine.symbols.length) {
          state.machine.symbols = Array.from(state.symbolMap.values()).map(entry => ({
            key: entry.key,
            label: entry.label,
            asset: entry.asset
          }));
        }
        debug('symbols:set', { reason, count: state.symbolMap.size });
        auditSymbolAssets();
        rebuildSymbolWeights();
        renderPaytable();
      }
      function applyUpgradeState(incoming = getMachineUpgrades(state.machine.id)) {
        const currentLocal = localUpgradeBucket();
        const baseUpgrades = getMachineUpgrades(state.machine.id);
        const source = incoming || baseUpgrades;
        const normalizedBase = {};
        if (state.upgradeCatalog.length) {
          state.upgradeCatalog.forEach(def => {
            const next = Number.isFinite(source?.[def.key])
              ? source[def.key]
              : Number(baseUpgrades?.[def.key]) || 0;
            const max = getUpgradeMaxLevel(def.key);
            normalizedBase[def.key] = Math.min(Math.max(0, Math.floor(next)), max);
          });
        } else {
          Object.assign(normalizedBase, baseUpgrades, source);
        }
        const effective = { ...normalizedBase };
        Object.entries(currentLocal || {}).forEach(([key, val]) => {
          const max = getUpgradeMaxLevel(key);
          const appended = (effective[key] || 0) + Math.max(0, Math.floor(val));
          effective[key] = Math.min(max, appended);
        });
        Object.entries(state.pendingUpgrades || {}).forEach(([key, val]) => {
          const appended = (effective[key] || 0) + val;
          const max = getUpgradeMaxLevel(key);
          effective[key] = Math.min(max, appended);
        });
        state.upgrades = effective;
        ensureMachineProgress(state.machine.id).upgrades = { ...normalizedBase };
        const settings = getUpgradeSettings();
        const rows = Math.min(
          settings.maxRows,
          (settings.baseRows || 3) + (effective.rows || 0)
        );
        const reels = Math.min(
          settings.maxReels,
          (settings.baseReels || 3) + (effective.reels || 0)
        );
        const maxLineTier = state.machine.lineTier || (state.machine.lines?.[state.machine.lines.length - 1]?.tier ?? 3);
        const lineTier = Math.min(maxLineTier, effective.lines || 0);
        state.machine.lines = buildLinePatterns(rows, reels);
        state.currentRows = rows;
        state.currentReels = reels;
        state.currentLineTier = lineTier;
        state.machine.rows = rows;
        state.machine.reels = reels;
        state.machine.currentRows = rows;
        state.machine.currentReels = reels;
        state.machine.currentLineTier = lineTier;
        state.machine.activeSymbols = computeActiveSymbols(effective);
        const betMult = Math.max(0, effective.betMultiplier || 0);
        const baseMax = resolveMaxBet(root?.dataset?.maxBet || DEFAULT_MAX_BET);
        const premiumCap = state.premium?.mods?.betCapMult || 1;
        state.maxBet = resolveMaxBet(baseMax) * Math.max(1, 10 ** betMult) * premiumCap;
        els.maxBet.textContent = formatMoney(state.maxBet);
        syncBetSteps();
        rebuildSymbolWeights();
        ensureGrid(rows, reels);
        refreshIdleGridSymbols();
        renderUpgrades();
        updateMachineMeta();
        updateSkillSpec();
        renderSkillButton();
        renderSkillStrip();
        renderBonusSummary();
        renderAutoSpinButton();
        renderPaytable();
        startIdleTicker();
        logAction('upgrade:state', { rows, reels, lineTier, betMult, maxBet: state.maxBet, upgrades: { ...state.upgrades } });
      }

      const syncMachineDefinition = (machine = {}) => {
        if (!machine || typeof machine !== 'object') return;
        state.machine.id = machine.id || state.machine.id;
        state.machine.name = machine.name || state.machine.name;
        state.machine.lineTier = Number(machine.lineTier) || state.machine.lineTier;
        state.machine.rows = Number(machine.rows) || state.machine.rows;
        state.machine.reels = Number(machine.reels) || state.machine.reels;
        state.machine.baseSymbolCount = Number(machine.baseSymbolCount) || state.machine.baseSymbolCount;
        if (Array.isArray(machine.lines)) state.machine.lines = machine.lines;
        if (machine.payouts) state.machine.payouts = machine.payouts;
        if (machine.assets) state.machine.assets = { ...state.machine.assets, ...machine.assets };
        if (Array.isArray(machine.activeSymbols)) state.machine.activeSymbols = machine.activeSymbols.slice();
        if (Array.isArray(machine.symbols)) {
          state.machine.symbols = machine.symbols.map(entry => ({ ...entry }));
        }
        if (machine.spinTiming) {
          state.machine.spinTiming = { ...machine.spinTiming };
        }
        const baseRows = Number(machine.baseRows ?? machine.upgrades?.baseRows ?? state.machine.upgradeSettings?.baseRows ?? state.machine.rows);
        const maxRows = Number(machine.maxRows ?? machine.upgrades?.maxRows ?? state.machine.upgradeSettings?.maxRows ?? state.machine.rows);
        const baseReels = Number(machine.baseReels ?? machine.upgrades?.baseReels ?? state.machine.upgradeSettings?.baseReels ?? state.machine.reels);
        const maxReels = Number(machine.maxReels ?? machine.upgrades?.maxReels ?? state.machine.upgradeSettings?.maxReels ?? state.machine.reels);
        const upgradeCosts = machine.upgrades?.costs
          || machine.upgradeSettings?.costs
          || machine.upgradeCosts
          || state.machine.upgradeSettings?.costs
          || {};
        state.machine.upgradeSettings = {
          baseRows,
          maxRows,
          baseReels,
          maxReels,
          costs: upgradeCosts
        };
        state.machine.rows = baseRows;
        state.machine.reels = baseReels;
        state.currentRows = baseRows;
        state.currentReels = baseReels;
        setSymbolMap(Array.isArray(machine.symbols) ? machine.symbols : [], 'syncMachineDefinition');
        applyUpgradeState();
      };

      const machineConfigUrl = (machineId) => `${MACHINE_CONFIG_DIR}/${machineId}.json`;

      const fetchMachineConfig = async (machineId, allowFallback = false) => {
        if (!machineId) return null;
        if (machineCache.has(machineId)) return machineCache.get(machineId);
        const isFile = window.location.protocol === 'file:';
        const useOffline = state.offlineMode || isFile;
        if (useOffline && OFFLINE_DATA.machines[machineId]) {
          const data = OFFLINE_DATA.machines[machineId];
          machineCache.set(machineId, data);
          return data;
        }
        if (useOffline) return null;
        const url = machineConfigUrl(machineId);
        try {
          const res = await fetch(url, { cache: 'no-cache' });
          if (res.ok) {
            const data = await res.json();
            machineCache.set(machineId, data);
            return data;
          }
        } catch (error) {
          debugError('machine-config', error, { machineId, url });
        }
        if (OFFLINE_DATA.machines[machineId]) {
          const data = OFFLINE_DATA.machines[machineId];
          machineCache.set(machineId, data);
          return data;
        }
        if (allowFallback && MACHINE_CONFIG_URL) {
          try {
            const res = await fetch(MACHINE_CONFIG_URL, { cache: 'no-cache' });
            if (res.ok) {
              const data = await res.json();
              machineCache.set(machineId, data);
              return data;
            }
          } catch (error) {
            debugError('machine-config:fallback', error, { machineId });
          }
        }
        return null;
      };

      const getMachineCost = (id, index) => {
        const cfg = machineCache.get(id);
        if (cfg?.unlockCost) return cfg.unlockCost;
        if (Number.isFinite(cfg?.cost)) return cfg.cost;
        if (index <= 0) return 0;
        return 25000 * index;
      };
      const unlockMachine = (id) => {
        const prevId = previousMachineId(id);
        if (!meetsMachineLevelRequirement(id)) {
          const prevName = prevId ? (machineCache.get(prevId)?.name || prevId) : 'previous machine';
          showAlert(`Reach Lv ${MACHINE_UNLOCK_LEVEL} on ${prevName} to unlock this machine.`);
          return false;
        }
        const idx = machineIndex(id);
        const prog = ensureMachineProgress(id);
        if (prog.unlocked) return true;
        const cost = getMachineCost(id, idx);
        if (!spendMachineBalance(cost)) {
          showAlert(`Need ${formatMoney(cost)} to unlock this machine.`);
          return false;
        }
        prog.unlocked = true;
        markDirty('machine-unlock');
        log('Machine unlocked', `${id} unlocked for ${formatMoney(cost)}`);
        return true;
      };

      const ensureDropTables = async () => {
        if (dropTableCache) return dropTableCache;
        if (state.offlineMode) {
          dropTableCache = OFFLINE_DATA.dropTables || { tierWeights: state.drop.tierWeights, tables: { classic: state.drop.table } };
          return dropTableCache;
        }
        try {
          const res = await fetch(DROP_TABLE_URL, { cache: 'no-cache' });
          if (res.ok) {
            dropTableCache = await res.json();
          }
        } catch (error) {
          debugError('drop-tables', error);
        }
        if (!dropTableCache) {
          dropTableCache = { tierWeights: state.drop.tierWeights, tables: { classic: state.drop.table } };
        }
        return dropTableCache;
      };

      const syncDropTableForMachine = async (machineId = 'classic') => {
        const tables = await ensureDropTables();
        const table = tables?.tables?.[machineId] || tables?.tables?.classic || { common: [], rare: [], epic: [] };
        state.drop.tableKey = machineId || 'classic';
          state.drop.table = table;
          if (tables?.tierWeights) {
            state.drop.tierWeights = { ...state.drop.tierWeights, ...tables.tierWeights };
          }
          logLocal('drop-table', { machineId, table: Object.keys(table || {}) });
        };

      const renderMachineList = async () => {
        if (!els.machineList) return;
        const nameCache = new Map();
        const cards = await Promise.all((machineList || []).map(async id => {
          const cfg = await fetchMachineConfig(id).catch(() => null);
          if (cfg?.name) nameCache.set(id, cfg.name);
          const prog = ensureMachineProgress(id);
          const idx = machineIndex(id);
          const prevId = previousMachineId(id);
          const meetsLevel = meetsMachineLevelRequirement(id);
          logLocal('machine-progress', { id, prog });
          return {
            id,
            name: cfg?.name || id,
            tier: cfg?.tier || 'Demo',
            icon: cfg?.assets?.icon || null,
            unlocked: prog.unlocked,
            cost: getMachineCost(id, idx),
            prevId,
            meetsLevel
          };
        }));
        cards.forEach(card => {
          if (!card.prevId) return;
          const prevCard = cards.find(c => c.id === card.prevId);
          if (prevCard?.name) {
            card.prevName = prevCard.name;
          } else if (nameCache.has(card.prevId)) {
            card.prevName = nameCache.get(card.prevId);
          } else {
            card.prevName = card.prevId;
          }
        });
        logLocal('machines', cards);
        els.machineList.innerHTML = cards.map(card => `
          <button
            type="button"
            class="machine-card"
            data-machine-id="${card.id}"
            data-active="${card.id === state.machine.id ? 'true' : 'false'}"
            data-locked="${card.unlocked ? 'false' : 'true'}"
            data-lock-reason="${card.unlocked ? 'none' : (!card.meetsLevel ? 'level' : 'price')}"
            data-locked-label="${card.unlocked ? '' : (!card.meetsLevel ? `Need Lv ${MACHINE_UNLOCK_LEVEL} on ${card.prevName || 'previous machine'}` : `Unlock for ${formatMoney(card.cost || 0)}`)}"
            data-prev-name="${card.prevName || ''}"
            role="listitem"
            aria-label="${card.name}, ${card.tier}, ${
              card.id === state.machine.id
                ? 'Current'
                : (card.unlocked
                  ? 'Unlocked'
                  : (!card.meetsLevel ? `Locked, need level ${MACHINE_UNLOCK_LEVEL}` : `Unlock for ${formatMoney(card.cost || 0)}`))
            }"
          >
            ${card.icon ? `<img src="${card.icon}" alt="${card.name}" class="machine-card__icon" loading="lazy">` : '<span class="machine-card__icon" aria-hidden="true"></span>'}
            <div>
              <p class="machine-card__name">${card.name}</p>
              <p class="machine-card__meta">${card.tier}</p>
            </div>
            <p class="machine-card__cost">${
              card.unlocked
                ? 'Unlocked'
                : (!card.meetsLevel
                  ? `Needs Lv ${MACHINE_UNLOCK_LEVEL} on ${card.prevName || 'previous machine'}`
                  : `Unlock for ${formatMoney(card.cost || 0)}`)}
              <span class="machine-card__status" data-state="${
                card.id === state.machine.id
                  ? 'active'
                  : (card.unlocked
                    ? 'active'
                    : (!card.meetsLevel ? 'level' : 'price'))
              }">${
                card.id === state.machine.id
                  ? 'Current'
                  : (card.unlocked
                    ? 'Unlocked'
                    : (!card.meetsLevel ? `Lv ${MACHINE_UNLOCK_LEVEL} needed` : 'Unlockable'))
              }</span>
            </p>
          </button>
        `).join('');
        const activeCard = cards.find(card => card.id === state.machine.id);
        updateMachinePicker(activeCard);
      };

      const setActiveMachine = async (machineId, options = {}) => {
        syncCurrentBalanceToMachine();
        const targetId = machineId || state.machine.id || 'classic';
        logAction('machine:switch', { targetId, options });
        const prog = ensureMachineProgress(targetId);
        if (!prog.unlocked) {
          showAlert('Machine locked. Unlock it first.');
          return;
        }
        const cfg = await fetchMachineConfig(targetId, true);
        if (!cfg) {
          debugError('machine:set', new Error('Missing machine config'), { targetId });
          ensureGrid(state.machine.rows, state.machine.reels);
          return;
        }
        state.machine.id = cfg.id || targetId;
        machineCache.set(state.machine.id, cfg);
        syncMachineDefinition(cfg);
        setSymbolMap(cfg.symbols || DEFAULT_SYMBOLS, 'machine-switch');
        state.machine.activeSymbols = computeActiveSymbols(state.upgrades);
        ensureGrid(state.currentRows || state.machine.rows, state.currentReels || state.machine.reels);
        applyMachineTheme();
        renderPaytable();
        rebuildSymbolWeights();
        updateMachineMeta();
        renderBonusSummary();
        applyUpgradeState(getMachineUpgrades(state.machine.id));
        await syncDropTableForMachine(state.machine.id);
        renderOpenDropPanels();
        renderMachineList();
        if (els.machineName) els.machineName.textContent = state.machine.name || state.machine.id;
        if (els.machineTier) els.machineTier.textContent = cfg.tier || 'Demo';
        updateMachinePicker({ id: state.machine.id, icon: state.machine.assets?.icon, name: state.machine.name });
        const configuredMax = Number(cfg.maxBet);
        state.maxBet = resolveMaxBet(Number.isFinite(configuredMax) ? configuredMax : (root?.dataset?.maxBet || DEFAULT_MAX_BET));
        loadMachineBalance(state.machine.id);
        syncBetSteps();
        setBetValue(state.bet);
        try {
          localStorage.setItem(LOCAL_MACHINE_KEY, state.machine.id);
        } catch {
          // ignore
        }
        if (!options.silent) {
          log('Machine ready', `${state.machine.name || state.machine.id} loaded`);
          markDirty('machine-switch');
        }
      };

      const loadMachineList = async () => {
        const isFile = window.location.protocol === 'file:';
        if (state.offlineMode || isFile) {
          machineList = OFFLINE_DATA.machineList || ['classic'];
          await renderMachineList();
          const preferred = localStorage.getItem(LOCAL_MACHINE_KEY);
          const target = (machineList || []).includes(preferred)
            ? preferred
            : (machineList?.[0] || state.machine.id || 'classic');
          await setActiveMachine(target, { silent: true });
          return;
        }
        let loaded = false;
        try {
          const res = await fetch(MACHINE_LIST_URL, { cache: 'no-cache' });
          if (res.ok) {
            const ids = await res.json();
            if (Array.isArray(ids) && ids.length) {
              machineList = ids;
              loaded = true;
              await renderMachineList();
            }
          }
        } catch (error) {
          debugError('machine-list', error);
        }
        if (!loaded) {
          const fallbackList = OFFLINE_DATA.machineList;
          machineList = Array.isArray(fallbackList) && fallbackList.length ? fallbackList : ['classic'];
          await renderMachineList();
        }
        const preferred = localStorage.getItem(LOCAL_MACHINE_KEY);
        const target = (machineList || []).includes(preferred)
          ? preferred
          : (machineList?.[0] || state.machine.id || 'classic');
        await setActiveMachine(target, { silent: true });
      };

      const loadMachineConfig = async () => {
        await loadMachineList();
        await syncDropTableForMachine(state.machine.id);
        renderOpenDropPanels();
      };

      const updateMachinePicker = (card = null) => {
        if (!els.machinePicker) return;
        const label = card?.name || state.machine.name || 'Machine';
        if (els.machinePickerLabel) {
          els.machinePickerLabel.textContent = label;
        }
        if (els.machinePickerLevel) {
          const prog = ensureMachineProgress(state.machine.id);
          els.machinePickerLevel.textContent = `Lv ${prog.lvl || 0}`;
        }
        els.machinePicker.setAttribute('aria-label', `Change machine: ${label}`);
      };

      const setAuthMode = (mode = 'login') => {
        debug('auth:setMode', mode);
        const nextMode = mode === 'register' ? 'register' : 'login';
        state.authMode = nextMode;
        localStorage.setItem(AUTH_MODE_KEY, nextMode);
        if (els.authBody) {
          els.authBody.dataset.mode = nextMode;
        }
        (els.authTabs || []).forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === nextMode);
        });
        if (els.authSubmit) {
          els.authSubmit.textContent = nextMode === 'register' ? 'Create Account' : 'Sign In';
        }
        if (els.authConfirmGroup) {
          els.authConfirmGroup.hidden = nextMode !== 'register';
        }
        if (nextMode !== 'register' && els.authConfirm) {
          els.authConfirm.value = '';
        }
        showAuthAlert('');
      };

      applyPremiumMods();
      setGameVisibility(false);
      renderAutoSpinButton();
      setAuthMode(state.authMode);
      setMachineFlyout(false);
      const handleAuthEnter = (event) => {
        if (event.key === 'Enter' && !state.busy) {
          event.preventDefault();
          if (document.activeElement === els.authEmail || document.activeElement === els.authPassword || document.activeElement === els.authConfirm) {
            loginOrRegister();
          }
        }
      };

      [els.authEmail, els.authPassword, els.authConfirm].forEach(input => {
        if (input) input.addEventListener('keydown', handleAuthEnter);
      });

      const updateXpBar = () => {
        const prog = ensureMachineProgress(state.machine.id);
        const needed = xpNeeded(prog.lvl || 0);
        const pct = needed > 0 ? clamp((prog.xp || 0) / needed, 0, 1) : 0;
        if (els.machineXpFill) {
          els.machineXpFill.style.width = `${Math.round(pct * 100)}%`;
        }
      };
      const renderPerkPopover = () => {
        if (!els.perksPopover) return;
        const prog = ensureMachineProgress(state.machine.id);
        const { perks, future } = buildLevelPerks(prog.lvl || 0);
        const perkList = perks.map(perk => `
          <li class="perk-row">
            <span class="perk-check" data-active="${perk.active ? 'true' : 'false'}">${perk.active ? '&#10003;' : ''}</span>
            <span class="perk-text">${perk.label}</span>
          </li>
        `).join('');
        const lossMult = getDropMultiplier(false);
        const winMult = getDropMultiplier(true);
        const dropRates = computeDropRates(winMult.total).slice(0, 8);
        const dropList = dropRates.map(rate => `
          <li class="perk-drop-row">
            <span class="rate-item"><img class="drop-icon" src="${rate.icon}" alt="${rate.name}">${rate.name}</span>
            <strong class="drop-amount">${dropPercent(rate.chance)}</strong>
          </li>
        `).join('');
        els.perksPopover.innerHTML = `
          <div class="perks-popover__header">
            <div class="perks-tabs" role="tablist">
              <button type="button" class="perks-tab active" data-perks-tab="perks" aria-selected="true">Perks</button>
              <button type="button" class="perks-tab" data-perks-tab="drops" aria-selected="false">Drop rates</button>
            </div>
            <button type="button" class="perks-close" id="perks-close" aria-label="Close perks"></button>
          </div>
          <div class="perks-panel" data-perks-panel="perks" data-active="true">
            <h4>Level perks (Lv ${prog.lvl || 0})</h4>
            <ul class="perks-list">${perkList}</ul>
            <p class="muted-text small">${future}</p>
          </div>
          <div class="perks-panel" data-perks-panel="drops">
            <h4>Drop rates</h4>
            <p class="drop-mult">Win: ${winMult.total.toFixed(2)}  Loss: ${lossMult.total.toFixed(2)}</p>
            <ul class="perks-drop-list">${dropList || '<li class="muted-text small">Drop table not loaded yet.</li>'}</ul>
          </div>
        `;
        const tabButtons = Array.from(els.perksPopover.querySelectorAll('[data-perks-tab]'));
        const panels = Array.from(els.perksPopover.querySelectorAll('[data-perks-panel]'));
        const setTab = (target) => {
          tabButtons.forEach(btn => {
            const active = btn.dataset.perksTab === target;
            btn.classList.toggle('active', active);
            btn.setAttribute('aria-selected', active ? 'true' : 'false');
          });
          panels.forEach(panel => {
            panel.dataset.active = panel.dataset.perksPanel === target ? 'true' : 'false';
          });
        };
        tabButtons.forEach(btn => btn.addEventListener('click', () => setTab(btn.dataset.perksTab)));
        const closeBtn = els.perksPopover.querySelector('#perks-close');
        closeBtn?.addEventListener('click', () => togglePerks(false));
      };

      let hudScheduled = false;
      const updateHud = () => {
        if (hudScheduled) return;
        hudScheduled = true;
        requestFrame(() => {
          hudScheduled = false;
          const totalBalance = (state.balance || 0) + (state.pendingIdleCoins || 0);
          if (els.hudBalance) els.hudBalance.textContent = formatCompactMoney(totalBalance);
          if (els.hudBet) els.hudBet.textContent = formatCompactMoney(state.bet || 0);
          if (els.hudWin) els.hudWin.textContent = formatCompactMoney(state.lastWin || 0);
          if (els.hudVip) {
            const vipMarks = Number(state.drop?.inventory?.vipMarks || 0);
            els.hudVip.textContent = `${formatCompactNumber(vipMarks)} VIP`;
          }
          if (els.hudLevel) {
            const prog = ensureMachineProgress(state.machine.id);
            els.hudLevel.textContent = `${prog.lvl || 0}`;
          }
          updateXpBar();
          renderPerkPopover();
        });
      };
      const clearLineFlash = (reenable = false) => {
        if (state.lineFlashTimer) {
          clearTimeout(state.lineFlashTimer);
          state.lineFlashTimer = null;
        }
        state.gridCells.forEach(cell => cell.classList.remove('line-flash'));
        if (els.lineOverlay) {
          els.lineOverlay.innerHTML = '';
        }
        if (reenable && els.lineFlashBtn) {
          els.lineFlashBtn.disabled = false;
          els.lineFlashBtn.removeAttribute('aria-busy');
        }
      };
      const renderLineOverlay = (patterns = []) => {
        if (!els.lineOverlay || !els.slotGrid) return;
        const overlayRect = els.lineOverlay.getBoundingClientRect();
        const width = Math.max(1, overlayRect.width || els.slotGrid.offsetWidth || 1);
        const height = Math.max(1, overlayRect.height || els.slotGrid.offsetHeight || 1);
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        const rows = state.currentRows || state.machine.rows;
        patterns.forEach((pattern, idx) => {
          const points = [];
          (pattern.pattern || []).forEach((row, col) => {
            const r = Math.max(0, Math.min(rows - 1, row));
            const cell = state.gridCells.get(`${r}:${col}`);
            if (!cell) return;
            const rect = cell.getBoundingClientRect();
            const cx = (rect.left + rect.right) / 2 - overlayRect.left;
            const cy = (rect.top + rect.bottom) / 2 - overlayRect.top;
            points.push(`${cx},${cy}`);
          });
          if (points.length >= 2) {
            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            poly.setAttribute('points', points.join(' '));
            poly.classList.add('line-path');
            poly.style.setProperty('--line-hue', `${(idx * 53) % 360}`);
            poly.style.animationDelay = `${idx * 0.08}s`;
            svg.appendChild(poly);
          }
        });
        els.lineOverlay.innerHTML = '';
        if (svg.childElementCount) {
          els.lineOverlay.appendChild(svg);
        }
      };
      const flashActiveLines = () => {
        if (!state.gameReady) return;
        clearLineFlash();
        const patterns = (state.machine.lines || []).filter(def => (def.tier ?? 0) <= (state.currentLineTier ?? 0));
        if (!patterns.length) {
          showAlert('No active lines yet. Unlock multi-line upgrades to see more patterns.');
          return;
        }
        if (els.lineFlashBtn) {
          els.lineFlashBtn.disabled = true;
          els.lineFlashBtn.setAttribute('aria-busy', 'true');
        }
        const rows = state.currentRows || state.machine.rows;
        state.gridCells.forEach(cell => cell.classList.remove('line-flash'));
        patterns.forEach(pattern => {
          (pattern.pattern || []).forEach((row, col) => {
            const r = Math.max(0, Math.min(rows - 1, row));
            const cell = state.gridCells.get(`${r}:${col}`);
            if (cell) cell.classList.add('line-flash');
          });
        });
        renderLineOverlay(patterns);
        const duration = Math.min(3500, 800 + patterns.length * 140);
        state.lineFlashTimer = setTimeout(() => {
          clearLineFlash(true);
        }, duration);
      };
      function clearSyncedPending(snapshot = {}) {
        let changed = false;
        Object.entries(snapshot || {}).forEach(([key, value]) => {
          if (!value) return;
          const current = state.pendingUpgrades?.[key] || 0;
          const remaining = current - value;
          if (remaining > 0) {
            state.pendingUpgrades[key] = remaining;
          } else {
            delete state.pendingUpgrades[key];
          }
          changed = true;
        });
        if (changed) {
          applyUpgradeState(state.serverUpgrades);
          renderUpgrades();
        }
      }

      function stopIdleTicker() {
        if (state.idleTicker) {
          cancelFrame(state.idleTicker);
          state.idleTicker = null;
        }
        state.idleTickerActive = false;
        state.lastIdleTick = 0;
      }

      function idleStep(timestamp) {
        if (!state.idleTickerActive) return;
        if (!state.lastIdleTick) state.lastIdleTick = timestamp;
        // Payout skill expiration
        const payout = state.skills.payout;
        if (payout && payout.activeUntil && payout.activeUntil <= timestamp) {
          payout.activeUntil = 0;
          renderPayoutSkill();
        }
        const equip = computeEquipmentStats();
        const speedMult = getLevelPerkEffects().speedMult || 1;
        const rate = Math.max(0, state.upgrades.idle || 0) * (1 + Math.max(0, equip.idlePct || 0) / 100) * speedMult;
        const delta = timestamp - state.lastIdleTick;
        if (rate > 0 && delta >= 1000) {
          const seconds = Math.floor(delta / 1000);
          const gained = rate * seconds;
          state.balance += gained;
          state.pendingIdleCoins = 0;
          state.lastIdleTick += seconds * 1000;
          if (els.balance) els.balance.textContent = formatMoney(state.balance, { compact: false });
          updateHud();
        }
        state.idleTicker = requestFrame(idleStep);
      }

      function startIdleTicker() {
        stopIdleTicker();
        if (!state.gameReady || (!state.auth.token && !state.offlineMode)) return;
        if ((state.upgrades.idle || 0) <= 0) return;
        state.idleTickerActive = true;
        state.lastIdleTick = 0;
        state.idleTicker = requestFrame(idleStep);
      }

      const setBetValue = (value) => {
        syncBetSteps();
        const capped = Math.min(value || 1, state.maxBet || DEFAULT_MAX_BET);
        const safe = Math.max(1, Math.round(capped));
        const idx = getNearestBetIndex(safe);
        debug('bet:update', { requested: value, applied: safe, max: state.maxBet, idx });
        const prev = state.bet;
        state.bet = safe;
        if (els.betSlider) {
          els.betSlider.max = Math.max(0, betSteps.length - 1);
          els.betSlider.value = idx;
          els.betSlider.setAttribute('aria-valuenow', safe.toString());
          els.betSlider.setAttribute('aria-valuemax', (state.maxBet || DEFAULT_MAX_BET).toString());
        }
        if (prev !== safe) {
          markDirty('bet');
        }
        if (els.spinBtn) {
          els.spinBtn.textContent = `Spin: ${formatMoney(state.bet || 0)}`;
        }
        updateHud();
        renderOpenDropPanels();
        renderSkillButton();
        renderBonusSummary();
      };
      setBetValue(state.bet);

      const storeGuestPlayer = (value) => {
        if (value) {
          localStorage.setItem(storageKeys.player, value);
        }
      };
      const resetStoredPlayer = () => localStorage.removeItem(storageKeys.player);
      const ensureOfflinePlayerId = () => {
        const existing = getStored(storageKeys.player);
        if (existing) return existing;
        const generated = `offline-${Math.random().toString(36).slice(2, 8)}`;
        storeGuestPlayer(generated);
        return generated;
      };

      const updateAuthUI = () => {
        const loggedIn = Boolean(state.auth.token) || state.offlineMode;
        const hasServerSession = Boolean(state.auth.token);
        debug('auth:updateUI', { loggedIn, offline: state.offlineMode });
      if (els.authOverlay) {
        const forceHidden = offlineMode;
        const hidden = forceHidden || loggedIn;
        els.authOverlay.dataset.hidden = hidden ? 'true' : 'false';
        els.authOverlay.setAttribute('aria-hidden', hidden ? 'true' : 'false');
        if (hidden && els.authOverlay.contains(document.activeElement)) {
          document.activeElement.blur?.();
        }
      }
        if (loggedIn && els.accountUser) {
          const label = state.offlineMode ? OFFLINE_USER : (state.auth.username || 'Account');
          els.accountUser.textContent = label;
        }
        if (els.accountToggle) {
          els.accountToggle.disabled = !loggedIn;
        }
        if (els.logoutBtn) {
          els.logoutBtn.disabled = !hasServerSession;
        }
        if (!loggedIn) {
          toggleAccountSheet(false);
        }
        if (els.deleteBtn) {
          els.deleteBtn.disabled = !hasServerSession;
        }
        if (loggedIn) startIdleTicker();
        else {
          stopIdleTicker();
          state.pendingIdleCoins = 0;
          state.pendingUpgrades = {};
          updateHud();
        }
        if (els.debugCoinBtn) {
          const matchesDebug = hasServerSession && (state.auth.username || '').toLowerCase() === DEBUG_EMAIL;
          els.debugCoinBtn.hidden = !matchesDebug;
          els.debugCoinBtn.disabled = !matchesDebug;
        }
        if (!loggedIn && els.authPassword) {
          els.authPassword.value = '';
          if (els.authConfirm) els.authConfirm.value = '';
        }
        if (!loggedIn) {
          if (els.machineOutcome) els.machineOutcome.textContent = 'Sign in to start spinning.';
          if (els.hudWin) els.hudWin.textContent = formatCompactMoney(0);
          updateHud();
        } else if (state.offlineMode && els.machineOutcome) {
          els.machineOutcome.textContent = 'Offline demo ready. Spins stay local.';
        }
      };

      const setAuthState = ({ token, username } = {}) => {
        debug('auth:setState', { tokenPresent: Boolean(token), username });
        state.auth.token = token || null;
        state.auth.username = token ? (username || state.auth.username || null) : null;
        if (!state.auth.token) {
          resetLocalProgress();
          state.sync = { rev: 0, dirty: false, inFlight: false, lastPush: 0, debounceTimer: null, queue: [] };
          state.playerId = null;
          state.pendingIdleCoins = 0;
          stopIdleTicker();
          stopSessionSync();
          state.worker.active = false;
          if (state.worker.timer) {
            clearTimeout(state.worker.timer);
            state.worker.timer = null;
          }
          state.drop.inventory = {};
          state.drop.history = [];
          state.drop.lastDrops = [];
          state.drop.lastTimestamp = 0;
        state.daily = {
          streak: 1,
          claimedToday: false,
          ready: false,
          lastClaimMs: 0,
          nextResetAt: 0,
          todayReward: null
        };
        renderDropLog();
        renderInventory();
        renderDaily();
        renderBonusSummary();
        toggleDropPanel(false);
        updateHud();
        applyUpgradeState({});
        logLocal('session', 'Local session cleared');
      }
        if (state.auth.token) {
          clearLocalUpgradeState();
          resetAutoState();
          state.sync.rev = 0;
          state.sync.dirty = false;
          state.sync.queue = [];
          localStorage.setItem(storageKeys.token, state.auth.token);
          localStorage.setItem(storageKeys.user, state.auth.username || '');
          resetStoredPlayer();
        } else {
          localStorage.removeItem(storageKeys.token);
          localStorage.removeItem(storageKeys.user);
        }
        updateAuthUI();
        if (state.auth.token && !state.offlineMode) startSessionSync();
      };

      const clearAuth = (message) => {
        debug('auth:clear', { message });
        if (!state.auth.token) return;
        setAuthState({});
        setGameVisibility(false);
        setStatus('Sign in to start', 'error');
        if (message) {
          showAuthAlert(message);
          log('Auth', message);
        }
      };

      const syncAuthFromPayload = (payload = {}) => {
        debug('auth:syncFromPayload', payload);
        if (payload.token && payload.username) {
          setAuthState({ token: payload.token, username: payload.username });
          showAuthAlert('');
        }
      };

      const withAuth = (payload = {}) => {
        if (state.auth.token) {
          return { ...payload, token: state.auth.token };
        }
        return payload;
      };

      const request = async (path, payload = {}, options = {}) => {
        if (state.offlineMode) {
          const err = new Error('Offline demo mode: network requests skipped.');
          err.status = 503;
          throw err;
        }
        const finalPayload = options.skipAuth ? payload : withAuth(payload);
        debug('request:start', { path, payload: finalPayload, options });
        let res;
        try {
          res = await fetch(`${API_BASE}${path}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(finalPayload)
          });
        } catch (networkError) {
          const err = new Error('Network request failed.');
          err.cause = networkError;
          debugError('request:network', networkError, { path, payload: finalPayload });
          throw err;
        }
        let data = {};
        try {
          data = await res.json();
        } catch {
          data = {};
        }
        debug('request:response', { path, status: res.status, ok: res.ok, body: data });
        if (!res.ok) {
          if (res.status === 401 && !options.skipAuth) {
            clearAuth('Session expired. Please sign in again.');
          }
          const err = new Error(data.error || data.message || 'Request failed');
          err.payload = data;
          err.status = res.status;
          debugError('request:error', err, { path, payload: finalPayload });
          throw err;
        }
        return data;
      };

      const updateStats = (payload = {}) => {
        debug('updateStats', payload);
        if (typeof payload.rev === 'number') {
          state.sync.rev = Math.max(state.sync.rev || 0, payload.rev);
          state.sync.dirty = false;
          state.sync.queue = [];
        }
        if (payload.playerId) {
          state.playerId = payload.playerId;
          els.playerId.textContent = payload.playerId;
          if (state.auth.token) {
            resetStoredPlayer();
          } else {
            storeGuestPlayer(payload.playerId);
          }
        }
        if (typeof payload.balance === 'number') {
          setMachineBalance(payload.balance, state.machine.id);
        }
        if (Number(payload.idleGained) > 0) {
          log('Idle payout collected', `+${formatMoney(payload.idleGained)} credits while away.`);
          state.pendingIdleCoins = Math.max(0, (state.pendingIdleCoins || 0) - payload.idleGained);
          state.lastIdleTick = 0;
          startIdleTicker();
        }
        if (typeof payload.spins === 'number') {
          state.spinCount = payload.spins;
          els.spinCount.textContent = payload.spins;
        }
        if (payload.currentRows) state.currentRows = payload.currentRows;
        if (payload.currentReels) state.currentReels = payload.currentReels;
        if (payload.worker) state.worker = { ...state.worker, ...payload.worker };
        if (payload.machines) state.machines = { ...state.machines, ...payload.machines };
        if (payload.machine) {
          syncMachineDefinition(payload.machine);
        }
        if (payload.dropState) {
          applyDropState(payload.dropState);
        } else if (payload.inventory) {
          applyDropState({ inventory: payload.inventory });
        }
        if (payload.daily) {
          applyDailyState(payload.daily, payload.reward);
        } else if (payload.reward && state.daily) {
          applyDailyState(state.daily, payload.reward);
        }

        if (payload.upgrades) {
          ensureMachineProgress(state.machine.id).upgrades = { ...payload.upgrades };
        }
        applyUpgradeState(getMachineUpgrades(state.machine.id));
        const incomingBet = Number(payload.bet);
        const fallbackBet = Number.isFinite(state.bet)
          ? state.bet
          : Number(els.betSlider?.value);
        const desiredBet = Number.isFinite(incomingBet)
          ? incomingBet
          : (Number.isFinite(fallbackBet) ? fallbackBet : 1);
        setBetValue(desiredBet || 1);
        updateHud();
        renderBonusSummary();
        renderAutoSpinButton();
      };

      const formatWinSummary = (groups = []) => {
        if (!groups?.length) return '';
        return groups
          .slice()
          .sort((a, b) => (b.payout || 0) - (a.payout || 0))
          .map(group => {
            const info = getSymbolEntry(group.symbol);
            return `${info.label || info.key} ${group.count}`;
          })
          .join(', ');
      };

      const updateLastSpin = (lastSpin) => {
        debug('updateLastSpin', lastSpin);
        if (!lastSpin) {
          state.lastWin = 0;
          if (els.lastOutcome) els.lastOutcome.textContent = 'N/A';
          if (els.lastWin) els.lastWin.textContent = 'N/A';
          if (els.lastMult) els.lastMult.textContent = 'N/A';
          if (els.lastTime) els.lastTime.textContent = 'N/A';
          if (els.machineOutcome) els.machineOutcome.textContent = 'Awaiting spin';
          if (els.hudWin) els.hudWin.textContent = formatMoney(0);
          highlightWins([]);
          updateHud();
          return;
        }
        if (activeReelLocks > 0 || anyReelSpinning()) {
          pendingSpinResult = lastSpin;
          pendingWinGroups = lastSpin.winGroups || [];
          return;
        }
        const summary = formatWinSummary(lastSpin.winGroups) || lastSpin.outcome || 'N/A';
        if (els.lastOutcome) els.lastOutcome.textContent = summary;
        const winAmount = lastSpin.winAmount || 0;
        state.lastWin = winAmount;
        if (els.lastWin) els.lastWin.textContent = formatMoney(winAmount);
        if (els.lastMult) {
          const lines = Array.isArray(lastSpin.winGroups) ? lastSpin.winGroups.length : 0;
          els.lastMult.textContent = lines ? `${lines} line${lines === 1 ? '' : 's'}` : 'N/A';
        }
        if (winAmount > 0) {
          showWinFlyover(winAmount);
        }
        if (els.lastTime) els.lastTime.textContent = new Date(lastSpin.timestamp).toLocaleString();
        if (els.machineOutcome) {
          const note = lastSpin.retriggered ? ' (Retriggered)' : '';
          els.machineOutcome.textContent = `${lastSpin.outcome || summary}${note}`;
        }
        if (els.hudWin) els.hudWin.textContent = formatCompactMoney(winAmount);
        if (Array.isArray(lastSpin.drops) && lastSpin.drops.length) {
          recordDrops(lastSpin.drops, Date.parse(lastSpin.timestamp) || Date.now());
          showDropFlyover(lastSpin.drops);
          renderInventory();
        }
        pendingWinGroups = lastSpin.winGroups || [];
        if (activeReelLocks === 0 && !anyReelSpinning()) {
          highlightWins(pendingWinGroups);
          pendingWinGroups = [];
        }
        pendingSpinResult = null;
      };

      const hydrateSession = async (session, logMessage) => {
        debug('hydrateSession', session);
        syncAuthFromPayload(session);
        if (session.snapshot) {
          await applySnapshot(session.snapshot, 'sync');
        }
        if (session.machine) {
          syncMachineDefinition(session.machine);
        }
        if (session.upgrades) {
          applyUpgradeState(session.upgrades);
        }
        updateStats(session);
        updateLastSpin(session.lastSpin);
        setGameVisibility(true);
        setStatus('Connected to AWS Lambda', 'ok');
        if (logMessage) {
          log(logMessage, `${session.username || 'User'}  balance ${formatMoney(state.balance || session.balance)}`);
        }
        if (state.auth.token) startSessionSync();
      };

      const startOfflineDemo = async () => {
        debug('offline:start');
        state.offlineMode = true;
        state.auth.token = null;
        state.auth.username = OFFLINE_USER;
        const saved = loadOfflineSnapshot();
        logLocal('offline:start', { saved: !!saved });
        const fallbackDrop = {
          inventory: state.drop.inventory || {},
          history: state.drop.history || [],
          lastDrops: state.drop.lastDrops || [],
          lastTimestamp: state.drop.lastTimestamp || 0
        };
        const snapshot = saved || {
          rev: state.sync.rev || 0,
          balance: Math.max(state.balance || 0, OFFLINE_START_BALANCE),
          bet: Math.min(state.bet || 25, state.maxBet || DEFAULT_MAX_BET),
          maxBet: state.maxBet || DEFAULT_MAX_BET,
          spinCount: state.spinCount || 0,
          playerId: ensureOfflinePlayerId(),
          machine: {
            id: state.machine.id,
            rows: state.currentRows || state.machine.rows,
            reels: state.currentReels || state.machine.reels,
            lineTier: state.currentLineTier || state.machine.lineTier || 0,
            upgrades: { ...getMachineUpgrades(state.machine.id) },
            spinTiming: state.machine.spinTiming
          },
          drop: fallbackDrop,
          equipment: state.equipment,
          cards: state.cards,
          daily: { ...state.daily },
          worker: { ...state.worker },
          skills: { ...state.skills },
          machines: { ...state.machines },
          upgrades: { ...state.serverUpgrades },
          clientUpgrades: { ...localUpgrades },
          symbolMap: Array.from(state.symbolMap.entries() || []),
          idle: { pending: 0, lastTick: 0 }
        };
        state.sync.rev = snapshot.rev || 0;
        await applySnapshot(snapshot, 'offline');
        updateStats(snapshot);
        setGameVisibility(true);
        setStatus('Offline demo mode. No login needed', 'ok');
        updateAuthUI();
        log('Offline demo', saved ? 'Local snapshot loaded.' : 'Local session created.');
        logLocal('balance', { balance: state.balance, bet: state.bet, maxBet: state.maxBet });
        state.sync.dirty = true;
        syncSnapshot(true);
      };

      const bootstrap = async () => {
        debug('bootstrap:start');
        if (state.offlineMode) {
          debug('bootstrap:skipped', 'offline mode');
          setStatus('Offline demo mode. No login needed', 'ok');
          return;
        }
        if (!state.auth.token) {
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          debug('bootstrap:skipped', 'missing auth token');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const session = await request('/session');
          await hydrateSession(session, 'Session synced');
          startSessionSync();
        } catch (error) {
          console.error(error);
          setGameVisibility(false);
          setStatus('Offline. Check CloudWatch logs.', 'error');
          showAlert(error.message || 'Unable to reach AWS.');
          log('Connection failed', error.message);
          debugError('bootstrap', error);
        } finally {
          debug('bootstrap:end');
          setBusy(false);
        }
      };

      const startAutoSpin = () => {
        if (!isAutoSpinUnlocked()) {
          focusUpgrade('autoSpinUnlock', 'Unlock Auto Spin in the Upgrades tab.');
          return;
        }
        if (state.autoSpin.active) {
          state.autoSpin.active = false;
          state.autoSpin.remaining = 0;
          refreshControls();
          return;
        }
        if (state.busy || !state.gameReady) return;
        state.autoSpin.active = true;
        state.autoSpin.remaining = getAutoSpinCount();
        refreshControls();
        spin(true);
      };

      const spin = async (auto = false) => {
        debug('spin:click', { busy: state.busy, authed: !!state.auth.token });
        if (state.busy) return;
        if (!auto) {
          state.autoSpin.active = false;
          state.autoSpin.remaining = 0;
          renderAutoSpinButton();
        }
        collectPendingIdle();
        const baseRows = state.currentRows || state.machine.rows;
        const baseReels = state.currentReels || state.machine.reels;
        const settings = getUpgradeSettings();
        const modifiers = consumeSpinModifiers();
        const effectiveRows = clamp(baseRows, settings.baseRows || baseRows, settings.maxRows || baseRows);
        const effectiveReels = clamp(
          baseReels + (modifiers.extraReels || 0),
          settings.baseReels || baseReels,
          settings.maxReels || baseReels
        );
        const bet = clamp(state.bet || 1, 1, state.maxBet || DEFAULT_MAX_BET);
        const freeSpin = (state.pendingFreeSpins || 0) > 0;
        if (!freeSpin && machineBalance() < bet) {
          showPopup('Not enough credits to spin.');
          return;
        }
        logAction('spin:start', { bet, balance: machineBalance(), rows: effectiveRows, reels: effectiveReels });
        setBetValue(bet);
        setBusy(true);
        showAlert('');
        if (els.error) els.error.textContent = '';
        const prevLines = state.machine.lines;
        state.currentRows = effectiveRows;
        state.currentReels = effectiveReels;
        state.machine.lines = buildLinePatterns(effectiveRows, effectiveReels);
        ensureGrid(effectiveRows, effectiveReels);
        startGridSpin();
        let spinData = null;
        try {
          spinData = runClientSpin(bet, { rows: effectiveRows, reels: effectiveReels });
          const spend = freeSpin ? 0 : bet;
          if (freeSpin && state.pendingFreeSpins > 0) {
            state.pendingFreeSpins = Math.max(0, state.pendingFreeSpins - 1);
          }
          if (spend > 0 && !spendMachineBalance(spend)) {
            showPopup('Not enough credits to spin.');
            return;
          }
          state.lastWin = spinData.winAmount || 0;
          state.spinCount = (state.spinCount || 0) + 1;
          if (spinData.retriggered) {
            log('Retriggered spin', 'Free retry activated');
          }
          // Apply skill and jackpot modifiers
          const perkEffects = getLevelPerkEffects();
          let finalWin = spinData.winAmount || 0;
          const nowMs = Date.now();
          const payoutSkill = state.skills.payout;
          const payoutActive = payoutSkill.activeUntil && payoutSkill.activeUntil > nowMs;
          if (payoutActive) {
            const perkMult = perkEffects.payoutSkillMult || 1;
            finalWin = Math.round(finalWin * (payoutSkill.multiplier || 1) * perkMult);
          }
          if ((modifiers.payoutMult || 1) > 1) {
            finalWin = Math.round(finalWin * modifiers.payoutMult);
          }
          if ((state.premium?.mods?.payoutMult || 1) > 1) {
            finalWin = Math.round(finalWin * state.premium.mods.payoutMult);
          }
          const legacyCount = Object.keys(state.globalPerks || {}).length;
          if (legacyCount > 0) {
            finalWin = Math.round(finalWin * (1 + legacyCount * 0.05));
          }
          const surge = state.skills.jackpotSurge || {};
          const surgeActive = surge.activeUntil && surge.activeUntil > nowMs;
          const surgeMult = surgeActive ? (surge.activeMultiplier || surge.multiplier || 1.3) : 1;
          const jackpotMult = (state.jackpots.multiplier || 10) * (perkEffects.jackpotMult || 1) * surgeMult;
          const jackpotChance = (state.jackpots.chance || 0.01) * (surgeActive ? 2 : 1);
          if (Math.random() < jackpotChance) {
            finalWin = Math.round(finalWin * jackpotMult);
            log('Jackpot!', `${jackpotMult.toFixed(2)} payout`);
          }
          if (spinData.retriggered) {
            state.pendingFreeSpins = (state.pendingFreeSpins || 0) + 1;
          }
        if (finalWin > 0) {
          state.jackpots.hotStreak.wins += 1;
          if (state.jackpots.hotStreak.wins >= 3) {
            finalWin = Math.round(finalWin * (1 + state.jackpots.hotStreak.bonusPct));
          }
          addMachineBalance(finalWin);
        } else {
          state.jackpots.hotStreak.wins = 0;
        }
        spinData.winAmount = finalWin;

          const dropResult = rollDropsForSpin(bet, finalWin || 0);
          if (dropResult.drops?.length) {
            applyDropsToInventory(dropResult.drops, Date.now());
            showDropFlyover(dropResult.drops);
          }
          const xpGain = Math.max(1, Math.round(bet / 10));
          const leveled = addMachineXp(state.machine.id, xpGain);
          const prog = ensureMachineProgress(state.machine.id);
          if (els.balance) els.balance.textContent = formatMoney(state.balance, { compact: false });
          if (els.spinCount) els.spinCount.textContent = state.spinCount;
          updateLastSpin(spinData);
          showXpFlyover(xpGain);
          updateHud();
          renderBonusSummary();
          if (leveled) {
            log('Level up', `${state.machine.name || state.machine.id} Lv ${prog.lvl}`);
            showLevelFlyover(prog.lvl);
            renderMachineList();
            updateMachinePicker({ id: state.machine.id, name: state.machine.name });
          }
          log('Spin processed locally', `${spinData.outcome} (balance ${formatMoney(state.balance)})`);
          logAction('spin:end', { outcome: spinData.outcome, win: spinData.winAmount, balance: state.balance, xpGain });
          markDirty('spin');
        } catch (error) {
          const msg = error?.message || 'Spin failed.';
          showAlert(msg);
          debugError('spin', error || new Error(msg));
          state.autoSpin.active = false;
          state.autoSpin.remaining = 0;
        } finally {
          stopGridSpin(spinData?.grid);
          await waitForReelsToSettle();
          state.currentRows = baseRows;
          state.currentReels = baseReels;
          state.machine.lines = prevLines;
          setBusy(false);
          const shouldAuto = state.autoSpin.active && state.autoSpin.remaining > 0;
          if (shouldAuto) {
            state.autoSpin.remaining -= 1;
            renderAutoSpinButton();
            const delay = Math.max(60, Math.round(120 / (getLevelPerkEffects().speedMult || 1)));
            setTimeout(() => spin(true), delay);
          } else if ((state.pendingFreeSpins || 0) > 0) {
            renderAutoSpinButton();
            setTimeout(() => spin(true), 100);
          } else {
            state.autoSpin.active = false;
            state.autoSpin.remaining = 0;
            refreshControls();
          }
        }
      };

      const claimDaily = async () => {
        debug('daily:claim', { busy: state.busy, ready: state.daily?.ready });
        if (state.offlineMode) {
          showAlert('Daily rewards are unavailable in offline mode.');
          return;
        }
        if (!state.auth.token) {
          showAuthAlert('Sign in to claim daily rewards.');
          return;
        }
        if (state.daily?.claimedToday) {
          showAlert('Already claimed today.');
          return;
        }
        setBusy(true);
        showAlert('');
        try {
          const result = await request('/daily', { action: 'claim' });
          updateStats(result);
          if (result.reward) {
            const drops = Array.isArray(result.reward.drops) ? result.reward.drops : [];
            if (drops.length) {
              applyDropsToInventory(drops, Date.now());
            }
            const parts = [];
            if (result.reward.vipMarks) parts.push(`+${result.reward.vipMarks} VIP marks`);
            if (result.reward.credits) parts.push(`+${formatMoney(result.reward.credits)} credits`);
            drops.filter(drop => drop.type !== 'vipMarks').forEach(drop => {
              const info = normalizeDrop(drop);
              parts.push(`${info.name} ${drop.amount || 1}`);
            });
            log('Daily reward claimed', parts.join('  '));
            markDirty('daily-claim');
          }
        } catch (error) {
          const payload = error.payload || {};
          if (payload.daily) {
            applyDailyState(payload.daily, payload.reward);
          }
          showAlert(error.message || 'Unable to claim daily reward.');
          debugError('daily:claim', error, { payload });
        } finally {
          setBusy(false);
          renderDaily();
          renderBonusSummary();
        }
      };

      const loginOrRegister = async () => {
        if (state.offlineMode) {
          showAuthAlert('Offline demo mode active. No login required.');
          setGameVisibility(true);
          setStatus('Offline demo mode. No login needed', 'ok');
          updateAuthUI();
          return;
        }
        const email = (els.authEmail?.value || '').trim().toLowerCase();
        const password = els.authPassword?.value || '';
        debug('auth:submit', { mode: state.authMode, email, hasPassword: Boolean(password) });
        if (!email || !password) {
          showAuthAlert('Enter your email and password.');
          return;
        }
        if (state.authMode === 'register') {
          const confirm = (els.authConfirm?.value || '').trim();
          if (!confirm) {
            showAuthAlert('Please confirm your password.');
            return;
          }
          if (confirm !== password) {
            showAuthAlert('Passwords do not match.');
            return;
          }
        }
        showAuthAlert('');
        toggleAuthInputs(true);
        try {
          const endpoint = state.authMode === 'register' ? '/auth/register' : '/auth/login';
          const result = await request(endpoint, { username: email, password }, { skipAuth: true });
          await hydrateSession(result, state.authMode === 'register' ? 'Account created' : 'Signed in');
          showAuthAlert(state.authMode === 'register' ? 'Account created! Credits synced.' : 'Signed in successfully.');
          debug('auth:success', { endpoint });
        } catch (error) {
          if (error && error.status === 409 && state.authMode === 'register') {
            setAuthMode('login');
            showAuthAlert('Account already exists. Sign in instead.');
          } else {
            showAuthAlert(error.message || 'Unable to process request.');
          }
          log('Auth failed', error.message);
          debugError('auth', error);
        } finally {
          toggleAuthInputs(false);
        }
      };

      const logout = async () => {
        debug('auth:logout-click', { authed: !!state.auth.token });
        if (!state.auth.token) return;
        showAuthAlert('');
        if (els.logoutBtn) els.logoutBtn.disabled = true;
        try {
          await request('/auth/logout', {});
        } catch (error) {
          console.error(error);
          debugError('logout', error);
        } finally {
          if (els.logoutBtn) els.logoutBtn.disabled = false;
          setAuthState({});
          setGameVisibility(false);
          setStatus('Sign in to start', 'error');
          log('Signed out', '');
          showAuthAlert('Signed out.');
        }
      };

      const deleteAccount = async () => {
        if (!state.auth.token) return;
        const confirmed = window.confirm('Delete your account and all slot progress? This cannot be undone.');
        debug('account:delete-click', { confirmed });
        if (!confirmed) return;
        showAuthAlert('');
        if (els.deleteBtn) els.deleteBtn.disabled = true;
        try {
          await request('/auth/delete', {});
          log('Account deleted', '');
          resetLocalProgress();
          clearLocalUpgradeState();
          resetAutoState();
          setAuthState({});
          setGameVisibility(false);
          setStatus('Account deleted', 'error');
          showAuthAlert('Account deleted. You can register again anytime.');
          toggleAccountSheet(false);
        } catch (error) {
          showAuthAlert(error.message || 'Unable to delete account right now.');
          log('Delete failed', error.message);
          debugError('delete-account', error);
        } finally {
          if (els.deleteBtn) els.deleteBtn.disabled = false;
        }
      };

      const grantDebugCoins = async () => {
        if (!state.auth.token) return;
        const email = (state.auth.username || '').toLowerCase();
        if (email !== DEBUG_EMAIL) return;
        debug('debug:grantCoins', email);
        setBusy(true);
        showAlert('');
        try {
          const result = await request('/session', { token: state.auth.token, action: 'debugCoins' });
          updateStats(result);
          log('Debug', '+100k credits granted.');
        } catch (error) {
          showAlert(error.message || 'Unable to grant coins.');
          debugError('debug-coins', error);
        } finally {
          setBusy(false);
        }
      };

      hydrateLocalCollections();
      loadGearDefinitions().then(() => {
        renderGear();
        renderBonusSummary();
      });
      loadCardDefinitions().then(() => {
        renderCards();
        renderBonusSummary();
      });
      updateAuthUI();
      ensureGrid(state.machine.rows, state.machine.reels);
      updateMachineMeta();
      renderPaytable();
      loadMachineConfig().finally(() => {
        renderDaily();
        renderBonusSummary();
        renderPayoutSkill();
        renderWorkerButton();
        updateHud();
        startOfflineDemo();
      });
      const handleWindowResize = () => {
        applyMachineTheme();
        if (els.machineFlyout?.dataset.open === 'true') positionMachineFlyout();
      };
      window.addEventListener('resize', handleWindowResize);
      window.addEventListener('scroll', () => {
        if (els.machineFlyout?.dataset.open === 'true') positionMachineFlyout();
      }, { passive: true });

      const handleChipAction = (action) => {
        debug('chip:action', { action, busy: state.busy, ready: state.gameReady });
        if (state.busy || !state.gameReady) return;
        const maxCap = state.maxBet || DEFAULT_MAX_BET;
        const balance = machineBalance();
        const pctMap = {
          'pct-10': 0.10,
          'pct-25': 0.25,
          'pct-50': 0.50,
          'pct-100': 1
        };
        const pct = pctMap[action];
        if (!pct) return;
        const raw = Math.max(1, Math.round(balance * pct));
        const bet = Math.min(maxCap, raw);
        setBetValue(bet);
        logAction('bet:chip', { action, bet });
      };

      els.chipButtons.forEach(btn => {
        btn.addEventListener('click', () => handleChipAction(btn.dataset.chip));
      });

      els.dropRatesBtn?.addEventListener('click', () => {
        if (state.busy || !state.gameReady) return;
        toggleDropPanel();
      });
      els.dropRatesPlayBtn?.addEventListener('click', () => {
        if (state.busy || !state.gameReady) return;
        toggleDropPanel(undefined, 'overlay');
      });

      els.dropSkillBtn?.addEventListener('click', () => {
        activateDropSkill();
      });
      els.payoutSkillBtn?.addEventListener('click', activatePayoutSkill);
      els.workerBtn?.addEventListener('click', toggleWorker);

      els.dropCloseBtn?.addEventListener('click', () => toggleDropPanel(false));
      els.dropOverlayClose?.addEventListener('click', () => toggleDropPanel(false, 'overlay'));
      els.dropPanel?.addEventListener('click', (event) => {
        const target = event.target;
        if (target === els.dropPanel) {
          toggleDropPanel(false);
        }
      });
      els.dropOverlay?.addEventListener('click', (event) => {
        if (event.target === els.dropOverlay) {
          toggleDropPanel(false, 'overlay');
        }
      });
      els.machineList?.addEventListener('click', (event) => {
        const card = event.target.closest('[data-machine-id]');
        if (!card || state.busy) return;
        const id = card.dataset.machineId;
        if (!id) return;
        const lockReason = card.dataset.lockReason;
        if (card.dataset.locked === 'true') {
          if (lockReason === 'level') {
            const label = card.dataset.lockedLabel || `Reach Lv ${MACHINE_UNLOCK_LEVEL} on ${card.dataset.prevName || 'previous machine'} to unlock.`;
            showAlert(label);
            return;
          }
          const unlocked = unlockMachine(id);
          if (unlocked) {
            card.dataset.locked = 'false';
            renderMachineList();
            showAlert('Machine unlocked. Click again to switch.');
          }
          return;
        }
        setActiveMachine(id);
        setMachineFlyout(false);
      });
      els.machinePicker?.addEventListener('click', () => {
        toggleMachineFlyout();
      });
      document.addEventListener('click', (event) => {
        if (!els.machineFlyout) return;
        if (els.machineFlyout.contains(event.target)) return;
        setMachineFlyout(false);
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          setMachineFlyout(false);
        }
      });
      els.dailyClaimBtn?.addEventListener('click', () => {
        if (state.busy) return;
        claimDaily();
      });

      els.gearPanel?.addEventListener('click', (event) => {
        const equipBtn = event.target.closest('[data-equip-id]');
        const unequipBtn = event.target.closest('[data-unequip-slot]');
        const upgradeBtn = event.target.closest('[data-upgrade-gear]');
        if (equipBtn) {
          equipGear(equipBtn.dataset.equipId);
        } else if (unequipBtn) {
          unequipGear(unequipBtn.dataset.unequipSlot);
        } else if (upgradeBtn) {
          upgradeGear(upgradeBtn.dataset.upgradeGear);
        }
      });

      els.cardPanel?.addEventListener('click', (event) => {
        const equipBtn = event.target.closest('[data-equip-card]');
        const unequipBtn = event.target.closest('[data-unequip-card]');
        const upgradeBtn = event.target.closest('[data-upgrade-card]');
        if (equipBtn) {
          const deck = Array.isArray(state.cards.deck) ? state.cards.deck : [];
          const slotIndex = deck.findIndex(id => !id);
          equipCard(equipBtn.dataset.equipCard, slotIndex >= 0 ? slotIndex : 0);
        } else if (unequipBtn) {
          unequipCard(Number(unequipBtn.dataset.unequipCard) || 0);
        } else if (upgradeBtn) {
          upgradeCard(upgradeBtn.dataset.upgradeCard);
        }
      });

      els.upgradeGrid?.addEventListener('click', (event) => {
        const button = event.target.closest('[data-upgrade]');
        if (!button || button.dataset.disabled === 'true') return;
        if (state.busy) return;
        purchaseUpgrade(button.dataset.upgrade);
      });
      els.paytable?.addEventListener('click', (event) => {
        const item = event.target.closest('li[data-active]');
        if (!item) return;
        const active = item.dataset.active === 'true';
        if (active) return;
        focusUpgrade('premium', 'Buy Premium Symbols to unlock more symbols.');
      });

      els.spinBtn.addEventListener('click', spin);
      els.lineFlashBtn?.addEventListener('click', flashActiveLines);
      els.autoSpinBtn?.addEventListener('click', () => {
        if (els.autoSpinBtn.dataset.locked === 'true' || !isAutoSpinUnlocked()) {
          focusUpgrade('autoSpinUnlock', 'Unlock Auto Spin in the Upgrades tab.');
          return;
        }
        startAutoSpin();
      });
      els.creditsChip?.addEventListener('click', () => setPaneActive('upgrades'));
      els.vipChip?.addEventListener('click', () => togglePremiumPanel(true));

      els.resetBtn.addEventListener('click', () => {
        if (state.busy) {
          return;
        }
        if (!state.auth.token && !state.offlineMode) {
          showAuthAlert('Sign in to use the slot machine.');
          return;
        }
        resetLocalProgress();
        if (state.offlineMode) {
          startOfflineDemo();
        } else {
          bootstrap();
        }
      });

      els.syncBtn.addEventListener('click', () => {
        if (state.busy) return;
        if (!state.auth.token && !state.offlineMode) return;
        syncSnapshot(true);
      });

      els.exportStateBtn?.addEventListener('click', exportStateKey);
      els.importStateBtn?.addEventListener('click', importStateKey);

      const purchaseUpgrade = async (type) => {
        const def = getUpgradeDef(type);
        if (!def) {
          showPopup('Upgrade unavailable.');
          debugError('upgrade:missing-def', new Error('Missing upgrade def'), { type });
          return;
        }
        const clientOnly = true;
        const bucket = getMachineUpgrades(state.machine.id);
        const serverLevel = bucket?.[type] || 0;
        const currentLevel = getEffectiveUpgradeLevel(type);
        const maxLevel = getUpgradeMaxLevel(type);
        logAction('upgrade:attempt', { type, currentLevel, maxLevel, balance: machineBalance(), cost: computeUpgradeCost(def, currentLevel) });
        if (currentLevel >= maxLevel) {
          showPopup('Upgrade already maxed.');
          debug('upgrade:maxed', { type, currentLevel, maxLevel, bucket, serverLevel });
          return;
        }
        if (def.requires) {
          const requirements = Array.isArray(def.requires) ? def.requires : [def.requires];
          const met = requirements.every(req => {
            return getEffectiveUpgradeLevel(req) > 0;
          });
          if (!met) {
            showPopup('Unlock the prerequisite upgrade first.');
            debug('upgrade:prereq', { type, requirements, current: state.upgrades });
            return;
          }
        }
        const localBucket = localUpgradeBucket();
        const localLevel = Math.max(0, Number(localBucket[type] || 0));
        // prioritize local level for client-only; allow spending if effective < max
        const cost = computeUpgradeCost(def, currentLevel);
        if (!spendMachineBalance(cost)) {
          showPopup(`Need ${formatMoney(cost)} to upgrade.`);
          debug('upgrade:insufficient', { type, cost, balance: machineBalance() });
          return;
        }
        // Legacy note for server builds: request('/session', { type }) would sync upgrades when online.
        localBucket[type] = localLevel + 1;
        saveLocalUpgrades(localUpgrades);
        ensureMachineProgress(state.machine.id).upgrades = { ...bucket, [type]: serverLevel };
        applyUpgradeState();
        renderUpgrades();
        renderAutoSpinButton();
        updateHud();
        markDirty('upgrade');
        log('Upgrade applied locally', def.label || type);
        const finalLevel = getEffectiveUpgradeLevel(type);
        debug('upgrade:applied', { type, level: finalLevel, bucket: localBucket, serverLevel });
        logAction('upgrade:applied', { type, level: finalLevel, balance: state.balance });
        showAlert(clientOnly ? 'Upgrade applied locally.' : 'Upgrade applied locally (offline).');
      };

      if (els.authSubmit) {
        els.authSubmit.addEventListener('click', loginOrRegister);
      }
      (els.authTabs || []).forEach(btn => {
        btn.addEventListener('click', () => setAuthMode(btn.dataset.mode));
      });
      if (els.authInfo) {
        els.authInfo.addEventListener('click', () => {
          setAuthMode('register');
          els.authEmail?.focus();
        });
      }
      els.logoutBtn.addEventListener('click', logout);
      els.debugCoinBtn?.addEventListener('click', grantDebugCoins);
      els.deleteBtn?.addEventListener('click', deleteAccount);
      els.premiumBtn?.addEventListener('click', () => togglePremiumPanel(true));
      els.premiumClose?.addEventListener('click', () => togglePremiumPanel(false));
      els.premiumPanel?.addEventListener('click', (event) => {
        if (event.target === els.premiumPanel) togglePremiumPanel(false);
      });
      els.premiumGrid?.addEventListener('click', (event) => {
        const btn = event.target.closest('[data-buy-premium]');
        if (!btn) return;
        purchasePremium(btn.dataset.buyPremium);
      });

      // Load upgrades after all helpers are defined to avoid init-order errors
      loadUpgradeCatalog().then(() => {
        setSymbolMap(DEFAULT_SYMBOLS, 'init');
        rebuildSymbolWeights();
      });

      function rebuildSymbolWeights() {
        const pool = Array.isArray(state.machine.activeSymbols) && state.machine.activeSymbols.length
          ? state.machine.activeSymbols
          : Array.from(state.symbolMap.keys());
        const entries = [];
        let total = 0;
        const lvl = ensureMachineProgress(state.machine.id).lvl || 0;
        const perks = getLevelPerkEffects(lvl);
        pool.forEach(key => {
          const payout = state.machine.payouts?.[key] || 1;
          const base = Math.max(1, payout);
          const biasFactor = perks.biasMult || 1;
          const wildFactor = key === 'wild'
            ? (perks.wildWeightMult || 1) * (state.premium?.mods?.wildWeight || 1)
            : 1;
          const weight = Math.max(
            1,
            Math.trunc(((1000 / base) + (Math.sqrt(base) * biasFactor)) * wildFactor)
          );
          total += weight;
          entries.push({ key, weight, total });
        });
        state.symbolWeights = { entries, total };
        debug('symbols:weights', { count: entries.length, total, lvl, bias: perks.biasMult, wild: perks.wildWeightMult });
      }

      const updateMachineCurrencyPill = () => {
        // removed per-machine currency pill
      };

      rebuildSymbolWeights();
    })();
  </script>
</body>
</html>
